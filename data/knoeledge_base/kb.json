{
    "globalThis": "Historically, accessing the global object has required different syntax in different JavaScript environments. On the web you can use window, self, or frames - but in Web Workers only self will work. In Node.js none of these work, and you must instead use global. The this keyword could be used inside functions running in non\u00e2\u0080\u0093strict mode, but this will be undefined in modules and inside functions running in strict mode. You can also use Function('return this')(), but environments that disable eval(), like CSP in browsers, prevent use of Function in this way.\nThe globalThis property provides a standard way of accessing the global this value (and hence the global object itself) across environments. Unlike similar properties such as window and self, it's guaranteed to work in window and non-window contexts. In this way, you can access the global object in a consistent manner without having to know which environment the code is being run in. To help you remember the name, just remember that in global scope the this value is globalThis.\n\nNote: globalThis is generally the same concept as the global object (i.e. adding properties to globalThis makes them global variables) \u00e2\u0080\u0094 this is the case for browsers and Node \u00e2\u0080\u0094 but hosts are allowed to provide a different value for globalThis that's unrelated to the global object.\n ",
    "Infinity": "Infinity is a property of the global object. In other words, it is a variable in global scope.\nThe value Infinity (positive infinity) is greater than any other number.\nThis value behaves slightly differently than mathematical infinity; see Number.POSITIVE_INFINITY for details. ",
    "NaN": "NaN is a property of the global object. In other words, it is a variable in global scope.\nIn modern browsers, NaN is a non-configurable, non-writable property. Even when this is not the case, avoid overriding it.\nThere are five different types of operations that return NaN:\n\nFailed number conversion (e.g. explicit ones like parseInt(\"blabla\"), Number(undefined), or implicit ones like Math.abs(undefined))\nMath operation where the result is not a real number (e.g. Math.sqrt(-1))\nIndeterminate form (e.g. 0 * Infinity, 1 ** Infinity, Infinity / Infinity, Infinity - Infinity)\nA method or expression whose operand is or gets coerced to NaN (e.g. 7 ** NaN, 7 * \"blabla\") \u00e2\u0080\u0094 this means NaN is contagious\nOther cases where an invalid value is to be represented as a number (e.g. an invalid Date new Date(\"blabla\").getTime(), \"\".charCodeAt(1))\n\nNaN and its behaviors are not invented by JavaScript. Its semantics in floating point arithmetic (including that NaN !== NaN) are specified by IEEE 754. NaN's behaviors include:\n\nIf NaN is involved in a mathematical operation (but not bitwise operations), the result is usually also NaN. (See counter-example below.)\nWhen NaN is one of the operands of any relational comparison (>, <, >=, <=), the result is always false.\nNaN compares unequal (via ==, !=, ===, and !==) to any other value \u00e2\u0080\u0094 including to another NaN value.\n\nNaN is also one of the falsy values in JavaScript. ",
    "undefined": "undefined is a property of the global object. That is, it is a variable in global scope.\nIn all non-legacy browsers, undefined is a non-configurable, non-writable property. Even when this is not the case, avoid overriding it.\n\n  A variable that has not been assigned a value is of type undefined. A\n  method or statement also returns undefined if the variable that is being\n  evaluated does not have an assigned value. A function returns undefined if\n  a value was not returned.\n\n\nNote: While you can use undefined as an identifier (variable name) in any scope other than the global scope (because undefined is not a reserved word), doing so is a very bad idea that will make your code difficult to maintain and debug.\njs// DON'T DO THIS\n\n(() => {\n  const undefined = \"foo\";\n  console.log(undefined, typeof undefined); // foo string\n})();\n\n((undefined) => {\n  console.log(undefined, typeof undefined); // foo string\n})(\"foo\");\n\n ",
    "eval()": "eval() is a function property of the global object.\nThe argument of the eval() function is a string. It will evaluate the source string as a script body, which means both statements and expressions are allowed. It returns the completion value of the code. For expressions, it's the value the expression evaluates to. Many statements and declarations have completion values as well, but the result may be surprising (for example, the completion value of an assignment is the assigned value, but the completion value of let is undefined), so it's recommended to not rely on statements' completion values.\nIn strict mode, declaring a variable named eval or re-assigning eval is a SyntaxError.\njs\"use strict\";\n\nconst eval = 1; // SyntaxError: Unexpected eval or arguments in strict mode\n\nIf the argument of eval() is not a string, eval() returns the argument unchanged. In the following example, passing a String object instead of a primitive causes eval() to return the String object rather than evaluating the string.\njseval(new String(\"2 + 2\")); // returns a String object containing \"2 + 2\"\neval(\"2 + 2\"); // returns 4\n\nTo work around the issue in a generic fashion, you can coerce the argument to a string yourself before passing it to eval().\njsconst expression = new String(\"2 + 2\");\neval(String(expression)); // returns 4\n ",
    "isFinite()": "isFinite() is a function property of the global object.\nWhen the argument to the isFinite() function is not of type Number, the value is first coerced to a number, and the resulting value is then compared against NaN and \u00c2\u00b1Infinity. This is as confusing as the behavior of isNaN \u00e2\u0080\u0094 for example, isFinite(\"1\") is true.\nNumber.isFinite() is a more reliable way to test whether a value is a finite number value, because it returns false for any non-number input. ",
    "isNaN()": "isNaN() is a function property of the global object.\nFor number values, isNaN() tests if the number is the value NaN. When the argument to the isNaN() function is not of type Number, the value is first coerced to a number, and the resulting value is then compared against NaN.\nThis behavior of isNaN() for non-numeric arguments can be confusing! For example, an empty string is coerced to 0, while a boolean is coerced to 0 or 1; both values are intuitively \"not numbers\", but they don't evaluate to NaN, so isNaN() returns false. Therefore, isNaN() answers neither the question \"is the input the floating point NaN value\" nor the question \"is the input not a number\".\nNumber.isNaN() is a more reliable way to test whether a value is the number value NaN or not. Alternatively, the expression x !== x can be used, and neither of the solutions is subject to the false positives that make the global isNaN() unreliable. To test if a value is a number, use typeof x === \"number\".\nThe isNaN() function answers the question \"is the input functionally equivalent to NaN when used in a number context\". If isNaN(x) returns false, you can use x in an arithmetic expression as if it's a valid number that's not NaN. If isNaN(x) returns true, x will get coerced to NaN and make most arithmetic expressions return NaN (because NaN propagates). You can use this, for example, to test whether an argument to a function is arithmetically processable (usable \"like\" a number), and handle values that are not number-like by throwing an error, providing a default value, etc. This way, you can have a function that makes use of the full versatility JavaScript provides by implicitly converting values depending on context.\n\nNote: The + operator performs both number addition and string concatenation. Therefore, even if isNaN() returns false for both operands, the + operator may still return a string, because it's not used as an arithmetic operator. For example, isNaN(\"1\") returns false, but \"1\" + 1 returns \"11\". To be sure that you are working with numbers, coerce the value to a number and use Number.isNaN() to test the result.\n ",
    "parseFloat()": "The parseFloat function converts its first argument to a string, parses that string as a decimal number literal, then returns a number or NaN. The number syntax it accepts can be summarized as:\n\nThe characters accepted by parseFloat() are plus sign (+), minus sign (- U+002D HYPHEN-MINUS), decimal digits (0 \u00e2\u0080\u0093 9), decimal point (.), exponent indicator (e or E), and the \"Infinity\" literal.\nThe +/- signs can only appear strictly at the beginning of the string, or immediately following the e/E character. The decimal point can only appear once, and only before the e/E character. The e/E character can only appear once, and only if there is at least one digit before it.\nLeading spaces in the argument are trimmed and ignored.\nparseFloat() can also parse and return Infinity or -Infinity if the string starts with \"Infinity\" or \"-Infinity\" preceded by none or more white spaces.\nparseFloat() picks the longest substring starting from the beginning that generates a valid number literal. If it encounters an invalid character, it returns the number represented up to that point, ignoring the invalid character and all characters following it.\nIf the argument's first character can't start a legal number literal per the syntax above, parseFloat returns NaN.\n\nSyntax-wise, parseFloat() parses a subset of the syntax that the Number() function accepts. Namely, parseFloat() does not support non-decimal literals with 0x, 0b, or 0o prefixes but supports everything else. However, parseFloat() is more lenient than Number() because it ignores trailing invalid characters, which would cause Number() to return NaN.\nSimilar to number literals and Number(), the number returned from parseFloat() may not be exactly equal to the number represented by the string, due to floating point range and inaccuracy. For numbers outside the -1.7976931348623158e+308 \u00e2\u0080\u0093 1.7976931348623158e+308 range (see Number.MAX_VALUE), -Infinity or Infinity is returned. ",
    "parseInt()": "The parseInt function converts its first argument to a string, parses that string, then returns an integer or NaN.\nIf not NaN, the return value will be the integer that is the first argument taken as a number in the specified radix. (For example, a radix of 10 converts from a decimal number, 8 converts from octal, 16 from hexadecimal, and so on.)\nThe radix argument is converted to a number. If it's unprovided, or if the value becomes 0, NaN or Infinity (undefined is coerced to NaN), JavaScript assumes the following:\n\nIf the input string, with leading whitespace and possible +/- signs removed, begins with 0x or 0X (a zero, followed by lowercase or uppercase X), radix is assumed to be 16 and the rest of the string is parsed as a hexadecimal number.\nIf the input string begins with any other value, the radix is 10 (decimal).\n\n\nNote: Other prefixes like 0b, which are valid in number literals, are treated as normal digits by parseInt(). parseInt() does not treat strings beginning with a 0 character as octal values either. The only prefix that parseInt() recognizes is 0x or 0X for hexadecimal values \u00e2\u0080\u0094 everything else is parsed as a decimal value if radix is missing. Number() or BigInt() can be used instead to parse these prefixes.\n\nIf the radix is 16, parseInt() allows the string to be optionally prefixed by 0x or 0X after the optional sign character (+/-).\nIf the radix value (coerced if necessary) is not in range [2, 36] (inclusive) parseInt returns NaN.\nFor radices above 10, letters of the English alphabet indicate numerals greater than 9. For example, for hexadecimal numbers (base 16), A through F are used. The letters are case-insensitive.\nparseInt understands exactly two signs: + for positive, and - for negative. It is done as an initial step in the parsing after whitespace is removed. If no signs are found, the algorithm moves to the following step; otherwise, it removes the sign and runs the number-parsing on the rest of the string.\nIf parseInt encounters a character that is not a numeral in the specified radix, it ignores it and all succeeding characters and returns the integer value parsed up to that point. For example, although 1e3 technically encodes an integer (and will be correctly parsed to the integer 1000 by parseFloat()), parseInt(\"1e3\", 10) returns 1, because e is not a valid numeral in base 10. Because . is not a numeral either, the return value will always be an integer.\nIf the first character cannot be converted to a number with the radix in use, parseInt returns NaN. Leading whitespace is allowed.\nFor arithmetic purposes, the NaN value is not a number in any radix. You can call the Number.isNaN function to determine if the result of parseInt is NaN. If NaN is passed on to arithmetic operations, the operation result will also be NaN.\nBecause large numbers use the e character in their string representation (e.g. 6.022e23 for 6.022 \u00c3\u0097 1023), using parseInt to truncate numbers will produce unexpected results when used on very large or very small numbers. parseInt should not be used as a substitute for Math.trunc().\nTo convert a number to its string literal in a particular radix, use thatNumber.toString(radix).\nBecause parseInt() returns a number, it may suffer from loss of precision if the integer represented by the string is outside the safe range. The BigInt() function supports parsing integers of arbitrary length accurately, by returning a BigInt. ",
    "decodeURI()": "decodeURI() is a function property of the global object.\nThe decodeURI() function decodes the URI by treating each escape sequence in the form %XX as one UTF-8 code unit (one byte). In UTF-8, the number of leading 1 bits in the first byte, which may be 0 (for 1-byte ASCII characters), 2, 3, or 4, indicates the number of bytes in the character. So by reading the first escape sequence, decodeURI() can determine how many more escape sequences to consume. If decodeURI() fails to find the expected number of sequences, or if the escape sequences don't encode a valid UTF-8 character, a URIError is thrown.\ndecodeURI() decodes all escape sequences, but if the escape sequence encodes one of the following characters, the escape sequence is preserved in the output string (because they are part of the URI syntax):\n; / ? : @ & = + $ , #\n ",
    "decodeURIComponent()": "decodeURIComponent() is a function property of the global object.\ndecodeURIComponent() uses the same decoding algorithm as described in decodeURI(). It decodes all escape sequences, including those that are not created by encodeURIComponent, like -.!~*'(). ",
    "encodeURI()": "encodeURI() is a function property of the global object.\nThe encodeURI() function escapes characters by UTF-8 code units, with each octet encoded in the format %XX, left-padded with 0 if necessary. Because lone surrogates in UTF-16 do not encode any valid Unicode character, they cause encodeURI() to throw a URIError.\nencodeURI() escapes all characters except:\nA\u00e2\u0080\u0093Z a\u00e2\u0080\u0093z 0\u00e2\u0080\u00939 - _ . ! ~ * ' ( )\n\n; / ? : @ & = + $ , #\n\nThe characters on the second line are characters that may be part of the URI syntax, and are only escaped by encodeURIComponent(). Both encodeURI() and encodeURIComponent() do not encode the characters -.!~*'(), known as \"unreserved marks\", which do not have a reserved purpose but are allowed in a URI \"as is\". (See RFC2396)\nThe encodeURI() function does not encode characters that have special meaning (reserved characters) for a URI. The following example shows all the parts that a URI can possibly contain. Note how certain characters are used to signify special meaning:\nurlhttp://username:password@www.example.com:80/path/to/file.php?foo=316&bar=this+has+spaces#anchor\n\nencodeURI, as the name implies, is used to encode a URL as a whole, assuming it is already well-formed. If you want to dynamically assemble string values into a URL, you probably want to use encodeURIComponent() on each dynamic segment instead, to avoid URL syntax characters in unwanted places.\njsconst name = \"Ben & Jerry's\";\n\n// This is bad:\nconst link = encodeURI(`https://example.com/?choice=${name}`); // \"https://example.com/?choice=Ben%20&%20Jerry's\"\nconsole.log([...new URL(link).searchParams]); // [['choice', 'Ben '], [\" Jerry's\", '']\n\n// Instead:\nconst link = encodeURI(\n  `https://example.com/?choice=${encodeURIComponent(name)}`,\n);\n// \"https://example.com/?choice=Ben%2520%2526%2520Jerry's\"\nconsole.log([...new URL(link).searchParams]); // [['choice', \"Ben%20%26%20Jerry's\"]]\n ",
    "encodeURIComponent()": "encodeURIComponent() is a function property of the global object.\nencodeURIComponent() uses the same encoding algorithm as described in encodeURI(). It escapes all characters except:\nA\u00e2\u0080\u0093Z a\u00e2\u0080\u0093z 0\u00e2\u0080\u00939 - _ . ! ~ * ' ( )\n\nCompared to encodeURI(), encodeURIComponent() escapes a larger set of characters. Use encodeURIComponent() on user-entered fields from forms POST'd to the server \u00e2\u0080\u0094 this will encode & symbols that may inadvertently be generated during data entry for special HTML entities or other characters that require encoding/decoding. For example, if a user writes Jack & Jill, without encodeURIComponent(), the ampersand could be interpreted on the server as the start of a new field and jeopardize the integrity of the data.\nFor application/x-www-form-urlencoded, spaces are to be replaced by +, so one may wish to follow a encodeURIComponent() replacement with an additional replacement of %20 with +. ",
    "escape()": "escape() is a function property of the global object.\nThe escape() function replaces all characters with escape sequences, with the exception of ASCII word characters (A\u00e2\u0080\u0093Z, a\u00e2\u0080\u0093z, 0\u00e2\u0080\u00939, _) and @\\*_+-./. Characters are escaped by UTF-16 code units. If the code unit's value is less than 256, it is represented by a two-digit hexadecimal number in the format %XX, left-padded with 0 if necessary. Otherwise, it is represented by a four-digit hexadecimal number in the format %uXXXX, left-padded with 0 if necessary.\n\nNote: This function was used mostly for URL encoding and is partly based on the escape format in RFC 1738. The escape format is not an escape sequence in string literals. You can replace %XX with \\xXX and %uXXXX with \\uXXXX to get a string containing actual string-literal escape sequences.\n ",
    "unescape()": "unescape() is a function property of the global object.\nThe unescape() function replaces any escape sequence with the character that it represents. Specifically, it replaces any escape sequence of the form %XX or %uXXXX (where X represents one hexadecimal digit) with the character that has the hexadecimal value XX/XXXX. If the escape sequence is not a valid escape sequence (for example, if % is followed by one or no hex digit), it is left as-is.\n\nNote: This function was used mostly for URL encoding and is partly based on the escape format in RFC 1738. The unescape() function does not evaluate escape sequences in string literals. You can replace \\xXX with %XX and \\uXXXX with %uXXXX to get a string that can be handled by unescape().\n ",
    "Object.prototype.__proto__": "The __proto__ getter function exposes the value of the internal [[Prototype]] of an object. For objects created using an object literal (unless you use the prototype setter syntax), this value is Object.prototype. For objects created using array literals, this value is Array.prototype. For functions, this value is Function.prototype. You can read more about the prototype chain in Inheritance and the prototype chain.\nThe __proto__ setter allows the [[Prototype]] of an object to be mutated. The value provided must be an object or null. Providing any other value will do nothing.\nUnlike Object.getPrototypeOf() and Object.setPrototypeOf(), which are always available on Object as static properties and always reflect the [[Prototype]] internal property, the __proto__ property doesn't always exist as a property on all objects, and as a result doesn't reflect [[Prototype]] reliably.\nThe __proto__ property is a simple accessor property on Object.prototype consisting of a getter and setter function. A property access for __proto__ that eventually consults Object.prototype will find this property, but an access that does not consult Object.prototype will not. If some other __proto__ property is found before Object.prototype is consulted, that property will hide the one found on Object.prototype.\nnull-prototype objects don't inherit any property from Object.prototype, including the __proto__ accessor property, so if you try to read __proto__ on such an object, the value is always undefined regardless of the object's actual [[Prototype]], and any assignment to __proto__ would create a new property called __proto__ instead of setting the object's prototype. Furthermore, __proto__ can be redefined as an own property on any object instance through Object.defineProperty() without triggering the setter. In this case, __proto__ will no longer be an accessor for [[Prototype]]. Therefore, always prefer Object.getPrototypeOf() and Object.setPrototypeOf() for setting and getting the [[Prototype]] of an object. ",
    "Object.prototype.toLocaleString()": "All objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the toLocaleString() method. Object's toLocaleString returns the result of calling this.toString().\nThis function is provided to give objects a generic toLocaleString method, even though not all may use it. In the core language, these built-in objects override toLocaleString to provide locale-specific formatting:\n\nArray: Array.prototype.toLocaleString()\nNumber: Number.prototype.toLocaleString()\nDate: Date.prototype.toLocaleString()\nTypedArray: TypedArray.prototype.toLocaleString()\nBigInt: BigInt.prototype.toLocaleString()\n ",
    "Object.preventExtensions()": "\n  An object is extensible if new properties can be added to it.\n  Object.preventExtensions() marks an object as no longer extensible, so that\n  it will never have properties beyond the ones it had at the time it was marked as\n  non-extensible. Note that the properties of a non-extensible object, in general, may\n  still be deleted. Attempting to add new properties to a non-extensible object\n  will fail, either silently or, in strict mode, throwing a TypeError.\n\nUnlike Object.seal() and Object.freeze(), Object.preventExtensions() invokes an intrinsic JavaScript behavior and cannot be replaced with a composition of several other operations. It also has its Reflect counterpart (which only exists for intrinsic operations), Reflect.preventExtensions().\nObject.preventExtensions() only prevents addition of own properties. Properties can still be added to the object prototype.\nThis method makes the [[Prototype]] of the target immutable; any [[Prototype]] re-assignment will throw a TypeError. This behavior is specific to the internal [[Prototype]] property; other properties of the target object will remain mutable.\nThere is no way to make an object extensible again once it has been made non-extensible. ",
    "Object.isSealed()": "\n  Returns true if the object is sealed, otherwise false. An\n  object is sealed if it is not extensible and\n  if all its properties are non-configurable and therefore not removable (but not\n  necessarily non-writable).\n ",
    "Object.setPrototypeOf()": "Object.setPrototypeOf() is generally considered the proper way to set the prototype of an object. You should always use it in favor of the deprecated Object.prototype.__proto__ accessor.\nIf the obj parameter is not an object (e.g. number, string, etc.), this method does nothing \u00e2\u0080\u0094 without coercing it to an object or attempting to set its prototype \u00e2\u0080\u0094 and directly returns obj as a primitive value. If prototype is the same value as the prototype of obj, then obj is directly returned, without causing a TypeError even when obj has immutable prototype.\nFor security concerns, there are certain built-in objects that are designed to have an immutable prototype. This prevents prototype pollution attacks, especially proxy-related ones. The core language only specifies Object.prototype as an immutable prototype exotic object, whose prototype is always null. In browsers, window and location are two other very common examples.\njsObject.isExtensible(Object.prototype); // true; you can add more properties\nObject.setPrototypeOf(Object.prototype, {}); // TypeError: Immutable prototype object '#<Object>' cannot have their prototype set\nObject.setPrototypeOf(Object.prototype, null); // No error; the prototype of `Object.prototype` is already `null`\n ",
    "Object.prototype.propertyIsEnumerable()": "All objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the propertyIsEnumerable() method. This method determines if the specified property, string or symbol, is an enumerable own property of the object. If the object does not have the specified property, this method returns false.\nThis method is equivalent to Object.getOwnPropertyDescriptor(obj, prop)?.enumerable ?? false. ",
    "Object.create()": "The Object.create() static method creates a new object, using an existing object as the prototype of the newly created object. ",
    "Object.freeze()": "Freezing an object is equivalent to preventing extensions and then changing all existing properties' descriptors' configurable to false \u00e2\u0080\u0094 and for data properties, writable to false as well. Nothing can be added to or removed from the properties set of a frozen object. Any attempt to do so will fail, either silently or by throwing a TypeError exception (most commonly, but not exclusively, when in strict mode).\n\n  For data properties of a frozen object, their values cannot be changed since the writable and\n  configurable attributes are set to false. Accessor properties (getters and setters) work the same \u00e2\u0080\u0094 the property value returned by the getter may still change, and the setter can still be called without throwing errors when setting the property. Note that values\n  that are objects can still be modified, unless they are also frozen. As an object, an\n  array can be frozen; after doing so, its elements cannot be altered and no elements can\n  be added to or removed from the array.\n\nPrivate properties do not have the concept of property descriptors. Freezing an object with private properties does not prevent the values of these private properties from being changed. (Freezing objects is usually meant as a security measure against external code, but external code cannot access private properties anyway.) Private properties cannot be added or removed from the object, whether the object is frozen or not.\n\nfreeze() returns the same object that was passed into the function. It\n  does not create a frozen copy.\n\n\n  A TypedArray or a DataView with elements will cause a TypeError,\n  as they are views over memory and will definitely cause other possible issues:\n\njsObject.freeze(new Uint8Array(0)); // No elements\n// Uint8Array []\n\nObject.freeze(new Uint8Array(1)); // Has elements\n// TypeError: Cannot freeze array buffer views with elements\n\nObject.freeze(new DataView(new ArrayBuffer(32))); // No elements\n// DataView {}\n\nObject.freeze(new Float64Array(new ArrayBuffer(64), 63, 0)); // No elements\n// Float64Array []\n\nObject.freeze(new Float64Array(new ArrayBuffer(64), 32, 2)); // Has elements\n// TypeError: Cannot freeze array buffer views with elements\n\n\n  Note that as the standard three properties (buf.byteLength,\n  buf.byteOffset and buf.buffer) are read-only (as are those of\n  an ArrayBuffer or SharedArrayBuffer), there is no reason for\n  attempting to freeze these properties.\n\nUnlike Object.seal(), existing properties in objects frozen with Object.freeze() are made immutable and data properties cannot be re-assigned. ",
    "Object.defineProperty()": "Object.defineProperty() allows a precise addition to or modification of a property on an object. Normal property addition through assignment creates properties which show up during property enumeration (for...in, Object.keys(), etc.), whose values may be changed and which may be deleted. This method allows these extra details to be changed from their defaults. By default, properties added using Object.defineProperty() are not writable, not enumerable, and not configurable. In addition, Object.defineProperty() uses the [[DefineOwnProperty]] internal method, instead of [[Set]], so it does not invoke setters, even when the property is already present.\nProperty descriptors present in objects come in two main flavors: data descriptors and accessor descriptors. A data descriptor is a property with a value that may or may not be writable. An accessor descriptor is a property described by a getter-setter pair of functions. A descriptor must be one of these two flavors; it cannot be both.\nBoth data and accessor descriptors are objects. They share the following optional keys (please note: the defaults mentioned here are in the case of defining properties using Object.defineProperty()):\n\nconfigurable\n\nwhen this is set to false,\n\nthe type of this property cannot be changed between data property and accessor property, and\nthe property may not be deleted, and\nother attributes of its descriptor cannot be changed (however, if it's a data descriptor with writable: true, the value can be changed, and writable can be changed to false).\n\nDefaults to false.\n\nenumerable\n\ntrue if and only if this property shows up during enumeration of the properties on the corresponding object. Defaults to false.\n\n\nA data descriptor also has the following optional keys:\n\nvalue\n\nThe value associated with the property. Can be any valid JavaScript value (number, object, function, etc.). Defaults to undefined.\n\nwritable\n\ntrue if the value associated with the property may be changed with an assignment operator. Defaults to false.\n\n\nAn accessor descriptor also has the following optional keys:\n\nget\n\nA function which serves as a getter for the property, or undefined if there is no getter. When the property is accessed, this function is called without arguments and with this set to the object through which the property is accessed (this may not be the object on which the property is defined due to inheritance). The return value will be used as the value of the property. Defaults to undefined.\n\nset\n\nA function which serves as a setter for the property, or undefined if there is no setter. When the property is assigned, this function is called with one argument (the value being assigned to the property) and with this set to the object through which the property is assigned. Defaults to undefined.\n\n\nIf a descriptor doesn't have any of the value, writable, get, and set keys, it is treated as a data descriptor. If a descriptor has both [value or writable] and [get or set] keys, an exception is thrown.\nThese attributes are not necessarily the descriptor's own properties. Inherited properties will be considered as well. In order to ensure these defaults are preserved, you might freeze existing objects in the descriptor object's prototype chain upfront, specify all options explicitly, or create a null-prototype object.\njsconst obj = {};\n// 1. Using a null prototype: no inherited properties\nconst descriptor = Object.create(null);\ndescriptor.value = \"static\";\n\n// not enumerable, not configurable, not writable as defaults\nObject.defineProperty(obj, \"key\", descriptor);\n\n// 2. Being explicit by using a throw-away object literal with all attributes present\nObject.defineProperty(obj, \"key2\", {\n  enumerable: false,\n  configurable: false,\n  writable: false,\n  value: \"static\",\n});\n\n// 3. Recycling same object\nfunction withValue(value) {\n  const d =\n    withValue.d ||\n    (withValue.d = {\n      enumerable: false,\n      writable: false,\n      configurable: false,\n      value,\n    });\n\n  // avoiding duplicate operation for assigning value\n  if (d.value !== value) d.value = value;\n\n  return d;\n}\n// and\nObject.defineProperty(obj, \"key\", withValue(\"static\"));\n\n// if freeze is available, prevents adding or\n// removing the object prototype properties\n// (value, get, set, enumerable, writable, configurable)\n(Object.freeze || Object)(Object.prototype);\n\nWhen the property already exists, Object.defineProperty() attempts to modify the property according to the values in the descriptor and the property's current configuration.\nIf the old descriptor had its configurable attribute set to false, the property is said to be non-configurable. It is not possible to change any attribute of a non-configurable accessor property, and it is not possible to switch between data and accessor property types. For data properties with writable: true, it is possible to modify the value and change the writable attribute from true to false. A TypeError is thrown when attempts are made to change non-configurable property attributes (except value and writable, if permitted), except when defining a value same as the original value on a data property.\nWhen the current property is configurable, defining an attribute to undefined effectively deletes it. For example, if o.k is an accessor property, Object.defineProperty(o, \"k\", { set: undefined }) will remove the setter, making k only have a getter and become readonly. If an attribute is absent from the new descriptor, the old descriptor attribute's value is kept (it won't be implicitly re-defined to undefined). It is possible to toggle between data and accessor property by giving a descriptor of a different \"flavor\". For example, if the new descriptor is a data descriptor (with value or writable), the original descriptor's get and set attributes will both be dropped. ",
    "Object.prototype.valueOf()": "JavaScript calls the valueOf method to convert an object to a primitive value. You rarely need to invoke the valueOf method yourself; JavaScript automatically invokes it when encountering an object where a primitive value is expected.\nThis method is called in priority by numeric conversion and primitive conversion, but string conversion calls toString() in priority, and toString() is very likely to return a string value (even for the Object.prototype.toString() base implementation), so valueOf() is usually not called in this case.\nAll objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the toString() method. The Object.prototype.valueOf() base implementation is deliberately useless: by returning an object, its return value will never be used by any primitive conversion algorithm. Many built-in objects override this method to return an appropriate primitive value. When you create a custom object, you can override valueOf() to call a custom method, so that your custom object can be converted to a primitive value. Generally, valueOf() is used to return a value that is most meaningful for the object \u00e2\u0080\u0094 unlike toString(), it does not need to be a string. Alternatively, you can add a @@toPrimitive method, which allows even more control over the conversion process, and will always be preferred over valueOf or toString for any type conversion. ",
    "Object.entries()": "Object.entries() returns an array whose elements are arrays corresponding to the enumerable string-keyed property key-value pairs found directly upon object. This is the same as iterating with a for...in loop, except that a for...in loop enumerates properties in the prototype chain as well. The order of the array returned by Object.entries() is the same as that provided by a for...in loop.\nIf you only need the property keys, use Object.keys() instead. If you only need the property values, use Object.values() instead. ",
    "Object.getPrototypeOf()": "\n  The Object.getPrototypeOf() static method returns the prototype\n  (i.e. the value of the internal [[Prototype]] property) of the specified\n  object.\n ",
    "Object.hasOwn()": "\n  The Object.hasOwn() method returns true if the specified property is a\n  direct property of the object \u00e2\u0080\u0094 even if the property value is null or undefined.\n  The method returns false if the property is inherited, or has not been declared at all.\n  Unlike the in operator, this\n  method does not check for the specified property in the object's prototype chain.\n\n\n  It is recommended over Object.prototype.hasOwnProperty() because\n  it works for null-prototype objects and with objects that\n  have overridden the inherited hasOwnProperty() method. While it is possible to\n  workaround these problems by calling Object.prototype.hasOwnProperty() on an\n  external object, Object.hasOwn() is more intuitive.\n ",
    "Object.fromEntries()": "The Object.fromEntries() method takes a list of key-value pairs and returns a new object whose properties are given by those entries. The iterable argument is expected to be an object that implements an @@iterator method. The method returns an iterator object that produces two-element array-like objects. The first element is a value that will be used as a property key, and the second element is the value to associate with that property key.\nObject.fromEntries() performs the reverse of Object.entries(), except that Object.entries() only returns string-keyed properties, while Object.fromEntries() can also create symbol-keyed properties.\n\nNote: Unlike Array.from(), Object.fromEntries() does not use the value of this, so calling it on another constructor does not create objects of that type.\n ",
    "Object() constructor": "The Object() constructor turns the input into an object. Its behavior depends on the input's type. ",
    "Object.assign()": "\n  Properties in the target object are overwritten by properties in the sources if they\n  have the same key. Later sources' properties\n  overwrite earlier ones.\n\n\n  The Object.assign() method only copies enumerable and\n  own properties from a source object to a target object. It uses\n  [[Get]] on the source and [[Set]] on the target, so it will\n  invoke getters and setters. Therefore it\n  assigns properties, versus copying or defining new properties. This may make it\n  unsuitable for merging new properties into a prototype if the merge sources contain\n  getters.\n\n\n  For copying property definitions (including their enumerability) into prototypes, use\n  Object.getOwnPropertyDescriptor() and\n  Object.defineProperty() instead.\n\nBoth String and Symbol properties are copied.\n\n  In case of an error, for example if a property is non-writable, a\n  TypeError is raised, and the target object is\n  changed if any properties are added before the error is raised.\n\n\n\nNote: Object.assign() does not throw on\n    null or undefined sources.\n  \n ",
    "Object.prototype.__lookupSetter__()": "All objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the __lookupSetter__() method. If a setter has been defined for an object's property, it's not possible to reference the setter function through that property, because that property only calls the function when it's being set. __lookupSetter__() can be used to obtain a reference to the setter function.\n__lookupSetter__() walks up the prototype chain to find the specified property. If any object along the prototype chain has the specified own property, the set attribute of the property descriptor for that property is returned. If that property is a data property, undefined is returned. If the property is not found along the entire prototype chain, undefined is also returned.\n__lookupSetter__() is defined in the spec as \"normative optional\", which means no implementation is required to implement this. However, all major browsers implement it, and due to its continued usage, it's unlikely to be removed. If a browser implements __lookupSetter__(), it also needs to implement the __lookupGetter__(), __defineGetter__(), and __defineSetter__() methods. ",
    "Object.keys()": "Object.keys() returns an array whose elements are strings corresponding to the enumerable string-keyed property names found directly upon object. This is the same as iterating with a for...in loop, except that a for...in loop enumerates properties in the prototype chain as well. The order of the array returned by Object.keys() is the same as that provided by a for...in loop.\nIf you need the property values, use Object.values() instead. If you need both the property keys and values, use Object.entries() instead. ",
    "Object.groupBy()": "Object.groupBy() calls a provided callbackFn function once for each element in an iterable. The callback function should return a string or symbol (values that are neither type are coerced to strings) indicating the group of the associated element. The values returned by callbackFn are used as keys for the object returned by Map.groupBy(). Each key has an associated array containing all the elements for which the callback returned the same value.\nThe elements in the returned object and the original iterable are the same (not deep copies). Changing the internal structure of the elements will be reflected in both the original iterable and the returned object. ",
    "Object.is()": "Object.is() determines whether two values are the same value. Two values are the same if one of the following holds:\n\nboth undefined\nboth null\nboth true or both false\nboth strings of the same length with the same characters in the same order\nboth the same object (meaning both values reference the same object in memory)\nboth BigInts with the same numeric value\nboth symbols that reference the same symbol value\nboth numbers and\n    \nboth +0\nboth -0\nboth NaN\nor both non-zero, not NaN, and have the same value\n\n\n\nObject.is() is not equivalent to the == operator. The == operator applies various coercions to both sides (if they are not the same type) before testing for equality (resulting in such behavior as \"\" == false being true), but Object.is() doesn't coerce either value.\nObject.is() is also not equivalent to the === operator. The only difference between Object.is() and === is in their treatment of signed zeros and NaN values. The === operator (and the == operator) treats the number values -0 and +0 as equal, but treats NaN as not equal to each other. ",
    "Object.defineProperties()": "\n  The Object.defineProperties() static method defines new or\n  modifies existing properties directly on an object, returning the object.\n ",
    "Object.isExtensible()": "Objects are extensible by default: they can have new properties added to them, and their [[Prototype]] can be re-assigned. An object can be marked as non-extensible using one of Object.preventExtensions(), Object.seal(), Object.freeze(), or Reflect.preventExtensions(). ",
    "Object.isFrozen()": "\n  An object is frozen if and only if it is not extensible, all its properties are non-configurable, and all its data\n  properties (that is, properties which are not accessor properties with getter or setter\n  components) are non-writable.\n ",
    "Object.getOwnPropertyDescriptor()": "\n  This method permits examination of the precise description of a property. A\n  property in JavaScript consists of either a string-valued name or a\n  Symbol and a property descriptor. Further information about property\n  descriptor types and their attributes can be found in\n  Object.defineProperty().\n\nA property descriptor is a record with some of the following attributes:\n\nvalue\n\nThe value associated with the property (data descriptors only).\n\nwritable\n\n\ntrue if and only if the value associated with the property may be\n      changed (data descriptors only).\n    \n\nget\n\n\n      A function which serves as a getter for the property, or undefined if\n      there is no getter (accessor descriptors only).\n    \n\nset\n\n\n      A function which serves as a setter for the property, or undefined if\n      there is no setter (accessor descriptors only).\n    \n\nconfigurable\n\n\ntrue if and only if the type of this property descriptor may be changed\n      and if the property may be deleted from the corresponding object.\n    \n\nenumerable\n\n\ntrue if and only if this property shows up during enumeration of the\n      properties on the corresponding object.\n    \n\n ",
    "Object.prototype.__lookupGetter__()": "All objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the __lookupGetter__() method. If a getter has been defined for an object's property, it's not possible to reference the getter function through that property, because that property refers to the return value of that function. __lookupGetter__() can be used to obtain a reference to the getter function.\n__lookupGetter__() walks up the prototype chain to find the specified property. If any object along the prototype chain has the specified own property, the get attribute of the property descriptor for that property is returned. If that property is a data property, undefined is returned. If the property is not found along the entire prototype chain, undefined is also returned.\n__lookupGetter__() is defined in the spec as \"normative optional\", which means no implementation is required to implement this. However, all major browsers implement it, and due to its continued usage, it's unlikely to be removed. If a browser implements __lookupGetter__(), it also needs to implement the __lookupSetter__(), __defineGetter__(), and __defineSetter__() methods. ",
    "Object.getOwnPropertyDescriptors()": "\n  This method permits examination of the precise description of all own properties of an\n  object. A property in JavaScript consists of either a string-valued name or a\n  Symbol and a property descriptor. Further information about property\n  descriptor types and their attributes can be found in\n  Object.defineProperty().\n\nA property descriptor is a record with some of the following attributes:\n\nvalue\n\nThe value associated with the property (data descriptors only).\n\nwritable\n\n\ntrue if and only if the value associated with the property may be\n      changed (data descriptors only).\n    \n\nget\n\n\n      A function which serves as a getter for the property, or undefined if\n      there is no getter (accessor descriptors only).\n    \n\nset\n\n\n      A function which serves as a setter for the property, or undefined if\n      there is no setter (accessor descriptors only).\n    \n\nconfigurable\n\n\ntrue if and only if the type of this property descriptor may be changed\n      and if the property may be deleted from the corresponding object.\n    \n\nenumerable\n\n\ntrue if and only if this property shows up during enumeration of the\n      properties on the corresponding object.\n    \n\n ",
    "Object.prototype.hasOwnProperty()": "\n  The hasOwnProperty() method returns true if the specified property is a\n  direct property of the object \u00e2\u0080\u0094 even if the value is null or undefined. The\n  method returns false if the property is inherited, or has not been declared at\n  all. Unlike the in operator, this\n  method does not check for the specified property in the object's prototype\n  chain.\n\n\n  The method can be called on most JavaScript objects, because most objects\n  descend from Object, and hence inherit its methods. For\n  example Array is an Object, so you can\n  use hasOwnProperty() method to check whether an index exists:\n\njsconst fruits = [\"Apple\", \"Banana\", \"Watermelon\", \"Orange\"];\nfruits.hasOwnProperty(3); // true ('Orange')\nfruits.hasOwnProperty(4); // false - not defined\n\n\n  The method will not be available in objects where it is reimplemented, or on\n  null-prototype objects (as these don't inherit from\n  Object.prototype). Examples for these cases are given below.\n ",
    "Object.seal()": "\n  Sealing an object is equivalent to preventing extensions and then changing all existing properties' descriptors to configurable: false. This has the effect of making the set of properties on the object fixed. Making all properties non-configurable\n  also prevents them from being converted from data properties to accessor properties and\n  vice versa, but it does not prevent the values of data properties from being changed.\n  Attempting to delete or add properties to a sealed object, or to convert a data property\n  to accessor or vice versa, will fail, either silently or by throwing a\n  TypeError (most commonly, although not exclusively, when in\n  strict mode code).\n\nPrivate properties do not have the concept of property descriptors. Private properties cannot be added or removed from the object, whether the object is sealed or not.\nThe prototype chain remains untouched. However, due to the effect of preventing extensions, the [[Prototype]] cannot be reassigned.\n\n  Unlike Object.freeze(), objects sealed with Object.seal() may have their existing\n  properties changed, as long as they are writable.\n ",
    "Object.prototype.toString()": "JavaScript calls the toString method to convert an object to a primitive value. You rarely need to invoke the toString method yourself; JavaScript automatically invokes it when encountering an object where a primitive value is expected.\nThis method is called in priority by string conversion, but numeric conversion and primitive conversion call valueOf() in priority. However, because the base valueOf() method returns an object, the toString() method is usually called in the end, unless the object overrides valueOf(). For example, +[1] returns 1, because its toString() method returns \"1\", which is then converted to a number.\nAll objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the toString() method. When you create a custom object, you can override toString() to call a custom method, so that your custom object can be converted to a string value. Alternatively, you can add a @@toPrimitive method, which allows even more control over the conversion process, and will always be preferred over valueOf or toString for any type conversion.\nTo use the base Object.prototype.toString() with an object that has it overridden (or to invoke it on null or undefined), you need to call Function.prototype.call() or Function.prototype.apply() on it, passing the object you want to inspect as the first parameter (called thisArg).\njsconst arr = [1, 2, 3];\n\narr.toString(); // \"1,2,3\"\nObject.prototype.toString.call(arr); // \"[object Array]\"\n\nObject.prototype.toString() returns \"[object Type]\", where Type is the object type. If the object has a Symbol.toStringTag property whose value is a string, that value will be used as the Type. Many built-in objects, including Map and Symbol, have a Symbol.toStringTag. Some objects predating ES6 do not have Symbol.toStringTag, but have a special tag nonetheless. They include (the tag is the same as the type name given below):\n\nArray\nFunction (anything whose typeof returns \"function\")\nError\nBoolean\nNumber\nString\nDate\nRegExp\n\nThe arguments object returns \"[object Arguments]\". Everything else, including user-defined classes, unless with a custom Symbol.toStringTag, will return \"[object Object]\".\nObject.prototype.toString() invoked on null and undefined returns [object Null] and [object Undefined], respectively. ",
    "Object.getOwnPropertySymbols()": "Similar to Object.getOwnPropertyNames(), you can get all symbol properties of a given object as an array of symbols. Note that Object.getOwnPropertyNames() itself does not contain the symbol properties of an object and only the string properties.\nAs all objects have no own symbol properties initially, Object.getOwnPropertySymbols() returns an empty array unless you have set symbol properties on your object. ",
    "Object.getOwnPropertyNames()": "Object.getOwnPropertyNames() returns an array whose elements are strings corresponding to the enumerable and non-enumerable properties found directly in a given object obj. The ordering of the enumerable properties in the array is consistent with the ordering exposed by a for...in loop (or by Object.keys()) over the properties of the object. The non-negative integer keys of the object (both enumerable and non-enumerable) are added in ascending order to the array first, followed by the string keys in the order of insertion.\nIn ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError. In ES2015, a non-object argument will be coerced to an object.\njsObject.getOwnPropertyNames(\"foo\");\n// TypeError: \"foo\" is not an object (ES5 code)\n\nObject.getOwnPropertyNames(\"foo\");\n// [\"0\", \"1\", \"2\", \"length\"]  (ES2015 code)\n ",
    "Object.prototype.constructor": "Any object (with the exception of null prototype objects) will have a constructor property on its [[Prototype]]. Objects created with literals will also have a constructor property that points to the constructor type for that object \u00e2\u0080\u0094 for example, array literals create Array objects, and object literals create plain objects.\njsconst o1 = {};\no1.constructor === Object; // true\n\nconst o2 = new Object();\no2.constructor === Object; // true\n\nconst a1 = [];\na1.constructor === Array; // true\n\nconst a2 = new Array();\na2.constructor === Array; // true\n\nconst n = 3;\nn.constructor === Number; // true\n\nNote that constructor usually comes from the constructor's prototype property. If you have a longer prototype chain, you can usually expect every object in the chain to have a constructor property.\njsconst o = new TypeError(); // Inheritance: TypeError -> Error -> Object\nconst proto = Object.getPrototypeOf;\n\nObject.hasOwn(o, \"constructor\"); // false\nproto(o).constructor === TypeError; // true\nproto(proto(o)).constructor === Error; // true\nproto(proto(proto(o))).constructor === Object; // true\n ",
    "Object.prototype.__defineGetter__()": "All objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the __defineGetter__() method. This method allows a getter to be defined on a pre-existing object. This is equivalent to Object.defineProperty(obj, prop, { get: func, configurable: true, enumerable: true }), which means the property is enumerable and configurable, and any existing setter, if present, is preserved.\n__defineGetter__() is defined in the spec as \"normative optional\", which means no implementation is required to implement this. However, all major browsers implement it, and due to its continued usage, it's unlikely to be removed. If a browser implements __defineGetter__(), it also needs to implement the __lookupGetter__(), __lookupSetter__(), and __defineSetter__() methods. ",
    "Object.prototype.isPrototypeOf()": "All objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the isPrototypeOf() method. This method allows you to check whether or not the object exists within another object's prototype chain. If the object passed as the parameter is not an object (i.e. a primitive), the method directly returns false. Otherwise, the this value is converted to an object, and the prototype chain of object is searched for the this value, until the end of the chain is reached or the this value is found. ",
    "Object.values()": "Object.values() returns an array whose elements are values of enumerable string-keyed properties found directly upon object. This is the same as iterating with a for...in loop, except that a for...in loop enumerates properties in the prototype chain as well. The order of the array returned by Object.values() is the same as that provided by a for...in loop.\nIf you need the property keys, use Object.keys() instead. If you need both the property keys and values, use Object.entries() instead. ",
    "Object.prototype.__defineSetter__()": "All objects that inherit from Object.prototype (that is, all except null-prototype objects) inherit the __defineSetter__() method. This method allows a setter to be defined on a pre-existing object. This is equivalent to Object.defineProperty(obj, prop, { set: func, configurable: true, enumerable: true }), which means the property is enumerable and configurable, and any existing getter, if present, is preserved.\n__defineSetter__() is defined in the spec as \"normative optional\", which means no implementation is required to implement this. However, all major browsers implement it, and due to its continued usage, it's unlikely to be removed. If a browser implements __defineSetter__(), it also needs to implement the __lookupGetter__(), __lookupSetter__(), and __defineGetter__() methods. ",
    "Function.prototype.apply()": "\nNote: This function is almost identical to call(), except that the function arguments are passed to call() individually as a list, while for apply() they are combined in one object, typically an array \u00e2\u0080\u0094 for example, func.call(this, \"eat\", \"bananas\") vs. func.apply(this, [\"eat\", \"bananas\"]).\n\nNormally, when calling a function, the value of this inside the function is the object that the function was accessed on. With apply(), you can assign an arbitrary value as this when calling an existing function, without first attaching the function to the object as a property. This allows you to use methods of one object as generic utility functions.\nYou can also use any kind of object which is array-like as the second parameter. In practice, this means that it needs to have a length property, and integer (\"index\") properties in the range (0..length - 1). For example, you could use a NodeList, or a custom object like { 'length': 2, '0': 'eat', '1': 'bananas' }. You can also use arguments, for example:\njsfunction wrapper() {\n  return anotherFn.apply(null, arguments);\n}\n\nWith the rest parameters and parameter spread syntax, this can be rewritten as:\njsfunction wrapper(...args) {\n  return anotherFn(...args);\n}\n\nIn general, fn.apply(null, args) is equivalent to fn(...args) with the parameter spread syntax, except args is expected to be an array-like object in the former case with apply(), and an iterable object in the latter case with spread syntax.\n\nWarning: Do not use apply() to chain constructors (for example, to implement inheritance). This invokes the constructor function as a plain function, which means new.target is undefined, and classes throw an error because they can't be called without new. Use Reflect.construct() or extends instead.\n ",
    "Function() constructor": "Function objects created with the Function constructor are parsed when the function is created. This is less efficient than creating a function with a function expression or function declaration and calling it within your code, because such functions are parsed with the rest of the code.\nAll arguments passed to the function, except the last, are treated as the names of the identifiers of the parameters in the function to be created, in the order in which they are passed. The function will be dynamically compiled as a function expression, with the source assembled in the following fashion:\njs`function anonymous(${args.join(\",\")}\n) {\n${functionBody}\n}`;\n\nThis is observable by calling the function's toString() method.\nHowever, unlike normal function expressions, the name anonymous is not added to the functionBody's scope, since functionBody only has access the global scope. If functionBody is not in strict mode (the body itself needs to have the \"use strict\" directive since it doesn't inherit the strictness from the context), you may use arguments.callee to refer to the function itself. Alternatively, you can define the recursive part as an inner function:\njsconst recursiveFn = new Function(\n  \"count\",\n  `\n(function recursiveFn(count) {\n  if (count < 0) {\n    return;\n  }\n  console.log(count);\n  recursiveFn(count - 1);\n})(count);\n`,\n);\n\nNote that the two dynamic parts of the assembled source \u00e2\u0080\u0094 the parameters list args.join(\",\") and functionBody \u00e2\u0080\u0094 will first be parsed separately to ensure they are each syntactically valid. This prevents injection-like attempts.\njsnew Function(\"/*\", \"*/) {\");\n// SyntaxError: Unexpected end of arg string\n// Doesn't become \"function anonymous(/*) {*/) {}\"\n ",
    "Function: displayName": "The displayName property, if present, may be preferred by consoles and profilers over the name property to be displayed as the name of a function.\nAmong browsers, only the Firefox console utilizes this property. React devtools also use the displayName property when displaying the component tree.\nFirefox does some basic attempts to decode the displayName that's possibly generated by the anonymous JavaScript functions naming convention algorithm. The following patterns are detected:\n\nIf displayName ends with a sequence of alphanumeric characters, _, and $, the longest such suffix is displayed.\nIf displayName ends with a sequence of []-enclosed characters, that sequence is displayed without the square brackets.\nIf displayName ends with a sequence of alphanumeric characters and _ followed by some /, ., or <, the sequence is returned without the trailing /, ., or < characters.\nIf displayName ends with a sequence of alphanumeric characters and _ followed by (^), the sequence is displayed without the (^).\n\nIf none of the above patterns match, the entire displayName is displayed. ",
    "Function: prototype": "When a function is called with new, the constructor's prototype property will become the resulting object's prototype.\njsfunction Ctor() {}\nconst inst = new Ctor();\nconsole.log(Object.getPrototypeOf(inst) === Ctor.prototype); // true\n\nYou can read Inheritance and the prototype chain for more information about the interactions between a constructor function's prototype property and the resulting object's prototype.\nA function having a prototype property is not sufficient for it to be eligible as a constructor. Generator functions have a prototype property, but cannot be called with new:\njsasync function* asyncGeneratorFunction() {}\nfunction* generatorFunction() {}\n\nInstead, generator functions' prototype property is used when they are called without new. The prototype property will become the returned Generator object's prototype.\nIn addition, some functions may have a prototype but throw unconditionally when called with new. For example, the Symbol() and BigInt() functions throw when called with new, because Symbol.prototype and BigInt.prototype are only intended to provide methods for the primitive values, but the wrapper objects should not be directly constructed.\nThe following functions do not have prototype, and are therefore ineligible as constructors, even if a prototype property is later manually assigned:\njsconst method = { foo() {} }.foo;\nconst arrowFunction = () => {};\nasync function asyncFunction() {}\n\nThe following are valid constructors that have prototype:\njsclass Class {}\nfunction fn() {}\n\nA bound function does not have a prototype property, but may be constructable. When it's constructed, the target function is constructed instead, and if the target function is constructable, it would return a normal instance.\njsconst boundFunction = function () {}.bind(null);\n\nA function's prototype property, by default, is a plain object with one property: constructor, which is a reference to the function itself. The constructor property is writable, non-enumerable, and configurable.\nIf the prototype of a function is reassigned with something other than an Object, when the function is called with new, the returned object's prototype would be Object.prototype instead. (In other words, new ignores the prototype property and constructs a plain object.)\njsfunction Ctor() {}\nCtor.prototype = 3;\nconsole.log(Object.getPrototypeOf(new Ctor()) === Object.prototype); // true\n ",
    "Function: name": "The function's name property can be used to identify the function in debugging tools or error messages. It has no semantic significance to the language itself.\nThe name property is read-only and cannot be changed by the assignment operator:\njsfunction someFunction() {}\n\nsomeFunction.name = \"otherFunction\";\nconsole.log(someFunction.name); // someFunction\n\nTo change it, use Object.defineProperty().\nThe name property is typically inferred from how the function is defined. In the following sections, we will describe the various ways in which it can be inferred. ",
    "Function.prototype.arguments": "The value of arguments is an array-like object corresponding to the arguments passed to a function.\nIn the case of recursion, i.e. if function f appears several times on the call stack, the value of f.arguments represents the arguments corresponding to the most recent invocation of the function.\nThe value of the arguments property is normally null if there is no outstanding invocation of the function in progress (that is, the function has been called but has not yet returned).\nNote that the only behavior specified by the ECMAScript specification is that Function.prototype has an initial arguments accessor that unconditionally throws a TypeError for any get or set request (known as a \"poison pill accessor\"), and that implementations are not allowed to change this semantic for any function except non-strict plain functions. The actual behavior of the arguments property, if it's anything other than throwing an error, is implementation-defined. For example, Chrome defines it as an own data property, while Firefox and Safari extend the initial poison-pill Function.prototype.arguments accessor to specially handle this values that are non-strict functions.\njs(function f() {\n  if (Object.hasOwn(f, \"arguments\")) {\n    console.log(\n      \"arguments is an own property with descriptor\",\n      Object.getOwnPropertyDescriptor(f, \"arguments\"),\n    );\n  } else {\n    console.log(\n      \"f doesn't have an own property named arguments. Trying to get f.[[Prototype]].arguments\",\n    );\n    console.log(\n      Object.getOwnPropertyDescriptor(\n        Object.getPrototypeOf(f),\n        \"arguments\",\n      ).get.call(f),\n    );\n  }\n})();\n\n// In Chrome:\n// arguments is an own property with descriptor {value: Arguments(0), writable: false, enumerable: false, configurable: false}\n\n// In Firefox:\n// f doesn't have an own property named arguments. Trying to get f.[[Prototype]].arguments\n// Arguments { \u00e2\u0080\u00a6 }\n ",
    "Function.prototype.bind()": "The bind() function creates a new bound function. Calling the bound function generally results in the execution of the function it wraps, which is also called the target function. The bound function will store the parameters passed \u00e2\u0080\u0094 which include the value of this and the first few arguments \u00e2\u0080\u0094 as its internal state. These values are stored in advance, instead of being passed at call time. You can generally see const boundFn = fn.bind(thisArg, arg1, arg2) as being equivalent to const boundFn = (...restArgs) => fn.call(thisArg, arg1, arg2, ...restArgs) for the effect when it's called (but not when boundFn is constructed).\nA bound function can be further bound by calling boundFn.bind(thisArg, /* more args */), which creates another bound function boundFn2. The newly bound thisArg value is ignored, because the target function of boundFn2, which is boundFn, already has a bound this. When boundFn2 is called, it would call boundFn, which in turn calls fn. The arguments that fn ultimately receives are, in order: the arguments bound by boundFn, arguments bound by boundFn2, and the arguments received by boundFn2.\njs\"use strict\"; // prevent `this` from being boxed into the wrapper object\n\nfunction log(...args) {\n  console.log(this, ...args);\n}\nconst boundLog = log.bind(\"this value\", 1, 2);\nconst boundLog2 = boundLog.bind(\"new this value\", 3, 4);\nboundLog2(5, 6); // \"this value\", 1, 2, 3, 4, 5, 6\n\nA bound function may also be constructed using the new operator if its target function is constructable. Doing so acts as though the target function had instead been constructed. The prepended arguments are provided to the target function as usual, while the provided this value is ignored (because construction prepares its own this, as seen by the parameters of Reflect.construct). If the bound function is directly constructed, new.target will be the target function instead. (That is, the bound function is transparent to new.target.)\njsclass Base {\n  constructor(...args) {\n    console.log(new.target === Base);\n    console.log(args);\n  }\n}\n\nconst BoundBase = Base.bind(null, 1, 2);\n\nnew BoundBase(3, 4); // true, [1, 2, 3, 4]\n\nHowever, because a bound function does not have the prototype property, it cannot be used as a base class for extends.\njsclass Derived extends class {}.bind(null) {}\n// TypeError: Class extends value does not have valid prototype property undefined\n\nWhen using a bound function as the right-hand side of instanceof, instanceof would reach for the target function (which is stored internally in the bound function) and read its prototype instead.\njsclass Base {}\nconst BoundBase = Base.bind(null, 1, 2);\nconsole.log(new Base() instanceof BoundBase); // true\n\nThe bound function has the following properties:\n\nlength\n\nThe length of the target function minus the number of arguments being bound (not counting the thisArg parameter), with 0 being the minimum value.\n\nname\n\nThe name of the target function plus a \"bound \" prefix.\n\n\nThe bound function also inherits the prototype chain of the target function. However, it doesn't have other own properties of the target function (such as static properties if the target function is a class). ",
    "Function.prototype.toString()": "\n  The Function object overrides the toString() method\n  inherited from Object; it does not inherit\n  Object.prototype.toString. For user-defined Function\n  objects, the toString method returns a string containing the source text\n  segment which was used to define the function.\n\n\n  JavaScript calls the toString method automatically when a\n  Function is to be represented as a text value, e.g. when a function is\n  concatenated with a string.\n\n\n  The toString() method will throw a TypeError exception\n  (\"Function.prototype.toString called on incompatible object\"), if its\n  this value object is not a Function object.\n\njsFunction.prototype.toString.call(\"foo\"); // throws TypeError\n\n\n  If the toString() method is called on built-in function objects, a\n  function created by Function.prototype.bind(), or\n  other non-JavaScript functions, then toString() returns a\n  native function string which looks like\n\nfunction someName() { [native code] }\n\nFor intrinsic object methods and functions, someName is the initial name of the function; otherwise its content may be implementation-defined, but will always be in property name syntax, like [1 + 1], someName, or 1.\n\nNote: This means using eval() on native function strings is a guaranteed syntax error.\n\nIf the toString() method is called on a function created by the Function constructor, toString() returns the source code of a synthesized function declaration named \"anonymous\" using the provided parameters and function body. For example, Function(\"a\", \"b\", \"return a + b\").toString() will return:\nfunction anonymous(a,b\n) {\nreturn a + b\n}\n\nSince ES2018, the spec requires the return value of toString() to be the exact same source code as it was declared, including any whitespace and/or s \u00e2\u0080\u0094 or, if the host doesn't have the source code available for some reason, requires returning a native function string. Support for this revised behavior can be found in the compatibility table. ",
    "Function.prototype.caller": "If the function f was invoked by the top-level code, the value of f.caller is null; otherwise it's the function that called f. If the function that called f is a strict mode function, the value of f.caller is also null.\nNote that the only behavior specified by the ECMAScript specification is that Function.prototype has an initial caller accessor that unconditionally throws a TypeError for any get or set request (known as a \"poison pill accessor\"), and that implementations are not allowed to change this semantic for any function except non-strict plain functions, in which case it must not have the value of a strict mode function. The actual behavior of the caller property, if it's anything other than throwing an error, is implementation-defined. For example, Chrome defines it as an own data property, while Firefox and Safari extend the initial poison-pill Function.prototype.caller accessor to specially handle this values that are non-strict functions.\njs(function f() {\n  if (Object.hasOwn(f, \"caller\")) {\n    console.log(\n      \"caller is an own property with descriptor\",\n      Object.getOwnPropertyDescriptor(f, \"caller\"),\n    );\n  } else {\n    console.log(\n      \"f doesn't have an own property named caller. Trying to get f.[[Prototype]].caller\",\n    );\n    console.log(\n      Object.getOwnPropertyDescriptor(\n        Object.getPrototypeOf(f),\n        \"caller\",\n      ).get.call(f),\n    );\n  }\n})();\n\n// In Chrome:\n// caller is an own property with descriptor {value: null, writable: false, enumerable: false, configurable: false}\n\n// In Firefox:\n// f doesn't have an own property named caller. Trying to get f.[[Prototype]].caller\n// null\n\nThis property replaces the obsolete arguments.caller property of the arguments object.\nThe special property __caller__, which returned the activation object of the caller thus allowing to reconstruct the stack, was removed for security reasons. ",
    "Function: length": "A Function object's length property indicates how many arguments the function expects, i.e. the number of formal parameters. This number excludes the rest parameter and only includes parameters before the first one with a default value. By contrast, arguments.length is local to a function and provides the number of arguments actually passed to the function.\nThe Function constructor is itself a Function object. Its length data property has a value of 1.\nDue to historical reasons, Function.prototype is a callable itself. The length property of Function.prototype has a value of 0. ",
    "Function.prototype.call()": "\nNote: This function is almost identical to apply(), except that the function arguments are passed to call() individually as a list, while for apply() they are combined in one object, typically an array \u00e2\u0080\u0094 for example, func.call(this, \"eat\", \"bananas\") vs. func.apply(this, [\"eat\", \"bananas\"]).\n\nNormally, when calling a function, the value of this inside the function is the object that the function was accessed on. With call(), you can assign an arbitrary value as this when calling an existing function, without first attaching the function to the object as a property. This allows you to use methods of one object as generic utility functions.\n\nWarning: Do not use call() to chain constructors (for example, to implement inheritance). This invokes the constructor function as a plain function, which means new.target is undefined, and classes throw an error because they can't be called without new. Use Reflect.construct() or extends instead.\n ",
    "Function.prototype[@@hasInstance]()": "The instanceof operator calls the [@@hasInstance]() method of the right-hand side whenever such a method exists. Because all functions inherit from Function.prototype by default, they would all have the [@@hasInstance]() method, so most of the time, the Function.prototype[@@hasInstance] method specifies the behavior of instanceof when the right-hand side is a function. This method implements the default behavior of the instanceof operator (the same algorithm when constructor has no @@hasInstance method).\nUnlike most methods, the Function.prototype[@@hasInstance]() property is non-configurable and non-writable. This is a security feature to prevent the underlying target function of a bound function from being obtainable. See this StackOverflow answer for an example. ",
    "Boolean.prototype.valueOf()": "\n  The valueOf() method of Boolean returns the primitive value\n  of a Boolean object or literal Boolean as a Boolean data type.\n\nThis method is usually called internally by JavaScript and not explicitly in code. ",
    "Boolean() constructor": "The value passed as the first parameter is converted to a boolean value. If the value is omitted or is 0, -0, 0n, null, false, NaN, undefined, or the empty string (\"\"), then the object has an initial value of false. All other values, including any object, an empty array ([]), or the string \"false\", create an object with an initial value of true.\n\nNote: When the non-standard property document.all is used as an argument for this constructor, the result is a Boolean object with the value false. This property is legacy and non-standard and should not be used.\n ",
    "Boolean.prototype.toString()": "\n  The Boolean object overrides the toString method of Object; it does not inherit\n  Object.prototype.toString(). For Boolean values, the toString method returns a string representation of the boolean value, which is either \"true\" or \"false\".\n\nThe toString() method requires its this value to be a Boolean primitive or wrapper object. It throws a TypeError for other this values without attempting to coerce them to boolean values.\nBecause Boolean doesn't have a [@@toPrimitive]() method, JavaScript calls the toString() method automatically when a Boolean object is used in a context expecting a string, such as in a template literal. However, boolean primitive values do not consult the toString() method to be coerced to strings \u00e2\u0080\u0094 rather, they are directly converted using the same algorithm as the initial toString() implementation.\njsBoolean.prototype.toString = () => \"Overridden\";\nconsole.log(`${true}`); // \"true\"\nconsole.log(`${new Boolean(true)}`); // \"Overridden\"\n ",
    "Symbol.search": "The Symbol.search static data property represents the well-known symbol @@search. The String.prototype.search() method looks up this symbol on its first argument for the method that returns the index within a string that matches the current object. \n For more information, see RegExp.prototype[@@search]() and String.prototype.search(). ",
    "Symbol() constructor": "The Symbol() function returns primitive values of type Symbol. ",
    "Symbol.prototype[@@toPrimitive]()": "\n  The [@@toPrimitive]() method of Symbol returns the primitive\n  value of a Symbol object as a Symbol data type. The hint\n  argument is not used.\n\n\n  JavaScript calls the [@@toPrimitive]() method to convert an object to a\n  primitive value. You rarely need to invoke the [@@toPrimitive]() method\n  yourself; JavaScript automatically invokes it when encountering an object where a\n  primitive value is expected.\n ",
    "Symbol.iterator": "Whenever an object needs to be iterated (such as at the beginning of a for...of loop), its @@iterator method is called with no arguments, and the returned iterator is used to obtain the values to be iterated.\nSome built-in types have a default iteration behavior, while other types (such as Object) do not. Some built-in types with a @@iterator method are:\n\nArray.prototype[@@iterator]()\nTypedArray.prototype[@@iterator]()\nString.prototype[@@iterator]()\nMap.prototype[@@iterator]()\nSet.prototype[@@iterator]()\n\nSee also Iteration protocols for more information. ",
    "Symbol.split": "The Symbol.split static data property represents the well-known symbol @@split. The String.prototype.split() method looks up this symbol on its first argument for the method that splits a string at the indices that match the current object. \n For more information, seeRegExp.prototype[@@split]() and String.prototype.split(). ",
    "Symbol.prototype.description": "Symbol objects can be created with an optional description which can be used for debugging but not to access the symbol itself. The Symbol.prototype.description property can be used to read that description. It is different to Symbol.prototype.toString() as it does not contain the enclosing \"Symbol()\" string. See the examples. ",
    "Symbol.toStringTag": "The Symbol.toStringTag static data property represents the well-known symbol @@toStringTag. Object.prototype.toString() looks up this symbol on the this value for the property containing a string that represents the type of the object. ",
    "Symbol.for()": "\n  In contrast to Symbol(), the Symbol.for() function creates a\n  symbol available in a global symbol registry list. Symbol.for() does also\n  not necessarily create a new symbol on every call, but checks first if a symbol with the\n  given key is already present in the registry. In that case, that symbol is\n  returned. If no symbol with the given key is found, Symbol.for() will\n  create a new global symbol.\n ",
    "Symbol.replace": "The Symbol.replace static data property represents the well-known symbol @@replace. The String.prototype.replace() and String.prototype.replaceAll() methods look up this symbol on their first argument for the method that replaces substrings matched by the current object. \n For more information, see RegExp.prototype[@@replace](), String.prototype.replace(), and String.prototype.replaceAll(). ",
    "Symbol.prototype.valueOf()": "The valueOf() method of Symbol returns the primitive value of a Symbol object as a Symbol data type.\nJavaScript calls the valueOf() method to convert an object to a primitive value. You rarely need to invoke the valueOf() method yourself; JavaScript automatically invokes it when encountering an object where a primitive value is expected. ",
    "Symbol.hasInstance": "The instanceof operator uses the following algorithm to calculate the return value of object instanceof constructor:\n\nIf constructor has a @@hasInstance method, then call it with object as the first argument and return the result, coerced to a boolean. Throw a TypeError if constructor is not an object, or if constructor[@@hasInstance] is not one of null, undefined, or a function.\nOtherwise, if constructor doesn't have a @@hasInstance method (constructor[@@hasInstance] is null or undefined), then determine the result using the same algorithm as Function.prototype[@@hasInstance]. Throw a TypeError if constructor is not a function.\n\nBecause all functions inherit from Function.prototype by default, most of the time, the Function.prototype[@@hasInstance] method specifies the behavior of instanceof when the right-hand side is a function. ",
    "Symbol.species": "The @@species accessor property allows subclasses to override the default constructor for objects. This specifies a protocol about how instances should be copied. For example, when you use copying methods of arrays, such as map(). the map() method uses instance.constructor[Symbol.species] to get the constructor for constructing the new array. For more information, see subclassing built-ins.\nAll built-in implementations of @@species return the this value, which is the current instance's constructor. This allows copying methods to create instances of derived classes rather than the base class \u00e2\u0080\u0094 for example, map() will return an array of the same type as the original array. ",
    "Symbol.matchAll": "The Symbol.matchAll static data property represents the well-known symbol @@matchAll. The String.prototype.matchAll() method looks up this symbol on its first argument for the method that returns an iterator, that yields matches of the current object against a string. \n For more information, see RegExp.prototype[@@matchAll]() and String.prototype.matchAll(). ",
    "Symbol.prototype.toString()": "\n  The Symbol object overrides the toString method of Object; it does not inherit\n  Object.prototype.toString(). For Symbol values, the toString method returns a descriptive string in the form \"Symbol(description)\", where description is the symbol's description.\n\nThe toString() method requires its this value to be a Symbol primitive or wrapper object. It throws a TypeError for other this values without attempting to coerce them to symbol values.\nBecause Symbol has a [@@toPrimitive]() method, that method always takes priority over toString() when a Symbol object is coerced to a string. However, because Symbol.prototype[@@toPrimitive]() returns a symbol primitive, and symbol primitives throw a TypeError when implicitly converted to a string, the toString() method is never implicitly called by the language. To stringify a symbol, you must explicitly call its toString() method or use the String() function. ",
    "Symbol.unscopables": "The @@unscopables symbol (accessed via Symbol.unscopables) can be defined on any object to exclude property names from being exposed as lexical variables in with environment bindings. Note that when using strict mode, with statements are not available, and this symbol is likely not needed.\nSetting a property of the @@unscopables object to true (or any truthy value) will make the corresponding property of the with scope object unscopable and therefore won't be introduced to the with body scope. Setting a property to false (or any falsy value) will make it scopable and thus appear as lexical scope variables.\nWhen deciding whether x is unscopable, the entire prototype chain of the @@unscopables property is looked up for a property called x. This means if you declared @@unscopables as a plain object, Object.prototype properties like toString would become unscopable as well, which may cause backward incompatibility for legacy code assuming those properties are normally scoped (see an example below). You are advised to make your custom @@unscopables property have null as its prototype, like Array.prototype[@@unscopables] does.\nThis protocol is also utilized by DOM APIs, such as Element.prototype.append(). ",
    "Symbol.toPrimitive": "With the help of the Symbol.toPrimitive property (used as a function value), an object can be converted to a primitive value. The function is called with a string argument hint, which specifies the preferred type of the result primitive value. The hint argument can be one of \"number\", \"string\", and \"default\".\nThe \"number\" hint is used by numeric coercion algorithms. The \"string\" hint is used by the string coercion algorithm. The \"default\" hint is used by the primitive coercion algorithm. The hint only acts as a weak signal of preference, and the implementation is free to ignore it (as Symbol.prototype[@@toPrimitive]() does). The language does not enforce alignment between the hint and the result type, although [@@toPrimitive]() must return a primitive, or a TypeError is thrown.\nObjects without the @@toPrimitive property are converted to primitives by calling the valueOf() and toString() methods in different orders, which is explained in more detail in the type coercion section. @@toPrimitive allows full control over the primitive conversion process. For example, Date.prototype[@@toPrimitive] treats \"default\" as if it's \"string\" and calls toString() instead of valueOf(). Symbol.prototype[@@toPrimitive] ignores the hint and always returns a symbol, which means even in string contexts, Symbol.prototype.toString() won't be called, and Symbol objects must always be explicitly converted to strings through String(). ",
    "Symbol.keyFor()": "\n  The Symbol.keyFor() static method retrieves a shared symbol\n  key from the global symbol registry for the given symbol.\n ",
    "Symbol.match": "This function is also used to identify if objects have the behavior of regular expressions. For example, the methods String.prototype.startsWith(), String.prototype.endsWith() and String.prototype.includes(), check if their first argument is a regular expression and will throw a TypeError if they are. Now, if the match symbol is set to false (or a Falsy value except undefined), it indicates that the object is not intended to be used as a regular expression object. ",
    "Symbol.asyncIterator": "The Symbol.asyncIterator static data property represents the well-known symbol @@asyncIterator. The async iterable protocol looks up this symbol for the method that returns the async iterator for an object. In order for an object to be async iterable, it must have an @@asyncIterator key. ",
    "Symbol.isConcatSpreadable": "The @@isConcatSpreadable symbol (Symbol.isConcatSpreadable) can be defined as an own or inherited property and its value is a boolean. It can control behavior for arrays and array-like objects:\n\nFor array objects, the default behavior is to spread (flatten) elements. Symbol.isConcatSpreadable can avoid flattening in these cases.\nFor array-like objects, the default behavior is no spreading or flattening. Symbol.isConcatSpreadable can force flattening in these cases.\n ",
    "Error: lineNumber": "Non-standard: This feature is non-standard and is not on a standards track. Do not use it on production sites facing the Web: it will not work for every user. There may also be large incompatibilities between implementations and the behavior may change in the future. \n The lineNumber data property of an Error instance contains the line number in the file that raised this error. ",
    "Error.prototype.name": "By default, Error instances are given the name \"Error\". The name property, in addition to the message property, is used by the Error.prototype.toString() method to create a string representation of the error. ",
    "Error: columnNumber": "Non-standard: This feature is non-standard and is not on a standards track. Do not use it on production sites facing the Web: it will not work for every user. There may also be large incompatibilities between implementations and the behavior may change in the future. \n The columnNumber data property of an Error instance contains the column number in the line of the file that raised this error. ",
    "Error: cause": "The value of cause can be of any type. You should not make assumptions that the error you caught has an Error as its cause, in the same way that you cannot be sure the variable bound in the catch statement is an Error either. The \"Providing structured data as the error cause\" example below shows a case where a non-error is deliberately provided as the cause. ",
    "Error() constructor": "The Error() constructor creates Error objects. ",
    "Error: fileName": "This non-standard property contains the path to the file that raised this error. If called from a debugger context, the Firefox Developer Tools for example, \"debugger eval code\" is returned. ",
    "Error.prototype.stack": "Each JavaScript engine uses its own format for stack traces, but they are fairly consistent in their high-level structure. Every implementation uses a separate line in the stack to represent each function call. The call that directly caused the error is placed at the top, and the call that started the whole call chain is placed at the bottom. Below are some examples of stack traces:\njsfunction foo() {\n  bar();\n}\n\nfunction bar() {\n  baz();\n}\n\nfunction baz() {\n  console.log(new Error().stack);\n}\n\nfoo();\n\n#### JavaScriptCore\nbaz@filename.js:10:24\nbar@filename.js:6:6\nfoo@filename.js:2:6\nglobal code@filename.js:13:4\n\n#### SpiderMonkey\nbaz@filename.js:10:15\nbar@filename.js:6:3\nfoo@filename.js:2:3\n@filename.js:13:1\n\n#### V8\nError\n    at baz (filename.js:10:15)\n    at bar (filename.js:6:3)\n    at foo (filename.js:2:3)\n    at filename.js:13:1\n\nDifferent engines set this value at different times. Most modern engines set it when the Error object is created. This means you can get the full call stack information within a function using the following:\njsfunction foo() {\n  console.log(new Error().stack);\n}\n\nWithout having to throw an error and then catch it.\nIn V8, the non-standard Error.captureStackTrace(), Error.stackTraceLimit, and Error.prepareStackTrace() APIs can be used to customize the stack trace. Read the Stack trace API in the V8 docs for more information.\nStack frames can be things other than explicit function calls, too. For example, event listeners, timeout jobs, and promise handlers all begin their own call chain. Source code within eval() and Function constructor calls also appear in the stack:\njsconsole.log(new Function(\"return new Error('Function failed')\")().stack);\nconsole.log(\"====\");\nconsole.log(eval(\"new Error('eval failed')\").stack);\n\n#### JavaScriptCore\nanonymous@\nglobal code@filename.js:1:65\n====\neval code@\neval@[native code]\nglobal code@filename.js:3:17\n\n#### SpiderMonkey\nanonymous@filename.js line 1 > Function:1:8\n@filename.js:1:65\n\n====\n@filename.js line 3 > eval:1:1\n@filename.js:3:13\n\n#### V8\nError: Function failed\n    at eval (eval at <anonymous> (filename.js:1:13), <anonymous>:1:8)\n    at filename.js:1:65\n====\nError: eval failed\n    at eval (eval at <anonymous> (filename.js:3:13), <anonymous>:1:1)\n    at filename.js:3:13\n\nIn Firefox, you can use the //# sourceURL directive to name an eval source. See the Firefox Debug eval sources docs and the Naming eval Scripts with the //# sourceURL Directive blog post for more details. ",
    "Error: message": "This property contains a brief description of the error if one is available or has been set. The message property combined with the name property is used by the Error.prototype.toString() method to create a string representation of the Error.\nBy default, the message property is an empty string, but this behavior can be overridden for an instance by specifying a message as the first argument to the Error constructor. ",
    "Error.prototype.toString()": "\n  The Error object overrides the Object.prototype.toString()\n  method inherited by all objects. Its semantics are as follows:\n\njsError.prototype.toString = function () {\n  if (\n    this === null ||\n    (typeof this !== \"object\" && typeof this !== \"function\")\n  ) {\n    throw new TypeError();\n  }\n  let name = this.name;\n  name = name === undefined ? \"Error\" : `${name}`;\n  let msg = this.message;\n  msg = msg === undefined ? \"\" : `${msg}`;\n  if (name === \"\") {\n    return msg;\n  }\n  if (msg === \"\") {\n    return name;\n  }\n  return `${name}: ${msg}`;\n};\n ",
    "AggregateError() constructor": "The AggregateError() constructor creates AggregateError objects. ",
    "AggregateError: errors": "The errors data property of an AggregateError instance contains an array representing the errors that were aggregated. ",
    "AggregateError": "The AggregateError object represents an error when several errors need to be wrapped in a single error. It is thrown when multiple errors need to be reported by an operation, for example by Promise.any(), when all promises passed to it reject. \n AggregateError is a subclass of Error. ",
    "EvalError": "The EvalError object indicates an error regarding the global eval() function. This exception is not thrown by JavaScript anymore, however the EvalError object remains for compatibility. \n EvalError is a serializable object, so it can be cloned with structuredClone() or copied between Workers using postMessage(). \n EvalError is a subclass of Error. ",
    "RangeError": "A RangeError is thrown when trying to pass a value as an argument to a function that does not allow a range that includes the value.\nThis can be encountered when:\n\npassing a value that is not one of the allowed string values to String.prototype.normalize(), or\nwhen attempting to create an array of an illegal length with the Array constructor, or\nwhen passing bad values to the numeric methods Number.prototype.toExponential(), Number.prototype.toFixed() or Number.prototype.toPrecision().\n\nRangeError is a serializable object, so it can be cloned with structuredClone() or copied between Workers using postMessage().\nRangeError is a subclass of Error. ",
    "ReferenceError": "The ReferenceError object represents an error when a variable that doesn't exist (or hasn't yet been initialized) in the current scope is referenced. \n ReferenceError is a serializable object, so it can be cloned with structuredClone() or copied between Workers using postMessage(). \n ReferenceError is a subclass of Error. ",
    "SyntaxError": "The SyntaxError object represents an error when trying to interpret syntactically invalid code. It is thrown when the JavaScript engine encounters tokens or token order that does not conform to the syntax of the language when parsing code. \n SyntaxError is a serializable object, so it can be cloned with structuredClone() or copied between Workers using postMessage(). \n SyntaxError is a subclass of Error. ",
    "TypeError": "The TypeError object represents an error when an operation could not be performed, typically (but not exclusively) when a value is not of the expected type. \n A TypeError may be thrown when: \n \nan operand or argument passed to a function is incompatible with the type expected by that operator or function; or\nwhen attempting to modify a value that cannot be changed; or\nwhen attempting to use a value in an inappropriate way.\n \n TypeError is a serializable object, so it can be cloned with structuredClone() or copied between Workers using postMessage(). \n TypeError is a subclass of Error. ",
    "URIError": "The URIError object represents an error when a global URI handling function was used in a wrong way. \n URIError is a serializable object, so it can be cloned with structuredClone() or copied between Workers using postMessage(). \n URIError is a subclass of Error. ",
    "InternalError": "Non-standard: This feature is non-standard and is not on a standards track. Do not use it on production sites facing the Web: it will not work for every user. There may also be large incompatibilities between implementations and the behavior may change in the future. \n The InternalError object indicates an error that occurred internally in the JavaScript engine. \n Example cases are mostly when something is too large, e.g.: \n \n\"too many switch cases\",\n\"too many parentheses in regular expression\",\n\"array initializer too large\",\n\"too much recursion\".\n \n InternalError is a subclass of Error. ",
    "Number.POSITIVE_INFINITY": "The Number.POSITIVE_INFINITY value behaves slightly differently than mathematical infinity:\n\nAny positive value, including POSITIVE_INFINITY, multiplied by POSITIVE_INFINITY is POSITIVE_INFINITY.\nAny negative value, including NEGATIVE_INFINITY, multiplied by POSITIVE_INFINITY is NEGATIVE_INFINITY.\nAny positive number divided by POSITIVE_INFINITY is positive zero (as defined in IEEE 754).\nAny negative number divided by POSITIVE_INFINITY is negative zero (as defined in IEEE 754.\nZero multiplied by POSITIVE_INFINITY is NaN.\nNaN multiplied by POSITIVE_INFINITY is NaN.\nPOSITIVE_INFINITY, divided by any negative value except NEGATIVE_INFINITY, is NEGATIVE_INFINITY.\nPOSITIVE_INFINITY, divided by any positive value except POSITIVE_INFINITY, is POSITIVE_INFINITY.\nPOSITIVE_INFINITY, divided by either NEGATIVE_INFINITY or POSITIVE_INFINITY, is NaN.\nNumber.POSITIVE_INFINITY > x is true for any number x that isn't POSITIVE_INFINITY.\n\nYou might use the Number.POSITIVE_INFINITY property to indicate an error condition that returns a finite number in case of success. Note, however, that NaN would be more appropriate in such a case.\nBecause POSITIVE_INFINITY is a static property of Number, you always use it as Number.POSITIVE_INFINITY, rather than as a property of a number value. ",
    "Number.prototype.valueOf()": "This method is usually called internally by JavaScript and not explicitly in web code. ",
    "Number.prototype.toLocaleString()": "The toLocaleString() method of Number values returns a string with a language-sensitive representation of this number. In implementations with Intl.NumberFormat API support, this method simply calls Intl.NumberFormat. \n Every time toLocaleString is called, it has to perform a search in a big database of localization strings, which is potentially inefficient. When the method is called many times with the same arguments, it is better to create a Intl.NumberFormat object and use its format() method, because a NumberFormat object remembers the arguments passed to it and may decide to cache a slice of the database, so future format calls can search for localization strings within a more constrained context. ",
    "Number() constructor": "The Number() constructor creates Number objects. When called as a function, it returns primitive values of type Number. ",
    "Number.isFinite()": "The Number.isFinite() static method determines whether the passed value is a finite number \u00e2\u0080\u0094 that is, it checks that a given value is a number, and the number is neither positive Infinity, negative Infinity, nor NaN. ",
    "Number.MAX_SAFE_INTEGER": "Double precision floating point format only has 52 bits to represent the mantissa, so it can only safely represent integers between -(253 \u00e2\u0080\u0093 1) and 253 \u00e2\u0080\u0093 1. \"Safe\" in this context refers to the ability to represent integers exactly and to compare them correctly. For example, Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2 will evaluate to true, which is mathematically incorrect. See Number.isSafeInteger() for more information.\nBecause MAX_SAFE_INTEGER is a static property of Number, you always use it as Number.MAX_SAFE_INTEGER, rather than as a property of a number value. ",
    "Number.MIN_VALUE": "Number.MIN_VALUE is the smallest positive number (not the most negative number) that can be represented within float precision \u00e2\u0080\u0094 in other words, the number closest to 0. The ECMAScript spec doesn't define a precise value that implementations are required to support \u00e2\u0080\u0094 instead the spec says, \"must be the smallest non-zero positive value that can actually be represented by the implementation\". This is because small IEEE-754 floating point numbers are denormalized, but implementations are not required to support this representation, in which case Number.MIN_VALUE may be larger.\nIn practice, its precise value in mainstream engines like V8 (used by Chrome, Edge, Node.js), SpiderMonkey (used by Firefox), and JavaScriptCore (used by Safari) is 2-1074, or 5E-324.\nBecause MIN_VALUE is a static property of Number, you always use it as Number.MIN_VALUE, rather than as a property of a number value. ",
    "Number.NEGATIVE_INFINITY": "The Number.NEGATIVE_INFINITY value behaves slightly differently than mathematical infinity:\n\nAny positive value, including POSITIVE_INFINITY, multiplied by NEGATIVE_INFINITY is NEGATIVE_INFINITY.\nAny negative value, including NEGATIVE_INFINITY, multiplied by NEGATIVE_INFINITY is POSITIVE_INFINITY.\nAny positive value divided by NEGATIVE_INFINITY is negative zero (as defined in IEEE 754).\nAny negative value divided by NEGATIVE_INFINITY is positive zero (as defined in IEEE 754).\nZero multiplied by NEGATIVE_INFINITY is NaN.\nNaN multiplied by NEGATIVE_INFINITY is NaN.\nNEGATIVE_INFINITY, divided by any negative value except NEGATIVE_INFINITY, is POSITIVE_INFINITY.\nNEGATIVE_INFINITY, divided by any positive value except POSITIVE_INFINITY, is NEGATIVE_INFINITY.\nNEGATIVE_INFINITY, divided by either NEGATIVE_INFINITY or POSITIVE_INFINITY, is NaN.\nx > Number.NEGATIVE_INFINITY is true for any number x that isn't NEGATIVE_INFINITY.\n\nYou might use the Number.NEGATIVE_INFINITY property to indicate an error condition that returns a finite number in case of success. Note, however, that NaN would be more appropriate in such a case.\nBecause NEGATIVE_INFINITY is a static property of Number, you always use it as Number.NEGATIVE_INFINITY, rather than as a property of a number value. ",
    "Number.MAX_VALUE": "Values larger than MAX_VALUE are represented as Infinity and will lose their actual value.\nBecause MAX_VALUE is a static property of Number, you always use it as Number.MAX_VALUE, rather than as a property of a number value. ",
    "Number.isNaN()": "The function Number.isNaN() provides a convenient way to check for equality with NaN. Note that you cannot test for equality with NaN using either the == or === operators, because unlike all other value comparisons in JavaScript, these evaluate to false whenever one operand is NaN, even if the other operand is also NaN.\nSince x !== x is only true for NaN among all possible JavaScript values, Number.isNaN(x) can also be replaced with a test for x !== x, despite the latter being less readable.\nAs opposed to the global isNaN() function, the Number.isNaN() method doesn't force-convert the parameter to a number. This makes it safe to pass values that would normally convert to NaN but aren't actually the same value as NaN. This also means that only values of the Number type that are also NaN return true. ",
    "Number.EPSILON": "Number.EPSILON is the difference between 1 and the next greater number representable in the Number format, because double precision floating point format only has 52 bits to represent the mantissa, and the lowest bit has a significance of 2-52.\nNote that the absolute accuracy of floating numbers decreases as the number gets larger, because the exponent grows while the mantissa's accuracy stays the same. Number.MIN_VALUE is the smallest representable positive number, which is much smaller than Number.EPSILON.\nBecause EPSILON is a static property of Number, you always use it as Number.EPSILON, rather than as a property of a number value. ",
    "Number.MIN_SAFE_INTEGER": "Double precision floating point format only has 52 bits to represent the mantissa, so it can only safely represent integers between -(253 \u00e2\u0080\u0093 1) and 253 \u00e2\u0080\u0093 1. Safe in this context refers to the ability to represent integers exactly and to correctly compare them. For example, Number.MIN_SAFE_INTEGER - 1 === Number.MIN_SAFE_INTEGER - 2 will evaluate to true, which is mathematically incorrect. See Number.isSafeInteger() for more information.\nBecause MIN_SAFE_INTEGER is a static property of Number, you always use it as Number.MIN_SAFE_INTEGER, rather than as a property of a number value. ",
    "Number.prototype.toFixed()": "The toFixed() method returns a string representation of a number without using exponential notation and with exactly digits digits after the decimal point. The number is rounded if necessary, and the fractional part is padded with zeros if necessary so that it has the specified length.\nIf the absolute value of the number is greater or equal to 1021, this method uses the same algorithm as Number.prototype.toString() and returns a string in exponential notation. toFixed() returns \"Infinity\", \"NaN\", or \"-Infinity\" if the value of the number is non-finite.\nThe output of toFixed() may be more precise than toString() for some values, because toString() only prints enough significant digits to distinguish the number from adjacent number values. For example:\njs(1000000000000000128).toString(); // '1000000000000000100'\n(1000000000000000128).toFixed(0); // '1000000000000000128'\n\nHowever, choosing a digits precision that's too high can return unexpected results, because decimal fractional numbers cannot be represented precisely in floating point. For example:\njs(0.3).toFixed(50); // '0.29999999999999998889776975374843459576368331909180'\n ",
    "Number.parseFloat()": "The Number.parseFloat() static method parses an argument and returns a floating point number. If a number cannot be parsed from the argument, it returns NaN. ",
    "Number.prototype.toExponential()": "\n  If the fractionDigits argument is omitted, the number of digits\n  after the decimal point defaults to the number of digits necessary to represent the\n  value uniquely.\n\n\n  If you use the toExponential() method for a numeric literal and the\n  numeric literal has no exponent and no decimal point, leave whitespace(s) before the dot\n  that precedes the method call to prevent the dot from being interpreted as a decimal\n  point.\n\n\n  If a number has more digits than requested by the\n  fractionDigits parameter, the number is rounded to the nearest\n  number represented by fractionDigits digits. See the discussion\n  of rounding in the description of the toFixed() method, which also applies to toExponential().\n ",
    "Number.prototype.toString()": "\n  The Number object overrides the toString method of Object; it does not inherit\n  Object.prototype.toString(). For Number values, the toString method returns a string representation of the value in the specified radix.\n\nFor radixes above 10, the letters of the alphabet indicate digits greater than 9. For example, for hexadecimal numbers (base 16) a through f are used.\nIf the specified number value is negative, the sign is preserved. This is the case even if the radix is 2; the string returned is the positive binary representation of the number value preceded by a - sign, not the two's complement of the number value.\nBoth 0 and -0 have \"0\" as their string representation. Infinity returns \"Infinity\" and NaN returns \"NaN\".\nIf the number is not a whole number, the decimal point . is used to separate the decimal places. Scientific notation is used if the radix is 10 and the number's magnitude (ignoring sign) is greater than or equal to 1021 or less than 10-6. In this case, the returned string always explicitly specifies the sign of the exponent.\njsconsole.log((10 ** 21.5).toString()); // \"3.1622776601683794e+21\"\nconsole.log((10 ** 21.5).toString(8)); // \"526665530627250154000000\"\n\nThe toString() method requires its this value to be a Number primitive or wrapper object. It throws a TypeError for other this values without attempting to coerce them to number values.\nBecause Number doesn't have a [@@toPrimitive]() method, JavaScript calls the toString() method automatically when a Number object is used in a context expecting a string, such as in a template literal. However, Number primitive values do not consult the toString() method to be coerced to strings \u00e2\u0080\u0094 rather, they are directly converted using the same algorithm as the initial toString() implementation.\njsNumber.prototype.toString = () => \"Overridden\";\nconsole.log(`${1}`); // \"1\"\nconsole.log(`${new Number(1)}`); // \"Overridden\"\n ",
    "Number.NaN": "Because NaN is a static property of Number, you always use it as Number.NaN, rather than as a property of a number value. ",
    "Number.isSafeInteger()": "The safe integers consist of all integers from -(253 - 1) to 253 - 1, inclusive (\u00c2\u00b19,007,199,254,740,991). A safe integer is an integer that:\n\ncan be exactly represented as an IEEE-754 double precision number, and\nwhose IEEE-754 representation cannot be the result of rounding any other integer to fit the IEEE-754 representation.\n\nFor example, 253 - 1 is a safe integer: it can be exactly represented, and no other integer rounds to it under any IEEE-754 rounding mode. In contrast, 253 is not a safe integer: it can be exactly represented in IEEE-754, but the integer 253 + 1 can't be directly represented in IEEE-754 but instead rounds to 253 under round-to-nearest and round-to-zero rounding.\nHandling values larger or smaller than ~9 quadrillion with full precision requires using an arbitrary precision arithmetic library. See What Every Programmer Needs to Know about Floating Point Arithmetic for more information on floating point representations of numbers.\nFor larger integers, consider using the BigInt type. ",
    "Number.prototype.toPrecision()": "\n  The toPrecision() method of Number values returns a string representing\n  this number to the specified precision.\n ",
    "Number.parseInt()": "\n  The Number.parseInt() static method parses a string argument and\n  returns an integer of the specified radix or base.\n ",
    "Number.isInteger()": "If the target value is an integer, return true, otherwise return false. If the value is NaN or Infinity, return false. The method will also return true for floating point numbers that can be represented as integer. It will always return false if the value is not a number.\nNote that some number literals, while looking like non-integers, actually represent integers \u00e2\u0080\u0094 due to the precision limit of ECMAScript floating-point number encoding (IEEE-754). For example, 5.0000000000000001 only differs from 5 by 1e-16, which is too small to be represented. (For reference, Number.EPSILON stores the distance between 1 and the next representable floating-point number greater than 1, and that is about 2.22e-16.) Therefore, 5.0000000000000001 will be represented with the same encoding as 5, thus making Number.isInteger(5.0000000000000001) return true.\nIn a similar sense, numbers around the magnitude of Number.MAX_SAFE_INTEGER will suffer from loss of precision and make Number.isInteger return true even when it's not an integer. (The actual threshold varies based on how many bits are needed to represent the decimal \u00e2\u0080\u0094 for example, Number.isInteger(4500000000000000.1) is true, but Number.isInteger(4500000000000000.5) is false.) ",
    "BigInt.prototype.valueOf()": "\n  The valueOf() method of BigInt values returns the wrapped primitive value\n  of a BigInt object.\n ",
    "BigInt64Array": "The BigInt64Array typed array represents an array of 64-bit signed integers in the platform byte order. If control over byte order is needed, use DataView instead. The contents are initialized to 0n. Once established, you can reference elements in the array using the object's methods, or using standard array index syntax (that is, using bracket notation). \n BigInt64Array is a subclass of the hidden TypedArray class. ",
    "BigInt.asUintN()": "The BigInt.asUintN method truncates a BigInt value to the given number of bits, and interprets the result as an unsigned integer. Unsigned integers have no sign bits and are always non-negative. For example, for BigInt.asUintN(4, 25n), the value 25n is truncated to 9n:\n25n = 00011001 (base 2)\n         ^==== Use only the four remaining bits\n===>      1001 (base 2) = 9n\n\n\nNote: BigInt values are always encoded as two's complement in binary.\n\nUnlike similar language APIs such as Number.prototype.toExponential(), asUintN is a static property of BigInt, so you always use it as BigInt.asUintN(), rather than as a method of a BigInt value. Exposing asUintN() as a \"standard library function\" allows interop with asm.js. ",
    "BigInt.prototype.toLocaleString()": "The toLocaleString() method of BigInt values returns a string with a language-sensitive representation of this BigInt. In implementations with Intl.NumberFormat API support, this method simply calls Intl.NumberFormat. \n Every time toLocaleString is called, it has to perform a search in a big database of localization strings, which is potentially inefficient. When the method is called many times with the same arguments, it is better to create a Intl.NumberFormat object and use its format() method, because a NumberFormat object remembers the arguments passed to it and may decide to cache a slice of the database, so future format calls can search for localization strings within a more constrained context. ",
    "BigInt.prototype.toString()": "\n  The BigInt object overrides the toString method of Object; it does not inherit\n  Object.prototype.toString(). For BigInt values, the toString() method returns a string representation of the value in the specified radix.\n\nFor radixes above 10, the letters of the alphabet indicate digits greater than 9. For example, for hexadecimal numbers (base 16) a through f are used.\nIf the specified BigInt value is negative, the sign is preserved. This is the case even if the radix is 2; the string returned is the positive binary representation of the BigInt value preceded by a - sign, not the two's complement of the BigInt value.\nThe toString() method requires its this value to be a BigInt primitive or wrapper object. It throws a TypeError for other this values without attempting to coerce them to BigInt values.\nBecause BigInt doesn't have a [@@toPrimitive]() method, JavaScript calls the toString() method automatically when a BigInt object is used in a context expecting a string, such as in a template literal. However, BigInt primitive values do not consult the toString() method to be coerced to strings \u00e2\u0080\u0094 rather, they are directly converted using the same algorithm as the initial toString() implementation.\njsBigInt.prototype.toString = () => \"Overridden\";\nconsole.log(`${1n}`); // \"1\"\nconsole.log(`${Object(1n)}`); // \"Overridden\"\n ",
    "BigInt() constructor": "The BigInt() function returns primitive values of type BigInt. ",
    "BigInt.asIntN()": "The BigInt.asIntN method truncates a BigInt value to the given number of bits, and interprets the result as a signed integer. For example, for BigInt.asIntN(3, 25n), the value 25n is truncated to 1n:\n25n = 00011001 (base 2)\n          ^=== Use only the three remaining bits\n===>       001 (base 2) = 1n\n\nIf the leading bit of the remaining number is 1, the result is negative. For example, BigInt.asIntN(4, 25n) yields -7n, because 1001 is the encoding of -7 under two's complement:\n25n = 00011001 (base 2)\n         ^==== Use only the four remaining bits\n===>      1001 (base 2) = -7n\n\n\nNote: BigInt values are always encoded as two's complement in binary.\n\nUnlike similar language APIs such as Number.prototype.toExponential(), asIntN is a static property of BigInt, so you always use it as BigInt.asIntN(), rather than as a method of a BigInt value. Exposing asIntN() as a \"standard library function\" allows interop with asm.js. ",
    "Math.log2()": "Because log2() is a static method of Math, you always use it as Math.log2(), rather than as a method of a Math object you created (Math is not a constructor).\nThis function is the equivalent of Math.log(x) / Math.log(2). For log2(e), use the constant Math.LOG2E, which is 1 / Math.LN2. ",
    "Math.log1p()": "For very small values of x, adding 1 can reduce or eliminate precision. The double floats used in JS give you about 15 digits of precision. 1 + 1e-15 = 1.000000000000001, but 1 + 1e-16 = 1.000000000000000 and therefore exactly 1.0 in that arithmetic, because digits past 15 are rounded off.\nWhen you calculate log(1 + x) where x is a small positive number, you should get an answer very close to x, because \n  \n\n\n\nlim\n\nx\n\u00e2\u0086\u0092\n0\n\n\n\n\nlog\n\u00e2\u0081\u00a1\n(\n1\n+\nx\n)\n\nx\n\n=\n1\n\n\\lim_{x \\to 0} \\frac{\\log(1+x)}{x} = 1\n\n. If you calculate Math.log(1 + 1.1111111111e-15), you should get an answer close to 1.1111111111e-15. Instead, you will end up taking the logarithm of 1.00000000000000111022 (the roundoff is in binary, so sometimes it gets ugly), and get the answer 1.11022\u00e2\u0080\u00a6e-15, with only 3 correct digits. If, instead, you calculate Math.log1p(1.1111111111e-15), you will get a much more accurate answer 1.1111111110999995e-15, with 15 correct digits of precision (actually 16 in this case).\n\nIf the value of x is less than -1, the return value is always NaN.\nBecause log1p() is a static method of Math, you always use it as Math.log1p(), rather than as a method of a Math object you created (Math is not a constructor). ",
    "Math.tanh()": "Because tanh() is a static method of Math, you always use it as Math.tanh(), rather than as a method of a Math object you created (Math is not a constructor). ",
    "Math.SQRT1_2": "Math.SQRT1_2 is a constant and a more performant equivalent to Math.sqrt(0.5).\nBecause SQRT1_2 is a static property of Math, you always use it as Math.SQRT1_2, rather than as a property of a Math object you created (Math is not a constructor). ",
    "Math.atan()": "Because atan() is a static method of Math, you always use it as Math.atan(), rather than as a method of a Math object you created (Math is not a constructor). ",
    "Math.log10()": "Because log10() is a static method of Math, you always use it as Math.log10(), rather than as a method of a Math object you created (Math is not a constructor).\nThis function is the equivalent of Math.log(x) / Math.log(10). For log10(e), use the constant Math.LOG10E, which is 1 / Math.LN10. ",
    "Math.random()": "The Math.random() static method returns a floating-point, pseudo-random number that's greater than or equal to 0 and less than 1, with approximately uniform distribution over that range \u00e2\u0080\u0094 which you can then scale to your desired range. The implementation selects the initial seed to the random number generation algorithm; it cannot be chosen or reset by the user. \n \nNote: Math.random() does not provide cryptographically secure random numbers. Do not use them for anything related to security. Use the Web Crypto API instead, and more precisely the window.crypto.getRandomValues() method.\n ",
    "Math.round()": "If the fractional portion of the argument is greater than 0.5, the argument is rounded to the integer with the next higher absolute value. If it is less than 0.5, the argument is rounded to the integer with the lower absolute value. If the fractional portion is exactly 0.5, the argument is rounded to the next integer in the direction of +\u00e2\u0088\u009e.\n\nNote: This differs from many languages' round() functions, which often round half-increments away from zero, giving a different result in the case of negative numbers with a fractional part of exactly 0.5.\n\nMath.round(x) is not exactly the same as Math.floor(x + 0.5). When x is -0, or -0.5 \u00e2\u0089\u00a4 x < 0, Math.round(x) returns -0, while Math.floor(x + 0.5) returns 0. However, neglecting that difference and potential precision errors, Math.round(x) and Math.floor(x + 0.5) are generally equivalent.\nBecause round() is a static method of Math, you always use it as Math.round(), rather than as a method of a Math object you created (Math has no constructor). ",
    "Math.PI": "Because PI is a static property of Math, you always use it as Math.PI, rather than as a property of a Math object you created (Math is not a constructor). ",
    "Math.ceil()": "Because ceil() is a static method of Math, you always use it as Math.ceil(), rather than as a method of a Math object you created (Math is not a constructor). ",
    "Math.cbrt()": "Because cbrt() is a static method of Math, you always use it as Math.cbrt(), rather than as a method of a Math object you created (Math is not a constructor). ",
    "Math.min()": "Because min() is a static method of Math, you always use it as Math.min(), rather than as a method of a Math object you created (Math is not a constructor).\nMath.min.length is 2, which weakly signals that it's designed to handle at least two parameters. ",
    "Math.E": "Because E is a static property of Math, you always use it as Math.E, rather than as a property of a Math object you created (Math is not a constructor). ",
    "Math.sqrt()": "Because sqrt() is a static method of Math, you always use it as Math.sqrt(), rather than as a method of a Math object you created (Math is not a constructor). ",
    "Math.LOG2E": "Because LOG2E is a static property of Math, you always use it as Math.LOG2E, rather than as a property of a Math object you created (Math is not a constructor). ",
    "Math.fround()": "JavaScript uses 64-bit double floating-point numbers internally, which offer a very high precision. However, sometimes you may be working with 32-bit floating-point numbers, for example if you are reading values from a Float32Array. This can create confusion: checking a 64-bit float and a 32-bit float for equality may fail even though the numbers are seemingly identical.\nTo solve this, Math.fround() can be used to cast the 64-bit float to a 32-bit float. Internally, JavaScript continues to treat the number as a 64-bit float, it just performs a \"round to even\" on the 23rd bit of the mantissa, and sets all following mantissa bits to 0. If the number is outside the range of a 32-bit float, Infinity or -Infinity is returned.\nBecause fround() is a static method of Math, you always use it as Math.fround(), rather than as a method of a Math object you created (Math is not a constructor). ",
    "Math.sin()": "Because sin() is a static method of Math, you always use it as Math.sin(), rather than as a method of a Math object you created (Math is not a constructor). ",
    "Math.trunc()": "Unlike the other three Math methods: Math.floor(), Math.ceil() and Math.round(), the way Math.trunc() works is very simple. It truncates (cuts off) the dot and the digits to the right of it, no matter whether the argument is a positive or negative number.\nBecause trunc() is a static method of Math, you always use it as Math.trunc(), rather than as a method of a Math object you created (Math is not a constructor). ",
    "Math.tan()": "Because tan() is a static method of Math, you always use it as Math.tan(), rather than as a method of a Math object you created (Math is not a constructor). ",
    "Math.LOG10E": "Because LOG10E is a static property of Math, you always use it as Math.LOG10E, rather than as a property of a Math object you created (Math is not a constructor). ",
    "Math.asin()": "Because asin() is a static method of Math, you always use it as Math.asin(), rather than as a method of a Math object you created (Math is not a constructor). ",
    "Math.sinh()": "Because sinh() is a static method of Math, you always use it as Math.sinh(), rather than as a method of a Math object you created (Math is not a constructor). ",
    "Math.acosh()": "Because acosh() is a static method of Math, you always use it as Math.acosh(), rather than as a method of a Math object you created (Math is no constructor). ",
    "Math.SQRT2": "Math.SQRT2 is a constant and a more performant equivalent to Math.sqrt(2).\nBecause SQRT2 is a static property of Math, you always use it as Math.SQRT2, rather than as a property of a Math object you created (Math is not a constructor). ",
    "Math.atanh()": "Because atanh() is a static method of Math, you always use it as Math.atanh(), rather than as a method of a Math object you created (Math is not a constructor). ",
    "Math.atan2()": "The Math.atan2() method measures the counterclockwise angle \u00ce\u00b8, in radians, between the positive x-axis and the point (x, y). Note that the arguments to this function pass the y-coordinate first and the x-coordinate second.\n\n\n\nMath.atan2() is passed separate x and y arguments, while Math.atan() is passed the ratio of those two arguments. Math.atan2(y, x) differs from Math.atan(y / x) in the following cases:\n\n\n\nx\ny\nMath.atan2(y, x)\nMath.atan(y / x)\n\n\n\n\nInfinity\nInfinity\n\u00cf\u0080 / 4\nNaN\n\n\nInfinity\n-Infinity\n-\u00cf\u0080 / 4\nNaN\n\n\n-Infinity\nInfinity\n3\u00cf\u0080 / 4\nNaN\n\n\n-Infinity\n-Infinity\n-3\u00cf\u0080 / 4\nNaN\n\n\n0\n0\n0\nNaN\n\n\n0\n-0\n-0\nNaN\n\n\n< 0 (including -0)\n0\n\u00cf\u0080\n0\n\n\n< 0 (including -0)\n-0\n-\u00cf\u0080\n0\n\n\n-Infinity\n> 0\n\u00cf\u0080\n-0\n\n\n-0\n> 0\n\u00cf\u0080 / 2\n-\u00cf\u0080 / 2\n\n\n-Infinity\n< 0\n-\u00cf\u0080\n0\n\n\n-0\n< 0\n-\u00cf\u0080 / 2\n\u00cf\u0080 / 2\n\n\n\nIn addition, for points in the second and third quadrants (x < 0), Math.atan2() would output an angle less than \n  \n\n\n-\n\n\u00cf\u0080\n2\n\n\n-\\frac{\\pi}{2}\n\n or greater than \n  \n\n\n\u00cf\u0080\n2\n\n\\frac{\\pi}{2}\n\n.\n\nBecause atan2() is a static method of Math, you always use it as Math.atan2(), rather than as a method of a Math object you created (Math is not a constructor). ",
    "Math.pow()": "Math.pow() is equivalent to the ** operator, except Math.pow() only accepts numbers.\nMath.pow(NaN, 0) (and the equivalent NaN ** 0) is the only case where NaN doesn't propagate through mathematical operations \u00e2\u0080\u0094 it returns 1 despite the operand being NaN. In addition, the behavior where base is 1 and exponent is non-finite (\u00c2\u00b1Infinity or NaN) is different from IEEE 754, which specifies that the result should be 1, whereas JavaScript returns NaN to preserve backward compatibility with its original behavior.\nBecause pow() is a static method of Math, use it as Math.pow(), rather than as a method of a Math object you created (Math is not a constructor). ",
    "Math.asinh()": "Because asinh() is a static method of Math, you always use it as Math.asinh(), rather than as a method of a Math object you created (Math is not a constructor). ",
    "Math.exp()": "Because exp() is a static method of Math, you always use it as Math.exp(), rather than as a method of a Math object you created (Math is not a constructor).\nBeware that e to the power of a number very close to 0 will be very close to 1 and suffer from loss of precision. In this case, you may want to use Math.expm1 instead, and obtain a much higher-precision fractional part of the answer. ",
    "Math.log()": "Because log() is a static method of Math, you always use it as Math.log(), rather than as a method of a Math object you created (Math is not a constructor).\nIf you need the natural log of 2 or 10, use the constants Math.LN2 or Math.LN10. If you need a logarithm to base 2 or 10, use Math.log2() or Math.log10(). If you need a logarithm to other bases, use Math.log(x) / Math.log(otherBase) as in the example below; you might want to precalculate 1 / Math.log(otherBase) since multiplication in Math.log(x) * constant is much faster.\nBeware that positive numbers very close to 1 can suffer from loss of precision and make its natural logarithm less accurate. In this case, you may want to use Math.log1p instead. ",
    "Math.cosh()": "Because cosh() is a static method of Math, you always use it as Math.cosh(), rather than as a method of a Math object you created (Math is not a constructor). ",
    "Math.sign()": "Because sign() is a static method of Math, you always use it as Math.sign(), rather than as a method of a Math object you created (Math is not a constructor). ",
    "Math.clz32()": "clz32 is short for CountLeadingZeros32.\nIf x is not a number, it will be converted to a number first, then converted to a 32-bit unsigned integer.\nIf the converted 32-bit unsigned integer is 0, 32 is returned, because all bits are 0. If the most significant bit is 1 (i.e. the number is greater than or equal to 231), 0 is returned.\nThis function is particularly useful for systems that compile to JS, like Emscripten. ",
    "Math.expm1()": "For very small values of x, adding 1 can reduce or eliminate precision. The double floats used in JS give you about 15 digits of precision. 1 + 1e-15 = 1.000000000000001, but 1 + 1e-16 = 1.000000000000000 and therefore exactly 1.0 in that arithmetic, because digits past 15 are rounded off.\nWhen you calculate \n  \n\n\ne\nx\n\n\\mathrm{e}^x\n\n where x is a number very close to 0, you should get an answer very close to 1 + x, because \n  \n\n\n\nlim\n\nx\n\u00e2\u0086\u0092\n0\n\n\n\n\n\ne\nx\n\n\u00e2\u0088\u0092\n1\n\nx\n\n=\n1\n\n\\lim_{x \\to 0} \\frac{\\mathrm{e}^x - 1}{x} = 1\n\n. If you calculate Math.exp(1.1111111111e-15) - 1, you should get an answer close to 1.1111111111e-15. Instead, due to the highest significant figure in the result of Math.exp being the units digit 1, the final value ends up being 1.1102230246251565e-15, with only 3 correct digits. If, instead, you calculate Math.exp1m(1.1111111111e-15), you will get a much more accurate answer 1.1111111111000007e-15, with 11 correct digits of precision.\n\nBecause expm1() is a static method of Math, you always use it as Math.expm1(), rather than as a method of a Math object you created (Math is not a constructor). ",
    "Math.hypot()": "Calculating the hypotenuse of a right triangle, or the magnitude of a complex number, uses the formula Math.sqrt(v1*v1 + v2*v2), where v1 and v2 are the lengths of the triangle's legs, or the complex number's real and complex components. The corresponding distance in 2 or more dimensions can be calculated by adding more squares under the square root: Math.sqrt(v1*v1 + v2*v2 + v3*v3 + v4*v4).\nThis function makes this calculation easier and faster; you call Math.hypot(v1, v2), or Math.hypot(v1, /* \u00e2\u0080\u00a6, */, vN).\nMath.hypot also avoids overflow/underflow problems if the magnitude of your numbers is very large. The largest number you can represent in JS is Number.MAX_VALUE, which is around 10308. If your numbers are larger than about 10154, taking the square of them will result in Infinity. For example, Math.sqrt(1e200*1e200 + 1e200*1e200) = Infinity. If you use hypot() instead, you get a better answer: Math.hypot(1e200, 1e200) = 1.4142...e+200 . This is also true with very small numbers. Math.sqrt(1e-200*1e-200 + 1e-200*1e-200) = 0, but Math.hypot(1e-200, 1e-200) = 1.4142...e-200.\nWith one argument, Math.hypot() is equivalent to Math.abs(). Math.hypot.length is 2, which weakly signals that it's designed to handle at least two parameters.\nBecause hypot() is a static method of Math, you always use it as Math.hypot(), rather than as a method of a Math object you created (Math is not a constructor). ",
    "Math.acos()": "Because acos() is a static method of Math, you always use it as Math.acos(), rather than as a method of a Math object you created (Math is not a constructor). ",
    "Math.floor()": "Because floor() is a static method of Math, you always use it as Math.floor(), rather than as a method of a Math object you created (Math is not a constructor). ",
    "Math.LN2": "Because LN2 is a static property of Math, you always use it as Math.LN2, rather than as a property of a Math object you created (Math is not a constructor). ",
    "Math.cos()": "Because cos() is a static method of Math, you always use it as Math.cos(), rather than as a method of a Math object you created (Math is not a constructor). ",
    "Math.abs()": "Because abs() is a static method of Math, you always use it as Math.abs(), rather than as a method of a Math object you created (Math is not a constructor). ",
    "Math.imul()": "Math.imul() allows for 32-bit integer multiplication with C-like semantics. This feature is useful for projects like Emscripten.\nBecause imul() is a static method of Math, you always use it as Math.imul(), rather than as a method of a Math object you created (Math is not a constructor).\nIf you use normal JavaScript floating point numbers in imul(), you will experience a degrade in performance. This is because of the costly conversion from a floating point to an integer for multiplication, and then converting the multiplied integer back into a floating point. However, with asm.js, which allows JIT-optimizers to more confidently use integers in JavaScript, multiplying two numbers stored internally as integers (which is only possible with asm.js) with imul() could be potentially more performant. ",
    "Math.LN10": "Because LN10 is a static property of Math, you always use it as Math.LN10, rather than as a property of a Math object you created (Math is not a constructor). ",
    "Math.max()": "Because max() is a static method of Math, you always use it as Math.max(), rather than as a method of a Math object you created (Math is not a constructor).\nMath.max.length is 2, which weakly signals that it's designed to handle at least two parameters. ",
    "Date.prototype.getUTCDay()": "The getUTCDay() method of Date instances returns the day of the week for this date according to universal time, where 0 represents Sunday. ",
    "Date.parse()": "This function is useful for setting date values based on string values, for example in conjunction with the setTime() method.\nBecause parse() is a static method of Date, you always use it as Date.parse(), rather than as a method of a Date object you created. ",
    "Date.prototype.toLocaleString()": "The toLocaleString() method of Date instances returns a string with a language-sensitive representation of this date in the local timezone. In implementations with Intl.DateTimeFormat API support, this method simply calls Intl.DateTimeFormat. \n Every time toLocaleString is called, it has to perform a search in a big database of localization strings, which is potentially inefficient. When the method is called many times with the same arguments, it is better to create a Intl.DateTimeFormat object and use its format() method, because a DateTimeFormat object remembers the arguments passed to it and may decide to cache a slice of the database, so future format calls can search for localization strings within a more constrained context. ",
    "Date.prototype.getUTCFullYear()": "Unlike getYear(), the value returned by getUTCFullYear() is an absolute number. For dates between the years 1000 and 9999, getFullYear() returns a four-digit number, for example, 1995. Use this function to make sure a year is compliant with years after 2000. ",
    "Date.prototype.getYear()": "Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time. \n The getYear() method of Date instances returns the year for this date according to local time. Because getYear() does not return full years (\"year 2000 problem\"), it is deprecated and has been replaced by the getFullYear() method. ",
    "Date.prototype.toString()": "The toString() method is part of the type coercion protocol. Because Date has a [@@toPrimitive]() method, that method always takes priority over toString() when a Date object is implicitly coerced to a string. However, Date.prototype[@@toPrimitive]() still calls this.toString() internally.\nThe Date object overrides the toString() method of Object. Date.prototype.toString() returns a string representation of the Date as interpreted in the local timezone, containing both the date and the time \u00e2\u0080\u0094 it joins the string representation specified in toDateString() and toTimeString() together, adding a space in between. For example: \"Thu Jan 01 1970 00:00:00 GMT+0000 (Coordinated Universal Time)\".\nDate.prototype.toString() must be called on Date instances. If the this value does not inherit from Date.prototype, a TypeError is thrown.\n\nIf you only want to get the date part, use toDateString().\nIf you only want to get the time part, use toTimeString().\nIf you want to make the date interpreted as UTC instead of local timezone, use toUTCString().\nIf you want to format the date in a more user-friendly format (e.g. localization), use toLocaleString().\n ",
    "Date.prototype.toUTCString()": "The value returned by toUTCString() is a string in the form Www, dd Mmm yyyy hh:mm:ss GMT, where:\n\n\n\nFormat String\nDescription\n\n\n\n\nWww\nDay of week, as three letters (e.g. Sun, Mon)\n\n\ndd\nDay of month, as two digits with leading zero if required\n\n\nMmm\nMonth, as three letters (e.g. Jan, Feb)\n\n\nyyyy\nYear, as four or more digits with leading zeroes if required\n\n\nhh\nHour, as two digits with leading zero if required\n\n\nmm\nMinute, as two digits with leading zero if required\n\n\nss\nSeconds, as two digits with leading zero if required\n\n\n ",
    "Date.prototype.setUTCFullYear()": "\n  If you do not specify the monthValue and\n  dateValue parameters, the values returned from the\n  getUTCMonth() and\n  getUTCDate() methods are used.\n\n\n  If a parameter you specify is outside of the expected range,\n  setUTCFullYear() attempts to update the other parameters and the date\n  information in the Date object accordingly. For example, if you specify 15\n  for monthValue, the year is incremented by 1\n  (yearValue + 1), and 3 is used for the month.\n ",
    "Date.prototype.setFullYear()": "If you do not specify the monthValue and dateValue parameters, the same values as what are returned by getMonth() and getDate() are used.\nIf a parameter you specify is outside of the expected range, other parameters and the date information in the Date object are updated accordingly. For example, if you specify 15 for monthValue, the year is incremented by 1 (yearValue + 1), and 3 is used for the month. ",
    "Date.prototype.setUTCDate()": "If the dateValue is outside of the range of date values for the month, setDate() will update the Date object accordingly.\nFor example, if 0 is provided for dateValue, the date will be set to the last day of the previous month. If you use 40 for dateValue, and the month stored in the Date object is June, the day will be changed to 10 and the month will be incremented to July.\nIf a negative number is provided for dateValue, the date will be set counting backwards from the last day of the previous month. -1 would result in the date being set to 1 day before the last day of the previous month. ",
    "Date.prototype.toLocaleDateString()": "The toLocaleDateString() method of Date instances returns a string with a language-sensitive representation of the date portion of this date in the local timezone. In implementations with Intl.DateTimeFormat API support, this method simply calls Intl.DateTimeFormat. \n Every time toLocaleString is called, it has to perform a search in a big database of localization strings, which is potentially inefficient. When the method is called many times with the same arguments, it is better to create a Intl.DateTimeFormat object and use its format() method, because a DateTimeFormat object remembers the arguments passed to it and may decide to cache a slice of the database, so future format calls can search for localization strings within a more constrained context. ",
    "Date.prototype.toDateString()": "Date instances refer to a specific point in time. toDateString() interprets the date in the local timezone and formats the date part in English. It always uses the following format, separated by spaces:\n\nFirst three letters of the week day name\nFirst three letters of the month name\nTwo-digit day of the month, padded on the left a zero if necessary\nFour-digit year (at least), padded on the left with zeros if necessary. May have a negative sign\n\nFor example: \"Thu Jan 01 1970\".\n\nIf you only want to get the time part, use toTimeString().\nIf you want to get both the date and time, use toString().\nIf you want to make the date interpreted as UTC instead of local timezone, use toUTCString().\nIf you want to format the date in a more user-friendly format (e.g. localization), use toLocaleDateString().\n ",
    "Date.prototype.setUTCMonth()": "\n  If you do not specify the dateValue parameter, the value returned from the\n  getUTCDate() method is used.\n\n\n  If a parameter you specify is outside of the expected range, setUTCMonth()\n  attempts to update the date information in the Date object accordingly.\n  For example, if you use 15 for monthValue, the year will be incremented by\n  1, and 3 will be used for month.\n ",
    "Date.prototype.getFullYear()": "Unlike getYear(), the value returned by getFullYear() is an absolute number. For dates between the years 1000 and 9999, getFullYear() returns a four-digit number, for example, 1995. Use this function to make sure a year is compliant with years after 2000. ",
    "Date.prototype.setUTCSeconds()": "\n  If you do not specify the msValue parameter, the value returned from the\n  getUTCMilliseconds() method is\n  used.\n\n\n  If a parameter you specify is outside of the expected range,\n  setUTCSeconds() attempts to update the date information in the\n  Date object accordingly. For example, if you use 100 for\n  secondsValue, the minutes stored in the Date object will be\n  incremented by 1, and 40 will be used for seconds.\n ",
    "Date.prototype.getSeconds()": "The getSeconds() method of Date instances returns the seconds for this date according to local time. ",
    "Date.prototype.toJSON()": "The toJSON() method is automatically called by JSON.stringify() when a Date object is stringified. This method is generally intended to, by default, usefully serialize Date objects during JSON serialization, which can then be deserialized using the Date() constructor as the reviver of JSON.parse().\nThe method first attempts to convert its this value to a primitive by calling its [@@toPrimitive]() (with \"number\" as hint), valueOf(), and toString() methods, in that order. If the result is a non-finite number, null is returned. (This generally corresponds to an invalid date, whose valueOf() returns NaN.) Otherwise, if the converted primitive is not a number or is a finite number, the return value of this.toISOString() is returned.\nNote that the method does not check whether the this value is a valid Date object. However, calling Date.prototype.toJSON() on non-Date objects fails unless the object's number primitive representation is NaN, or the object also has a toISOString() method. ",
    "Date.prototype.toLocaleTimeString()": "The toLocaleTimeString() method of Date instances returns a string with a language-sensitive representation of the time portion of this date in the local timezone. In implementations with Intl.DateTimeFormat API support, this method simply calls Intl.DateTimeFormat. \n Every time toLocaleTimeString is called, it has to perform a search in a big database of localization strings, which is potentially inefficient. When the method is called many times with the same arguments, it is better to create a Intl.DateTimeFormat object and use its format() method, because a DateTimeFormat object remembers the arguments passed to it and may decide to cache a slice of the database, so future format calls can search for localization strings within a more constrained context. ",
    "Date.prototype.getUTCMilliseconds()": "The getUTCMilliseconds() method of Date instances returns the milliseconds for this date according to universal time. ",
    "Date.prototype.setSeconds()": "\n  If you do not specify the msValue parameter, the value returned\n  from the getMilliseconds() method is\n  used.\n\n\n  If a parameter you specify is outside of the expected range, setSeconds()\n  attempts to update the date information in the Date object accordingly.\n  For example, if you use 100 for secondsValue, the minutes stored\n  in the Date object will be incremented by 1, and 40 will be used for\n  seconds.\n ",
    "Date.prototype.getDate()": "The getDate() method of Date instances returns the day of the month for this date according to local time. ",
    "Date.prototype.setDate()": "If you specify a number outside the expected range, the date information in the Date object is updated accordingly. For example, if the Date object holds June 1st, a dateValue of 40 changes the date to July 10th, while a dateValue of 0 changes the date to the last day of the previous month, May 31st. ",
    "Date.prototype.toTimeString()": "Date instances refer to a specific point in time. toTimeString() interprets the date in the local timezone and formats the time part in English. It always uses the format of hh:mm:ss GMT\u00c2\u00b1xxxx (TZ), where:\n\n\n\nFormat String\nDescription\n\n\n\n\nhh\nHour, as two digits with leading zero if required\n\n\nmm\nMinute, as two digits with leading zero if required\n\n\nss\nSeconds, as two digits with leading zero if required\n\n\n\u00c2\u00b1xxxx\nThe local timezone's offset \u00e2\u0080\u0094 two digits for hours and two digits for minutes (e.g. -0500, +0800)\n\n\nTZ\nThe timezone's name (e.g. PDT, PST)\n\n\n\nFor example: \"04:42:04 GMT+0000 (Coordinated Universal Time)\".\n\nIf you only want to get the date part, use toDateString().\nIf you want to get both the date and time, use toString().\nIf you want to make the date interpreted as UTC instead of local timezone, use toUTCString().\nIf you want to format the date in a more user-friendly format (e.g. localization), use toLocaleTimeString().\n ",
    "Date.prototype.setTime()": "The setTime() method of Date instances changes the timestamp for this date, which is the number of milliseconds since the epoch, defined as the midnight at the beginning of January 1, 1970, UTC. ",
    "Date.prototype[@@toPrimitive]()": "The [@@toPrimitive]() method is part of the type coercion protocol. JavaScript always calls the [@@toPrimitive]() method in priority to convert an object to a primitive value. You rarely need to invoke the [@@toPrimitive]() method yourself; JavaScript automatically invokes it when encountering an object where a primitive value is expected.\nThe [@@toPrimitive]() method of the Date object returns a primitive value by either invoking this.valueOf() and returning a number, or invoking this.toString() and returning a string. It exists to override the default primitive coercion process to return a string instead of a number, because primitive coercion, by default, calls valueOf() before toString(). With the custom [@@toPrimitive](), new Date(0) + 1 returns \"Thu Jan 01 1970 00:00:00 GMT+0000 (Coordinated Universal Time)1\" (a string) instead of 1 (a number). ",
    "Date.prototype.getHours()": "The getHours() method of Date instances returns the hours for this date according to local time. ",
    "Date.now()": "To offer protection against timing attacks and fingerprinting, the precision of Date.now() might get rounded depending on browser settings. In Firefox, the privacy.reduceTimerPrecision preference is enabled by default and defaults to 2ms. You can also enable privacy.resistFingerprinting, in which case the precision will be 100ms or the value of privacy.resistFingerprinting.reduceTimerPrecision.microseconds, whichever is larger.",
    "Date.prototype.setMilliseconds()": "If you specify a number outside the expected range, the date information in the Date object is updated accordingly. For example, if you specify 1005, the number of seconds is incremented by 1, and 5 is used for the milliseconds. ",
    "Date.prototype.setUTCMilliseconds()": "\n  If a parameter you specify is outside of the expected range,\n  setUTCMilliseconds() attempts to update the date information in the\n  Date object accordingly. For example, if you use 1100 for\n  millisecondsValue, the seconds stored in the Date\n  object will be incremented by 1, and 100 will be used for milliseconds.\n ",
    "Date.UTC()": "Years between 0 and 99 are converted to a year in the 20th century (1900 + year). For example, 95 is converted to the year 1995.\nThe UTC() method differs from the Date() constructor in three ways:\n\nDate.UTC() uses universal time instead of the local time.\nDate.UTC() returns a time value as a number instead of creating a Date object.\nWhen passed a single number, Date.UTC() interprets it as a year instead of a timestamp.\n\nIf a parameter is outside of the expected range, the UTC() method updates the other parameters to accommodate the value. For example, if 15 is used for monthIndex, the year will be incremented by 1 (year + 1) and 3 will be used for the month.\nBecause UTC() is a static method of Date, you always use it as Date.UTC(), rather than as a method of a Date object you created. ",
    "Date.prototype.getTimezoneOffset()": "date.getTimezoneOffset() returns the difference, in minutes, between date as evaluated in the UTC time zone and as evaluated in the local time zone \u00e2\u0080\u0094 that is, the time zone of the host system in which the browser is being used (if the code is run from the Web in a browser), or otherwise the host system of whatever JavaScript runtime (for example, a Node.js environment) the code is executed in. ",
    "Date.prototype.getUTCMinutes()": "The getUTCMinutes() method of Date instances returns the minutes for this date according to universal time. ",
    "Date.prototype.valueOf()": "The valueOf() method is part of the type coercion protocol. Because Date has a [@@toPrimitive]() method, that method always takes priority over valueOf() when a Date object is implicitly coerced to a number. However, Date.prototype[@@toPrimitive]() still calls this.valueOf() internally.\nThe Date object overrides the valueOf() method of Object. Date.prototype.valueOf() returns the timestamp of the date, which is functionally equivalent to the Date.prototype.getTime() method. ",
    "Date.prototype.getUTCSeconds()": "The getUTCSeconds() method of Date instances returns the seconds in the specified date according to universal time. ",
    "Date.prototype.setYear()": "\n  If yearValue is a number between 0 and 99 (inclusive), then the year for\n  dateObj is set to 1900 + yearValue. Otherwise, the year for\n  dateObj is set to yearValue.\n ",
    "Date.prototype.setMinutes()": "If you do not specify the secondsValue and msValue parameters, the same values as what are returned by getSeconds() and getMilliseconds() are used.\nIf a parameter you specify is outside of the expected range, other parameters and the date information in the Date object are updated accordingly. For example, if you specify 100 for secondsValue, the minutes is incremented by 1 (minutesValue + 1), and 40 is used for seconds. ",
    "Date.prototype.getMinutes()": "The getMinutes() method of Date instances returns the minutes for this date according to local time. ",
    "Date() constructor": "The Date() constructor creates Date objects. When called as a function, it returns a string representing the current time. ",
    "Date.prototype.getUTCMonth()": "The getUTCMonth() method of Date instances returns the month for this date according to universal time, as a zero-based value (where zero indicates the first month of the year). ",
    "Date.prototype.getUTCHours()": "The getUTCHours() method of Date instances returns the hours for this date according to universal time. ",
    "Date.prototype.toISOString()": "The toISOString() method of Date instances returns a string representing this date in the date time string format, a simplified format based on ISO 8601, which is always 24 or 27 characters long (YYYY-MM-DDTHH:mm:ss.sssZ or \u00c2\u00b1YYYYYY-MM-DDTHH:mm:ss.sssZ, respectively). The timezone is always UTC, as denoted by the suffix Z. ",
    "Date.prototype.setHours()": "If you do not specify the minutesValue, secondsValue, and msValue parameters, the same values as what are returned by getMinutes(), getSeconds(), and getMilliseconds() are used.\nIf a parameter you specify is outside of the expected range, other parameters and the date information in the Date object are updated accordingly. For example, if you specify 100 for secondsValue, the minutes are incremented by 1 (minutesValue + 1), and 40 is used for seconds. ",
    "Date.prototype.getMonth()": "The return value of getMonth() is zero-based, which is useful for indexing into arrays of months, for example:\njsconst valentines = new Date(\"1995-02-14\");\nconst month = valentines.getMonth();\nconst monthNames = [\"January\", \"February\", \"March\" /* , \u00e2\u0080\u00a6 */];\n\nconsole.log(monthNames[month]); // \"February\"\n\nHowever, for the purpose of internationalization, you should prefer using Intl.DateTimeFormat with the options parameter instead.\njsconst options = { month: \"long\" };\nconsole.log(new Intl.DateTimeFormat(\"en-US\", options).format(valentines));\n// \"February\"\nconsole.log(new Intl.DateTimeFormat(\"de-DE\", options).format(valentines));\n// \"Februar\"\n ",
    "Date.prototype.setUTCHours()": "\n  If you do not specify the minutesValue,\n  secondsValue, and msValue parameters,\n  the values returned from the getUTCMinutes(), getUTCSeconds(),\n  and getUTCMilliseconds() methods\n  are used.\n\n\n  If a parameter you specify is outside of the expected range, setUTCHours()\n  attempts to update the date information in the Date object accordingly.\n  For example, if you use 100 for secondsValue, the minutes will\n  be incremented by 1 (minutesValue + 1), and 40 will be used for seconds.\n ",
    "Date.prototype.getMilliseconds()": "The getMilliseconds() method of Date instances returns the milliseconds for this date according to local time. ",
    "Date.prototype.setUTCMinutes()": "\n  If you do not specify the secondsValue and\n  msValue parameters, the values returned from\n  getUTCSeconds() and\n  getUTCMilliseconds() methods are\n  used.\n\n\n  If a parameter you specify is outside of the expected range,\n  setUTCMinutes() attempts to update the date information in the\n  Date object accordingly. For example, if you use 100 for\n  secondsValue, the minutes will be incremented by 1\n  (minutesValue + 1), and 40 will be used for seconds.\n ",
    "Date.prototype.setMonth()": "If you do not specify the dateValue parameter, the same value as what is returned by getDate() is used.\nIf a parameter you specify is outside of the expected range, other parameters and the date information in the Date object are updated accordingly. For example, if you specify 15 for monthValue, the year is incremented by 1, and 3 is used for month.\n\n  The current day of month will have an impact on the behavior of this method.\n  Conceptually it will add the number of days given by the current day of the month to the\n  1st day of the new month specified as the parameter, to return the new date.\n  For example, if the current value is 31st January 2016, calling setMonth with a value of 1 will return 2nd March 2016.\n  This is because in 2016 February had 29 days.\n ",
    "Date.prototype.getDay()": "The return value of getDay() is zero-based, which is useful for indexing into arrays of days, for example:\njsconst valentines = new Date(\"1995-02-14\");\nconst day = valentines.getDay();\nconst dayNames = [\"Sunday\", \"Monday\", \"Tuesday\" /* , \u00e2\u0080\u00a6 */];\n\nconsole.log(dayNames[day]); // \"Monday\"\n\nHowever, for the purpose of internationalization, you should prefer using Intl.DateTimeFormat with the options parameter instead.\njsconst options = { weekday: \"long\" };\nconsole.log(new Intl.DateTimeFormat(\"en-US\", options).format(valentines));\n// \"Monday\"\nconsole.log(new Intl.DateTimeFormat(\"de-DE\", options).format(valentines));\n// \"Montag\"\n ",
    "Date.prototype.getUTCDate()": "The getUTCDate() method of Date instances returns the day of the month for this date according to universal time. ",
    "Date.prototype.getTime()": "Date objects are fundamentally represented by a timestamp, and this method allows you to retrieve the timestamp. You can use this method to help assign a date and time to another Date object. This method is functionally equivalent to the valueOf() method. ",
    "String.prototype.substr()": "A string's substr() method extracts length characters from the string, counting from the start index.\n\nIf start >= str.length, an empty string is returned.\nIf start < 0, the index starts counting from the end of the string. More formally, in this case the substring starts at max(start + str.length, 0).\nIf start is omitted or undefined, it's treated as 0.\nIf length is omitted or undefined, or if start + length >= str.length, substr() extracts characters to the end of the string.\nIf length < 0, an empty string is returned.\nFor both start and length, NaN is treated as 0.\n\nAlthough you are encouraged to avoid using substr(), there is no trivial way to migrate substr() to either slice() or substring() in legacy code without essentially writing a polyfill for substr(). For example, str.substr(a, l), str.slice(a, a + l), and str.substring(a, a + l) all have different results when str = \"01234\", a = 1, l = -2 \u00e2\u0080\u0094 substr() returns an empty string, slice() returns \"123\", while substring() returns \"0\". The actual refactoring path depends on the knowledge of the range of a and l. ",
    "String.prototype.sup()": "Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time. \n The sup() method of String values creates a string that embeds this string in a <sup> element (<sup>str</sup>), which causes this string to be displayed as superscript. \n \nNote: All HTML wrapper methods are deprecated and only standardized for compatibility purposes. Use DOM APIs such as document.createElement() instead.\n ",
    "String.prototype.match()": "The implementation of String.prototype.match itself is very simple \u00e2\u0080\u0094 it simply calls the Symbol.match method of the argument with the string as the first parameter. The actual implementation comes from RegExp.prototype[@@match]().\n\nIf you need to know if a string matches a regular expression RegExp, use RegExp.prototype.test().\nIf you only want the first match found, you might want to use RegExp.prototype.exec() instead.\nIf you want to obtain capture groups and the global flag is set, you need to use RegExp.prototype.exec() or String.prototype.matchAll() instead.\n\nFor more information about the semantics of match() when a regex is passed, see RegExp.prototype[@@match](). ",
    "String.prototype.trimEnd()": "The trimEnd() method of String values removes whitespace from the end of this string and returns a new string, without modifying the original string. trimRight() is an alias of this method. ",
    "String.prototype.toLowerCase()": "\n  The toLowerCase() method returns the value of the string converted to\n  lower case. toLowerCase() does not affect the value of the string\n  str itself.\n ",
    "String.prototype.toUpperCase()": "\n  The toUpperCase() method returns the value of the string converted to\n  uppercase. This method does not affect the value of the string itself since JavaScript\n  strings are immutable.\n ",
    "String.prototype.toWellFormed()": "Strings in JavaScript are UTF-16 encoded. UTF-16 encoding has the concept of surrogate pairs, which is introduced in detail in the UTF-16 characters, Unicode code points, and grapheme clusters section.\ntoWellFormed() iterates through the code units of this string, and replaces any lone surrogates with the Unicode replacement character U+FFFD \u00ef\u00bf\u00bd. This ensures that the returned string is well-formed and can be used in functions that expect well-formed strings, such as encodeURI. Compared to a custom implementation, toWellFormed() is more efficient, as engines can directly access the internal representation of strings.\nWhen ill-formed strings are used in certain contexts, such as TextEncoder, they are automatically converted to well-formed strings using the same replacement character. When lone surrogates are rendered, they are also rendered as the replacement character (a diamond with a question mark inside). ",
    "String.prototype.charAt()": "Characters in a string are indexed from left to right. The index of the first character is 0, and the index of the last character in a string called str is str.length - 1.\nUnicode code points range from 0 to 1114111 (0x10FFFF). charAt() always returns a character whose value is less than 65536, because the higher code points are represented by a pair of 16-bit surrogate pseudo-characters. Therefore, in order to get a full character with value greater than 65535, it is necessary to retrieve not only charAt(i), but also charAt(i + 1) (as if manipulating a string with two characters), or to use codePointAt(i) and String.fromCodePoint() instead. For information on Unicode, see UTF-16 characters, Unicode code points, and grapheme clusters.\ncharAt() is very similar to using bracket notation to access a character at the specified index. The main differences are:\n\ncharAt() attempts to convert index to an integer, while bracket notation does not, and directly uses index as a property name.\ncharAt() returns an empty string if index is out of range, while bracket notation returns undefined.\n ",
    "String.prototype.big()": "Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time. \n The big() method of String values creates a string that embeds this string in a <big> element (<big>str</big>), which causes this string to be displayed in a big font. \n \nNote: All HTML wrapper methods are deprecated and only standardized for compatibility purposes. For the case of big(), the <big> element itself has been removed from the HTML specification and shouldn't be used anymore. Web developers should use CSS properties instead.\n ",
    "String.prototype.blink()": "Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time. \n The blink() method of String values creates a string that embeds this string in a <blink> element (<blink>str</blink>), which used to cause a string to blink in old browsers. \n \nNote: All HTML wrapper methods are deprecated and only standardized for compatibility purposes. For the case of blink(), the <blink> element itself is removed from modern browsers, and blinking text is frowned upon by several accessibility standards. Avoid using the element in any way.\n ",
    "String.prototype.startsWith()": "This method lets you determine whether or not a string begins with another string. This method is case-sensitive. ",
    "String.prototype.strike()": "Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time. \n The strike() method of String values creates a string that embeds this string in a <strike> element (<strike>str</strike>), which causes this string to be displayed as struck-out text. \n \nNote: All HTML wrapper methods are deprecated and only standardized for compatibility purposes. For the case of strike(), the <strike> element itself has been removed from the HTML specification and shouldn't be used anymore. Web developers should use the <del> for deleted content or the <s> for content that is no longer accurate or no longer relevant instead.\n ",
    "String.prototype.trimStart()": "The trimStart() method of String values removes whitespace from the beginning of this string and returns a new string, without modifying the original string. trimLeft() is an alias of this method. ",
    "String.prototype.toString()": "\n  The String object overrides the toString method of Object; it does not inherit\n  Object.prototype.toString(). For String values, the toString method returns the string itself (if it's a primitive) or the string that the String object wraps. It has the exact same implementation as String.prototype.valueOf().\n\nThe toString() method requires its this value to be a String primitive or wrapper object. It throws a TypeError for other this values without attempting to coerce them to string values.\nBecause String doesn't have a [@@toPrimitive]() method, JavaScript calls the toString() method automatically when a String object is used in a context expecting a string, such as in a template literal. However, String primitive values do not consult the toString() method to be coerced to strings \u00e2\u0080\u0094 since they are already strings, no conversion is performed.\njsString.prototype.toString = () => \"Overridden\";\nconsole.log(`${\"foo\"}`); // \"foo\"\nconsole.log(`${new String(\"foo\")}`); // \"Overridden\"\n ",
    "String.prototype.link()": "Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time. \n The link() method of String values creates a string that embeds this string in an <a> element (<a href=\"...\">str</a>), to be used as a hypertext link to another URL. \n \nNote: All HTML wrapper methods are deprecated and only standardized for compatibility purposes. Use DOM APIs such as document.createElement() instead.\n ",
    "String.prototype.toLocaleUpperCase()": "\n  The toLocaleUpperCase() method returns the value of the string converted\n  to upper case according to any locale-specific case mappings.\n  toLocaleUpperCase() does not affect the value of the string itself. In most\n  cases, this will produce the same result as toUpperCase(), but for some locales, such as Turkish, whose case mappings do not\n  follow the default case mappings in Unicode, there may be a different result.\n\n\n  Also notice that conversion is not necessarily a 1:1 character mapping, as some\n  characters might result in two (or even more) characters when transformed to upper-case.\n  Therefore the length of the result string can differ from the input length. This also\n  implies that the conversion is not stable, so i.E. the following can return\n  false:\n  x.toLocaleLowerCase() === x.toLocaleUpperCase().toLocaleLowerCase()\n ",
    "String.prototype.repeat()": "\n  The repeat() method of String values constructs and returns a new string\n  which contains the specified number of copies of this string, concatenated together.\n ",
    "String.fromCodePoint()": "Because fromCodePoint() is a static method of String, you always use it as String.fromCodePoint(), rather than as a method of a String value you created.\nUnicode code points range from 0 to 1114111 (0x10FFFF). In UTF-16, each string index is a code unit with value 0 \u00e2\u0080\u0093 65535. Higher code points are represented by a pair of 16-bit surrogate pseudo-characters. Therefore, fromCodePoint() may return a string whose length (in UTF-16 code units) is larger than the number of arguments passed. For information on Unicode, see UTF-16 characters, Unicode code points, and grapheme clusters. ",
    "String.prototype.replaceAll()": "This method does not mutate the string value it's called on. It returns a new string.\nUnlike replace(), this method would replace all occurrences of a string, not just the first one. This is especially useful if the string is not statically known, as calling the RegExp() constructor without escaping special characters may unintentionally change its semantics.\njsfunction unsafeRedactName(text, name) {\n  return text.replace(new RegExp(name, \"g\"), \"[REDACTED]\");\n}\nfunction safeRedactName(text, name) {\n  return text.replaceAll(name, \"[REDACTED]\");\n}\n\nconst report =\n  \"A hacker called ha.*er used special characters in their name to breach the system.\";\n\nconsole.log(unsafeRedactName(report, \"ha.*er\")); // \"A [REDACTED]s in their name to breach the system.\"\nconsole.log(safeRedactName(report, \"ha.*er\")); // \"A hacker called [REDACTED] used special characters in their name to breach the system.\"\n\nIf pattern is an object with a Symbol.replace method (including RegExp objects), that method is called with the target string and replacement as arguments. Its return value becomes the return value of replaceAll(). In this case the behavior of replaceAll() is entirely encoded by the @@replace method, and therefore will have the same result as replace() (apart from the extra input validation that the regex is global).\nIf the pattern is an empty string, the replacement will be inserted in between every UTF-16 code unit, similar to split() behavior.\njs\"xxx\".replaceAll(\"\", \"_\"); // \"_x_x_x_\"\n\nFor more information about how regex properties (especially the sticky flag) interact with replaceAll(), see RegExp.prototype[@@replace](). ",
    "String.prototype.toLocaleLowerCase()": "\n  The toLocaleLowerCase() method returns the value of the string converted\n  to lower case according to any locale-specific case mappings.\n  toLocaleLowerCase() does not affect the value of the string itself. In most\n  cases, this will produce the same result as toLowerCase(), but for some locales, such as Turkish, whose case mappings do not\n  follow the default case mappings in Unicode, there may be a different result.\n ",
    "String.prototype.fontsize()": "The fontsize() method itself simply joins the string parts together without any validation or normalization. However, to create valid <font> elements, When you specify size as an integer, you set the font size of str to one of the 7 defined sizes. You can specify size as a string such as \"-2\" or \"+3\" to adjust the font size of str relative to 3, the default value. ",
    "String.prototype.charCodeAt()": "Characters in a string are indexed from left to right. The index of the first character is 0, and the index of the last character in a string called str is str.length - 1.\nUnicode code points range from 0 to 1114111 (0x10FFFF). charCodeAt() always returns a value that is less than 65536, because the higher code points are represented by a pair of 16-bit surrogate pseudo-characters. Therefore, in order to get a full character with value greater than 65535, it is necessary to retrieve not only charCodeAt(i), but also charCodeAt(i + 1) (as if manipulating a string with two characters), or to use codePointAt(i) instead. For information on Unicode, see UTF-16 characters, Unicode code points, and grapheme clusters. ",
    "String.prototype.indexOf()": "Strings are zero-indexed: The index of a string's first character is 0, and the index of a string's last character is the length of the string minus 1.\njs\"Blue Whale\".indexOf(\"Blue\"); // returns  0\n\"Blue Whale\".indexOf(\"Blute\"); // returns -1\n\"Blue Whale\".indexOf(\"Whale\", 0); // returns  5\n\"Blue Whale\".indexOf(\"Whale\", 5); // returns  5\n\"Blue Whale\".indexOf(\"Whale\", 7); // returns -1\n\"Blue Whale\".indexOf(\"\"); // returns  0\n\"Blue Whale\".indexOf(\"\", 9); // returns  9\n\"Blue Whale\".indexOf(\"\", 10); // returns 10\n\"Blue Whale\".indexOf(\"\", 11); // returns 10\n\n\n  The indexOf() method is case sensitive. For example, the following\n  expression returns -1:\n\njs\"Blue Whale\".indexOf(\"blue\"); // returns -1\n ",
    "String.prototype.padEnd()": "\n  The padEnd() method of String values pads this string with a given\n  string (repeated, if needed) so that the resulting string reaches a given length. The\n  padding is applied from the end of this string.\n ",
    "String.prototype.bold()": "Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time. \n The bold() method of String values creates a string that embeds this string in a <b> element (<b>str</b>), which causes this string to be displayed as bold. \n \nNote: All HTML wrapper methods are deprecated and only standardized for compatibility purposes. Use DOM APIs such as document.createElement() instead.\n ",
    "String.prototype.at()": "The at() method of String values takes an integer value and returns a new String consisting of the single UTF-16 code unit located at the specified offset. This method allows for positive and negative integers. Negative integers count back from the last string character. ",
    "String.prototype.sub()": "Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time. \n The sub() method of String values creates a string that embeds this string in a <sub> element (<sub>str</sub>), which causes this string to be displayed as subscript. \n \nNote: All HTML wrapper methods are deprecated and only standardized for compatibility purposes. Use DOM APIs such as document.createElement() instead.\n ",
    "String: length": "This property returns the number of code units in the string. JavaScript uses UTF-16 encoding, where each Unicode character may be encoded as one or two code units, so it's possible for the value returned by length to not match the actual number of Unicode characters in the string. For common scripts like Latin, Cyrillic, wellknown CJK characters, etc., this should not be an issue, but if you are working with certain scripts, such as emojis, mathematical symbols, or obscure Chinese characters, you may need to account for the difference between code units and characters.\nThe language specification requires strings to have a maximum length of 253 - 1 elements, which is the upper limit for precise integers. However, a string with this length needs 16384TiB of storage, which cannot fit in any reasonable device's memory, so implementations tend to lower the threshold, which allows the string's length to be conveniently stored in a 32-bit integer.\n\nIn V8 (used by Chrome and Node), the maximum length is 229 - 24 (~1GiB). On 32-bit systems, the maximum length is 228 - 16 (~512MiB).\nIn Firefox, the maximum length is 230 - 2 (~2GiB). Before Firefox 65, the maximum length was 228 - 1 (~512MiB).\nIn Safari, the maximum length is 231 - 1 (~4GiB).\n\nIf you are working with large strings in other encodings (such as UTF-8 files or blobs), note that when you load the data into a JS string, the encoding always becomes UTF-16. The size of the string may be different from the size of the source file.\njsconst str1 = \"a\".repeat(2 ** 29 - 24); // Success\nconst str2 = \"a\".repeat(2 ** 29 - 23); // RangeError: Invalid string length\n\nconst buffer = new Uint8Array(2 ** 29 - 24).fill(\"a\".codePointAt(0)); // This buffer is 512MiB in size\nconst str = new TextDecoder().decode(buffer); // This string is 1GiB in size\n\nFor an empty string, length is 0.\nThe static property String.length is unrelated to the length of strings. It's the arity of the String function (loosely, the number of formal parameters it has), which is 1.\nSince length counts code units instead of characters, if you want to get the number of characters, you can first split the string with its iterator, which iterates by characters:\njsfunction getCharacterLength(str) {\n  // The string iterator that is used here iterates over characters,\n  // not mere code units\n  return [...str].length;\n}\n\nconsole.log(getCharacterLength(\"A\\uD87E\\uDC04Z\")); // 3\n ",
    "String.prototype.anchor()": "Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time. \n The anchor() method of String values creates a string that embeds this string in an <a> element with a name (<a name=\"...\">str</a>). \n \nNote: All HTML wrapper methods are deprecated and only standardized for compatibility purposes. Use DOM APIs such as document.createElement() instead.\nThe HTML specification no longer allows the <a> element to have a name attribute, so this method doesn't even create valid markup.\n ",
    "String.prototype.split()": "If separator is a non-empty string, the target string is split by all matches of the separator without including separator in the results. For example, a string containing tab separated values (TSV) could be parsed by passing a tab character as the separator, like myString.split(\"\\t\"). If separator contains multiple characters, that entire character sequence must be found in order to split. If separator appears at the beginning (or end) of the string, it still has the effect of splitting, resulting in an empty (i.e. zero length) string appearing at the first (or last) position of the returned array. If separator does not occur in str, the returned array contains one element consisting of the entire string.\nIf separator is an empty string (\"\"), str is converted to an array of each of its UTF-16 \"characters\", without empty strings on either ends of the resulting string.\n\nNote: \"\".split(\"\") is therefore the only way to produce an empty array when a string is passed as separator and limit is not 0.\n\n\nWarning: When the empty string (\"\") is used as a separator, the string is not split by user-perceived characters (grapheme clusters) or unicode characters (code points), but by UTF-16 code units. This destroys surrogate pairs. See \"How do you get a string to a character array in JavaScript?\" on StackOverflow.\n\nIf separator is a regexp that matches empty strings, whether the match is split by UTF-16 code units or Unicode code points depends on if the regex is Unicode-aware.\njs\"\u00f0\u009f\u0098\u0084\u00f0\u009f\u0098\u0084\".split(/(?:)/); // [ \"\\ud83d\", \"\\ude04\", \"\\ud83d\", \"\\ude04\" ]\n\"\u00f0\u009f\u0098\u0084\u00f0\u009f\u0098\u0084\".split(/(?:)/u); // [ \"\u00f0\u009f\u0098\u0084\", \"\u00f0\u009f\u0098\u0084\" ]\n\nIf separator is a regular expression with capturing groups, then each time separator matches, the captured groups (including any undefined results) are spliced into the output array. This behavior is specified by the regexp's Symbol.split method.\nIf separator is an object with a Symbol.split method, that method is called with the target string and limit as arguments, and this set to the object. Its return value becomes the return value of split.\nAny other value will be coerced to a string before being used as separator. ",
    "String.prototype.valueOf()": "\n  The valueOf() method of String returns the primitive value\n  of a String object as a string data type. This value is equivalent to\n  String.prototype.toString().\n\nThis method is usually called internally by JavaScript and not explicitly in code. ",
    "String.prototype.fixed()": "Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time. \n The fixed() method of String values creates a string that embeds this string in a <tt> element (<tt>str</tt>), which causes this string to be displayed in a fixed-width font. \n \nNote: All HTML wrapper methods are deprecated and only standardized for compatibility purposes. For the case of fixed(), the <tt> element itself has been removed from the HTML specification and shouldn't be used anymore. Web developers should use CSS properties instead.\n ",
    "String.prototype.codePointAt()": "Characters in a string are indexed from left to right. The index of the first character is 0, and the index of the last character in a string called str is str.length - 1.\nUnicode code points range from 0 to 1114111 (0x10FFFF). In UTF-16, each string index is a code unit with value 0 \u00e2\u0080\u0093 65535. Higher code points are represented by a pair of 16-bit surrogate pseudo-characters. Therefore, codePointAt() returns a code point that may span two string indices. For information on Unicode, see UTF-16 characters, Unicode code points, and grapheme clusters. ",
    "String.prototype.substring()": "substring() extracts characters from indexStart up to but not including indexEnd. In particular:\n\nIf indexEnd is omitted, substring() extracts characters to the end of the string.\nIf indexStart is equal to indexEnd, substring() returns an empty string.\nIf indexStart is greater than indexEnd, then the effect of substring() is as if the two arguments were swapped; see example below.\n\nAny argument value that is less than 0 or greater than str.length is treated as if it were 0 and str.length, respectively.\nAny argument value that is NaN is treated as if it were 0. ",
    "String.prototype.concat()": "\n  The concat() function concatenates the string arguments to the calling\n  string and returns a new string. Changes to the original string or the returned string\n  don't affect the other.\n\n\n  If the arguments are not of the type string, they are converted to string values before\n  concatenating.\n\nThe concat() method is very similar to the addition/string concatenation operators (+, +=), except that concat() coerces its arguments directly to strings, while addition coerces its operands to primitives first. For more information, see the reference page for the + operator. ",
    "String.prototype.italics()": "Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time. \n The italics() method of String values creates a string that embeds this string in an <i> element (<i>str</i>), which causes this string to be displayed as italic. \n \nNote: All HTML wrapper methods are deprecated and only standardized for compatibility purposes. Use DOM APIs such as document.createElement() instead.\n ",
    "String.prototype.trim()": "The trim() method of String values removes whitespace from both ends of this string and returns a new string, without modifying the original string. \n To return a new string with whitespace trimmed from just one end, use trimStart() or trimEnd(). ",
    "String.prototype.slice()": "slice() extracts the text from one string and returns a new string. Changes to the text in one string do not affect the other string.\nslice() extracts up to but not including indexEnd. For example, str.slice(4, 8) extracts the fifth character through the eighth character (characters indexed 4, 5, 6, and 7):\n              indexStart        indexEnd\n                  \u00e2\u0086\u0093               \u00e2\u0086\u0093\n| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |\n| T | h | e |   | m | i | r | r | o | r |\n\n                  m   i   r   r\n                 _______________\n                      \u00e2\u0086\u0091\n                    Result\n\n\nIf indexStart >= str.length, an empty string is returned.\nIf indexStart < 0, the index is counted from the end of the string. More formally, in this case, the substring starts at max(indexStart + str.length, 0).\nIf indexStart is omitted, undefined, or cannot be converted to a number, it's treated as 0.\nIf indexEnd is omitted, undefined, or cannot be converted to a number, or if indexEnd >= str.length, slice() extracts to the end of the string.\nIf indexEnd < 0, the index is counted from the end of the string. More formally, in this case, the substring ends at max(indexEnd + str.length, 0).\nIf indexEnd <= indexStart after normalizing negative values (i.e. indexEnd represents a character that's before indexStart), an empty string is returned.\n ",
    "String.fromCharCode()": "Because fromCharCode() is a static method of String, you always use it as String.fromCharCode(), rather than as a method of a String value you created.\nUnicode code points range from 0 to 1114111 (0x10FFFF). charCodeAt() always returns a value that is less than 65536, because the higher code points are represented by a pair of 16-bit surrogate pseudo-characters. Therefore, in order to produce a full character with value greater than 65535, it is necessary to provide two code units (as if manipulating a string with two characters). For information on Unicode, see UTF-16 characters, Unicode code points, and grapheme clusters.\nBecause fromCharCode() only works with 16-bit values (same as the \\u escape sequence), a surrogate pair is required in order to return a supplementary character. For example, both String.fromCharCode(0xd83c, 0xdf03) and \"\\ud83c\\udf03\" return code point U+1F303 \"Night with Stars\". While there is a mathematical relationship between the supplementary code point value (e.g. 0x1f303) and both surrogate values that represent it (e.g., 0xd83c and 0xdf03), it does require an extra step to either calculate or look up the surrogate pair values every time a supplementary code point is to be used. For this reason, it's more convenient to use String.fromCodePoint(), which allows for returning supplementary characters based on their actual code point value. For example, String.fromCodePoint(0x1f303) returns code point U+1F303 \"Night with Stars\". ",
    "String.prototype.small()": "Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time. \n The small() method of String values creates a string that embeds this string in a <small> element (<small>str</small>), which causes this string to be displayed in a small font. \n \nNote: All HTML wrapper methods are deprecated and only standardized for compatibility purposes. Use DOM APIs such as document.createElement() instead.\n ",
    "String.prototype.padStart()": "\n  The padStart() method of String values pads this string with another string (multiple times, if needed) until the resulting\n  string reaches the given length. The padding is applied from the start of this string.\n ",
    "String.prototype.includes()": "This method lets you determine whether or not a string includes another string. ",
    "String.prototype.endsWith()": "This method lets you determine whether or not a string ends with another string. This method is case-sensitive. ",
    "String.raw()": "In most cases, String.raw() is used with template literals. The first syntax mentioned above is only rarely used, because the JavaScript engine will call this with proper arguments for you, (just like with other tag functions).\nString.raw() is the only built-in template literal tag. It has close semantics to an untagged literal since it concatenates all arguments and returns a string. You can even re-implement it with normal JavaScript code.\n\nWarning: You should not use String.raw directly as an \"identity\" tag. See Building an identity tag for how to implement this.\n\nIf String.raw() is called with an object whose raw property doesn't have a length property or a non-positive length, it returns an empty string \"\". If substitutions.length < strings.raw.length - 1 (i.e. there are not enough substitutions to fill the placeholders \u00e2\u0080\u0094 which can't happen in a well-formed tagged template literal), the rest of the placeholders are filled with empty strings. ",
    "": "",
    "String.prototype.isWellFormed()": "Strings in JavaScript are UTF-16 encoded. UTF-16 encoding has the concept of surrogate pairs, which is introduced in detail in the UTF-16 characters, Unicode code points, and grapheme clusters section.\nisWellFormed() allows you to test whether a string is well-formed (i.e. does not contain any lone surrogates). Compared to a custom implementation, isWellFormed() is more efficient, as engines can directly access the internal representation of strings. If you need to convert a string to a well-formed string, use the toWellFormed() method. isWellFormed() allows you to handle ill-formed strings differently from well-formed strings, such as throwing an error or marking it as invalid. ",
    "String.prototype.search()": "The implementation of String.prototype.search() itself is very simple \u00e2\u0080\u0094 it simply calls the Symbol.search method of the argument with the string as the first parameter. The actual implementation comes from RegExp.prototype[@@search]().\nThe g flag of regexp has no effect on the search() result, and the search always happens as if the regex's lastIndex is 0. For more information on the behavior of search(), see RegExp.prototype[@@search]().\nWhen you want to know whether a pattern is found, and also know its index within a string, use search().\n\nIf you only want to know if it exists, use the RegExp.prototype.test() method, which returns a boolean.\nIf you need the content of the matched text, use String.prototype.match() or RegExp.prototype.exec().\n ",
    "String.prototype.matchAll()": "The implementation of String.prototype.matchAll itself is very simple \u00e2\u0080\u0094 it simply calls the Symbol.matchAll method of the argument with the string as the first parameter (apart from the extra input validation that the regex is global). The actual implementation comes from RegExp.prototype[@@matchAll](). ",
    "String.prototype.normalize()": "\n  Unicode assigns a unique numerical value, called a code point, to each\n  character. For example, the code point for \"A\" is given as U+0041. However,\n  sometimes more than one code point, or sequence of code points, can represent the same\n  abstract character \u00e2\u0080\u0094 the character \"\u00c3\u00b1\" for example can be represented by\n  either of:\n\n\nThe single code point U+00F1.\n\n    The code point for \"n\" (U+006E) followed by the code point for the\n    combining tilde (U+0303).\n  \n\njsconst string1 = \"\\u00F1\";\nconst string2 = \"\\u006E\\u0303\";\n\nconsole.log(string1); // \u00c3\u00b1\nconsole.log(string2); // \u00c3\u00b1\n\n\n  However, since the code points are different, string comparison will not treat them as\n  equal. And since the number of code points in each version is different, they even have\n  different lengths.\n\njsconst string1 = \"\\u00F1\"; // \u00c3\u00b1\nconst string2 = \"\\u006E\\u0303\"; // \u00c3\u00b1\n\nconsole.log(string1 === string2); // false\nconsole.log(string1.length); // 1\nconsole.log(string2.length); // 2\n\n\n  The normalize() method helps solve this problem by converting a string\n  into a normalized form common for all sequences of code points that represent the same\n  characters. There are two main normalization forms, one based on canonical\nequivalence and the other based on compatibility.\n ",
    "String.prototype[@@iterator]()": "Strings are iterated by Unicode code points. This means grapheme clusters will be split, but surrogate pairs will be preserved.\njs// \"Backhand Index Pointing Right: Dark Skin Tone\"\n[...\"\u00f0\u009f\u0091\u0089\u00f0\u009f\u008f\u00bf\"]; // ['\u00f0\u009f\u0091\u0089', '\u00f0\u009f\u008f\u00bf']\n// splits into the basic \"Backhand Index Pointing Right\" emoji and\n// the \"Dark skin tone\" emoji\n\n// \"Family: Man, Boy\"\n[...\"\u00f0\u009f\u0091\u00a8\u00e2\u0080\u008d\u00f0\u009f\u0091\u00a6\"]; // [ '\u00f0\u009f\u0091\u00a8', '\u00e2\u0080\u008d', '\u00f0\u009f\u0091\u00a6' ]\n// splits into the \"Man\" and \"Boy\" emoji, joined by a ZWJ\n ",
    "String.prototype.fontcolor()": "The fontcolor() method itself simply joins the string parts together without any validation or normalization. However, to create valid <font> elements, if you express color as a hexadecimal RGB triplet, you must use the format rrggbb. For example, the hexadecimal RGB values for salmon are red=FA, green=80, and blue=72, so the RGB triplet for salmon is \"FA8072\". ",
    "String.prototype.lastIndexOf()": "Strings are zero-indexed: The index of a string's first character is 0, and the index of a string's last character is the length of the string minus 1.\njs\"canal\".lastIndexOf(\"a\"); // returns 3\n\"canal\".lastIndexOf(\"a\", 2); // returns 1\n\"canal\".lastIndexOf(\"a\", 0); // returns -1\n\"canal\".lastIndexOf(\"x\"); // returns -1\n\"canal\".lastIndexOf(\"c\", -5); // returns 0\n\"canal\".lastIndexOf(\"c\", 0); // returns 0\n\"canal\".lastIndexOf(\"\"); // returns 5\n\"canal\".lastIndexOf(\"\", 2); // returns 2\n ",
    "String.prototype.localeCompare()": "\n  Returns an integer indicating whether the referenceStr comes\n  before, after or is equivalent to the compareString.\n\n\n\n    Negative when the referenceStr occurs before\n    compareString\n\n\n    Positive when the referenceStr occurs after\n    compareString\n\nReturns 0 if they are equivalent\n\n\nWarning: Do not rely on exact return values of -1 or 1!\n\n    Negative and positive integer results vary between browsers (as well as between\n    browser versions) because the ECMAScript specification only mandates negative and positive\n    values. Some browsers may return -2 or 2, or even some other\n    negative or positive value.\n  \n ",
    "String() constructor": "The String() constructor creates String objects. When called as a function, it returns primitive values of type String. ",
    "String.prototype.replace()": "This method does not mutate the string value it's called on. It returns a new string.\nA string pattern will only be replaced once. To perform a global search and replace, use a regular expression with the g flag, or use replaceAll() instead.\nIf pattern is an object with a Symbol.replace method (including RegExp objects), that method is called with the target string and replacement as arguments. Its return value becomes the return value of replace(). In this case the behavior of replace() is entirely encoded by the @@replace method \u00e2\u0080\u0094 for example, any mention of \"capturing groups\" in the description below is actually functionality provided by RegExp.prototype[@@replace].\nIf the pattern is an empty string, the replacement is prepended to the start of the string.\njs\"xxx\".replace(\"\", \"_\"); // \"_xxx\"\n\nA regexp with the g flag is the only case where replace() replaces more than once. For more information about how regex properties (especially the sticky flag) interact with replace(), see RegExp.prototype[@@replace](). ",
    "RegExp.prototype.flags": "RegExp.prototype.flags has a string as its value. Flags in the flags property are sorted alphabetically (from left to right, e.g. \"dgimsuvy\"). It actually invokes the other flag accessors (hasIndices, global, etc.) one-by-one and concatenates the results.\nAll built-in functions read the flags property instead of reading individual flag accessors.\nThe set accessor of flags is undefined. You cannot change this property directly. ",
    "RegExp.prototype.multiline": "RegExp.prototype.multiline has the value true if the m flag was used; otherwise, false. The m flag indicates that a multiline input string should be treated as multiple lines. For example, if m is used, ^ and $ change from matching at only the start or end of the entire string to the start or end of any line within the string.\nThe set accessor of multiline is undefined. You cannot change this property directly. ",
    "RegExp() constructor": "The RegExp() constructor creates RegExp objects. \n For an introduction to regular expressions, read the Regular Expressions chapter in the JavaScript Guide. ",
    "RegExp.prototype.test()": "\n  Use test() whenever you want to know whether a pattern is found in a\n  string. test() returns a boolean, unlike the\n  String.prototype.search() method (which returns the index of a match, or\n  -1 if not found).\n\n\n  To get more information (but with slower execution), use the\n  exec() method. (This is similar to the\n  String.prototype.match() method.)\n\n\n  As with exec() (or in combination with it), test() called\n  multiple times on the same global regular expression instance will advance past the\n  previous match.\n ",
    "RegExp.prototype.toString()": "The RegExp object overrides the toString() method of the Object object; it does not inherit Object.prototype.toString(). For RegExp objects, the toString() method returns a string representation of the regular expression.\nIn practice, it reads the regex's source and flags properties and returns a string in the form /source/flags. The toString() return value is guaranteed to be a parsable regex literal, although it may not be the exact same text as what was originally specified for the regex (for example, the flags may be reordered). ",
    "RegExp.prototype.unicodeSets": "RegExp.prototype.unicodeSets has the value true if the v flag was used; otherwise, false. The v flag is an \"upgrade\" to the u flag that enables more Unicode-related features. (\"v\" is the next letter after \"u\" in the alphabet.) Because u and v interpret the same regex in incompatible ways, using both flags results in a SyntaxError. With the v flag, you get all features mentioned in the u flag description, plus:\n\nThe \\p escape sequence can be additionally used to match properties of strings, instead of just characters.\nThe character class syntax is upgraded to allow intersection, union, and subtraction syntaxes, as well as matching multiple Unicode characters.\nThe character class complement syntax [^...] constructs a complement class instead of negating the match result, avoiding some confusing behaviors with case-insensitive matching. For more information, see Complement classes and case-insensitive matching.\n\nSome valid u-mode regexes become invalid in v-mode. Specifically, the character class syntax is different and some characters can no longer appear literally. For more information, see v-mode character class.\n\nNote: The v mode does not interpret grapheme clusters as single characters; they are still multiple code points. For example, /[\u00f0\u009f\u0087\u00ba\u00f0\u009f\u0087\u00b3]/v is still able to match \"\u00f0\u009f\u0087\u00ba\".\n\nThe set accessor of unicodeSets is undefined. You cannot change this property directly. ",
    "RegExp.input ($_)": "Because input is a static property of RegExp, you always use it as RegExp.input or RegExp.$_, rather than as a property of a RegExp object you created.\nThe value of input updates whenever a RegExp (but not a RegExp subclass) instance makes a successful match. If no matches have been made, input is an empty string. You can set the value of input, but this does not affect other behaviors of the regex, and the value will be overwritten again when the next successful match is made. ",
    "RegExp.prototype[@@split]()": "This method is called internally in String.prototype.split() when a RegExp is passed as the separator. For example, the following two examples return the same result.\njs\"a-b-c\".split(/-/);\n\n/-/[Symbol.split](\"a-b-c\");\n\nThis method exists for customizing the behavior of split() in RegExp subclasses.\nThe RegExp.prototype[@@split]() base method exhibits the following behaviors:\n\nIt starts by using @@species to construct a new regexp, thus avoiding mutating the original regexp in any way.\nThe regexp's g (\"global\") flag is ignored, and the y (\"sticky\") flag is always applied even when it was not originally present.\nIf the target string is empty, and the regexp can match empty strings (for example, /a?/), an empty array is returned. Otherwise, if the regexp can't match an empty string, [\"\"] is returned.\nThe matching proceeds by continuously calling this.exec(). Since the regexp is always sticky, this will move along the string, each time yielding a matching string, index, and any capturing groups.\nFor each match, the substring between the last matched string's end and the current matched string's beginning is first appended to the result array. Then, the capturing groups' values are appended one-by-one.\nIf the current match is an empty string, or if the regexp doesn't match at the current position (since it's sticky), the lastIndex would still be advanced \u00e2\u0080\u0094 if the regex is Unicode-aware, it would advance by one Unicode code point; otherwise, it advances by one UTF-16 code unit.\nIf the regexp doesn't match the target string, the target string is returned as-is, wrapped in an array.\nThe returned array's length will never exceed the limit parameter, if provided, while trying to be as close as possible. Therefore, the last match and its capturing groups may not all be present in the returned array if the array is already filled.\n ",
    "RegExp.prototype[@@match]()": "This method is called internally in String.prototype.match().\nFor example, the following two examples return same result.\njs\"abc\".match(/a/);\n\n/a/[Symbol.match](\"abc\");\n\nIf the regex is global (with the g flag), the regex's exec() method will be repeatedly called until exec() returns null. Otherwise, exec() would only be called once and its result becomes the return value of @@match.\nBecause @@match would keep calling exec() until it returns null, and exec() would automatically reset the regex's lastIndex to 0 when the last match fails, @@match would typically not have side effects when it exits. However, when the regex is sticky but not global, lastIndex would not be reset. In this case, each call to match() may return a different result.\njsconst re = /[abc]/y;\nfor (let i = 0; i < 5; i++) {\n  console.log(\"abc\".match(re), re.lastIndex);\n}\n// [ 'a' ] 1\n// [ 'b' ] 2\n// [ 'c' ] 3\n// null 0\n// [ 'a' ] 1\n\nWhen the regex is sticky and global, it would still perform sticky matches \u00e2\u0080\u0094 i.e. it would fail to match any occurrences beyond the lastIndex.\njsconsole.log(\"ab-c\".match(/[abc]/gy)); // [ 'a', 'b' ]\n\nIf the current match is an empty string, the lastIndex would still be advanced \u00e2\u0080\u0094 if the regex is Unicode-aware, it would advance by one Unicode code point; otherwise, it advances by one UTF-16 code unit.\njsconsole.log(\"\u00f0\u009f\u0098\u0084\".match(/(?:)/g)); // [ '', '', '' ]\nconsole.log(\"\u00f0\u009f\u0098\u0084\".match(/(?:)/gu)); // [ '', '' ]\n\nThis method exists for customizing match behavior within RegExp subclasses.\nIn addition, the @@match property is used to check whether an object is a regular expression. ",
    "RegExp.prototype.sticky": "RegExp.prototype.sticky has the value true if the y flag was used; otherwise, false. The y flag indicates that the regex attempts to match the target string only from the index indicated by the lastIndex property (and unlike a global regex, does not attempt to match from any later indexes).\nThe set accessor of sticky is undefined. You cannot change this property directly.\nFor both sticky regexes and global regexes:\n\nThey start matching at lastIndex.\nWhen the match succeeds, lastIndex is advanced to the end of the match.\nWhen lastIndex is out of bounds of the currently matched string, lastIndex is reset to 0.\n\nHowever, for the exec() method, the behavior when matching fails is different:\n\nWhen the exec() method is called on a sticky regex, if the regex fails to match at lastIndex, the regex immediately returns null and resets lastIndex to 0.\nWhen the exec() method is called on a global regex, if the regex fails to match at lastIndex, it tries to match from the next character, and so on until a match is found or the end of the string is reached.\n\nFor the exec() method, a regex that's both sticky and global behaves the same as a sticky and non-global regex. Because test() is a simple wrapper around exec(), test() would ignore the global flag and perform sticky matches as well. However, due to many other methods special-casing the behavior of global regexes, the global flag is, in general, orthogonal to the sticky flag.\n\nString.prototype.matchAll() (which calls RegExp.prototype[@@matchAll]()): y, g and gy are all different.\n    \nFor y regexes: matchAll() throws; [@@matchAll]() yields the exec() result exactly once, without updating the regex's lastIndex.\nFor g or gy regexes: returns an iterator that yields a sequence of exec() results.\n\n\nString.prototype.match() (which calls RegExp.prototype[@@match]()): y, g and gy are all different.\n    \nFor y regexes: returns the exec() result and updates the regex's lastIndex.\nFor g or gy regexes: returns an array of all exec() results.\n\n\nString.prototype.search() (which calls RegExp.prototype[@@search]()): the g flag is always irrelevant.\n    \nFor y or gy regexes: always returns 0 (if the very beginning of the string matches) or -1 (if the beginning doesn't match), without updating the regex's lastIndex when it exits.\nFor g regexes: returns the index of the first match in the string, or -1 if no match is found.\n\n\nString.prototype.split() (which calls RegExp.prototype[@@split]()): y, g, and gy all have the same behavior.\nString.prototype.replace() (which calls RegExp.prototype[@@replace]()): y, g and gy are all different.\n    \nFor y regexes: replaces once at the current lastIndex and updates lastIndex.\nFor g and gy regexes: replaces all occurrences matched by exec().\n\n\nString.prototype.replaceAll() (which calls RegExp.prototype[@@replace]()): y, g and gy are all different.\n    \nFor y regexes: replaceAll() throws.\nFor g and gy regexes: replaces all occurrences matched by exec().\n\n\n ",
    "RegExp.prototype[@@replace]()": "This method is called internally in String.prototype.replace() and String.prototype.replaceAll() if the pattern argument is a RegExp object. For example, the following two examples return the same result.\njs\"abc\".replace(/a/, \"A\");\n\n/a/[Symbol.replace](\"abc\", \"A\");\n\nIf the regex is global (with the g flag), the regex's exec() method will be repeatedly called until exec() returns null. Otherwise, exec() would only be called once. For each exec() result, the substitution will be prepared based on the description in String.prototype.replace().\nBecause @@replace would keep calling exec() until it returns null, and exec() would automatically reset the regex's lastIndex to 0 when the last match fails, @@replace would typically not have side effects when it exits. However, when the regex is sticky but not global, lastIndex would not be reset. In this case, each call to replace() may return a different result.\njsconst re = /a/y;\n\nfor (let i = 0; i < 5; i++) {\n  console.log(\"aaa\".replace(re, \"b\"), re.lastIndex);\n}\n\n// baa 1\n// aba 2\n// aab 3\n// aaa 0\n// baa 1\n\nWhen the regex is sticky and global, it would still perform sticky matches \u00e2\u0080\u0094 i.e. it would fail to match any occurrences beyond the lastIndex.\njsconsole.log(\"aa-a\".replace(/a/gy, \"b\")); // \"bb-a\"\n\nIf the current match is an empty string, the lastIndex would still be advanced \u00e2\u0080\u0094 if the regex is Unicode-aware, it would advance by one Unicode code point; otherwise, it advances by one UTF-16 code unit.\njsconsole.log(\"\u00f0\u009f\u0098\u0084\".replace(/(?:)/g, \" \")); // \" \\ud83d \\ude04 \"\nconsole.log(\"\u00f0\u009f\u0098\u0084\".replace(/(?:)/gu, \" \")); // \" \u00f0\u009f\u0098\u0084 \"\n\nThis method exists for customizing replace behavior in RegExp subclasses. ",
    "RegExp.prototype.hasIndices": "RegExp.prototype.hasIndices has the value true if the d flag was used; otherwise, false. The d flag indicates that the result of a regular expression match should contain the start and end indices of the substrings of each capture group. It does not change the regex's interpretation or matching behavior in any way, but only provides additional information in the matching result.\nThis flag primarily affects the return value of exec(). If the d flag is present, the array returned by exec() has an additional indices property as described in the exec() method's return value. Because all other regex-related methods (such as String.prototype.match()) call exec() internally, they will also return the indices if the regex has the d flag.\nThe set accessor of hasIndices is undefined. You cannot change this property directly. ",
    "RegExp.$1, \u00e2\u0080\u00a6, RegExp.$9": "Because $1\u00e2\u0080\u0093$9 are static properties of RegExp, you always use them as RegExp.$1, RegExp.$2, etc., rather than as properties of a RegExp object you created.\nThe values of $1, \u00e2\u0080\u00a6, $9 update whenever a RegExp (but not a RegExp subclass) instance makes a successful match. If no matches have been made, or if the last match does not have the corresponding capturing group, the respective property is an empty string. The set accessor of each property is undefined, so you cannot change the properties directly.\nThe number of possible parenthesized substrings is unlimited, but the RegExp object can only hold the first nine. You can access all parenthesized substrings through the returned array's indexes.\n$1, \u00e2\u0080\u00a6, $9 can also be used in the replacement string of String.prototype.replace(), but that's unrelated to the RegExp.$n legacy properties. ",
    "RegExp.leftContext ($`)": "Because leftContext is a static property of RegExp, you always use it as RegExp.leftContext or RegExp[\"$`\"], rather than as a property of a RegExp object you created.\nThe value of leftContext updates whenever a RegExp (but not a RegExp subclass) instance makes a successful match. If no matches have been made, leftContext is an empty string. The set accessor of leftContext is undefined, so you cannot change this property directly.\nYou cannot use the shorthand alias with the dot property accessor (RegExp.$` ), because ` is not a valid identifier part, so this causes a SyntaxError. Use the bracket notation instead.\n$` can also be used in the replacement string of String.prototype.replace(), but that's unrelated to the RegExp[\"$`\"] legacy property. ",
    "RegExp.prototype.compile()": "Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time. \n \nNote: The compile() method is only specified for compatibility reasons. Using compile() causes the otherwise immutable regex source and flags to become mutable, which may break user expectations. You can use the RegExp() constructor to construct a new regular expression object instead.\n \n The compile() method of RegExp instances is used to recompile a regular expression with new source and flags after the RegExp object has already been created. ",
    "RegExp.prototype.unicode": "RegExp.prototype.unicode has the value true if the u flag was used; otherwise, false. The u flag enables various Unicode-related features. With the \"u\" flag:\n\nAny Unicode code point escapes (\\u{xxxx}, \\p{UnicodePropertyValue}) will be interpreted as such instead of identity escapes. For example /\\u{61}/u matches \"a\", but /\\u{61}/ (without u flag) matches \"u\".repeat(61), where the \\u is equivalent to a single u.\nSurrogate pairs will be interpreted as whole characters instead of two separate characters. For example, /[\u00f0\u009f\u0098\u0084]/u would only match \"\u00f0\u009f\u0098\u0084\" but not \"\\ud83d\".\nWhen lastIndex is automatically advanced (such as when calling exec()), unicode regexes advance by Unicode code points instead of UTF-16 code units.\n\nThere are other changes to the parsing behavior that prevent possible syntax mistakes (which are analogous to strict mode for regex syntax). These syntaxes are all deprecated and only kept for web compatibility, and you should not rely on them.\nThe set accessor of unicode is undefined. You cannot change this property directly. ",
    "RegExp.prototype[@@search]()": "This method is called internally in String.prototype.search(). For example, the following two examples return the same result.\njs\"abc\".search(/a/);\n\n/a/[Symbol.search](\"abc\");\n\nThis method does not copy the regular expression, unlike @@split or @@matchAll. However, unlike @@match or @@replace, it will set lastIndex to 0 when execution starts and restore it to the previous value when it exits, therefore generally avoiding side effects. This means that the g flag has no effect with this method, and it always returns the first match in the string even when lastIndex is non-zero. This also means sticky regexps will always search strictly at the beginning of the string.\njsconst re = /[abc]/g;\nre.lastIndex = 2;\nconsole.log(\"abc\".search(re)); // 0\n\nconst re2 = /[bc]/y;\nre2.lastIndex = 1;\nconsole.log(\"abc\".search(re2)); // -1\nconsole.log(\"abc\".match(re2)); // [ 'b' ]\n\n@@search always calls the regex's exec() method exactly once, and returns the index property of the result, or -1 if the result is null.\nThis method exists for customizing the search behavior in RegExp subclasses. ",
    "RegExp.prototype[@@matchAll]()": "This method is called internally in String.prototype.matchAll(). For example, the following two examples return the same result.\njs\"abc\".matchAll(/a/g);\n\n/a/g[Symbol.matchAll](\"abc\");\n\nLike @@split, @@matchAll starts by using @@species to construct a new regex, thus avoiding mutating the original regexp in any way. lastIndex starts as the original regex's value.\njsconst regexp = /[a-c]/g;\nregexp.lastIndex = 1;\nconst str = \"abc\";\nArray.from(str.matchAll(regexp), (m) => `${regexp.lastIndex} ${m[0]}`);\n// [ \"1 b\", \"1 c\" ]\n\nThe validation that the input is a global regex happens in String.prototype.matchAll(). @@matchAll does not validate the input. If the regex is not global, the returned iterator yields the exec() result once and then returns undefined. If the regexp is global, each time the returned iterator's next() method is called, the regex's exec() is called and the result is yielded.\nWhen the regex is sticky and global, it will still perform sticky matches \u00e2\u0080\u0094 i.e. it will not match any occurrences beyond the lastIndex.\njsconsole.log(Array.from(\"ab-c\".matchAll(/[abc]/gy)));\n// [ [ \"a\" ], [ \"b\" ] ]\n\nIf the current match is an empty string, the lastIndex will still be advanced. If the regex has the u flag, it advances by one Unicode code point; otherwise, it advances by one UTF-16 code point.\njsconsole.log(Array.from(\"\u00f0\u009f\u0098\u0084\".matchAll(/(?:)/g)));\n// [ [ \"\" ], [ \"\" ], [ \"\" ] ]\n\nconsole.log(Array.from(\"\u00f0\u009f\u0098\u0084\".matchAll(/(?:)/gu)));\n// [ [ \"\" ], [ \"\" ] ]\n\nThis method exists for customizing the behavior of matchAll() in RegExp subclasses. ",
    "RegExp.prototype.source": "Conceptually, the source property is the text between the two forward slashes in the regular expression literal. The language requires the returned string to be properly escaped, so that when the source is concatenated with a forward slash on both ends, it would form a parsable regex literal. For example, for new RegExp(\"/\"), the source is \\\\/, because if it generates /, the resulting literal becomes ///, which is a line . Similarly, all line terminators will be escaped because line terminator characters would break up the regex literal. There's no requirement for other characters, as long as the result is parsable. For empty regular expressions, the string (?:) is returned. ",
    "RegExp.rightContext ($')": "Because rightContext is a static property of RegExp, you always use it as RegExp.rightContext or RegExp[\"$'\"], rather than as a property of a RegExp object you created.\nThe value of rightContext updates whenever a RegExp (but not a RegExp subclass) instance makes a successful match. If no matches have been made, rightContext is an empty string. The set accessor of rightContext is undefined, so you cannot change this property directly.\nYou cannot use the shorthand alias with the dot property accessor (RegExp.$'), because ' is not a valid identifier part, so this causes a SyntaxError. Use the bracket notation instead.\n$' can also be used in the replacement string of String.prototype.replace(), but that's unrelated to the RegExp[\"$'\"] legacy property. ",
    "RegExp[@@species]": "The @@species accessor property returns the default constructor for RegExp objects. Subclass constructors may override it to change the constructor assignment. The default implementation is basically:\njs// Hypothetical underlying implementation for illustration\nclass RegExp {\n  static get [Symbol.species]() {\n    return this;\n  }\n}\n\nBecause of this polymorphic implementation, @@species of derived subclasses would also return the constructor itself by default.\njsclass SubRegExp extends SubRegExp {}\nSubRegExp[Symbol.species] === SubRegExp; // true\n\nSome RegExp methods create a copy of the current regex instance before running exec(), so that side effects such as changes to lastIndex are not retained. The @@species property is used to determine the constructor of the new instance. The methods that copy the current regex instance are:\n\n[@@matchAll]()\n[@@split]()\n ",
    "RegExp.prototype.global": "RegExp.prototype.global has the value true if the g flag was used; otherwise, false. The g flag indicates that the regular expression should be tested against all possible matches in a string. Each call to exec() will update its lastIndex property, so that the next call to exec() will start at the next character.\nSome methods, such as String.prototype.matchAll() and String.prototype.replaceAll(), will validate that, if the parameter is a regex, it is global. The regex's @@match and @@replace methods (called by String.prototype.match() and String.prototype.replace()) would also have different behaviors when the regex is global.\nThe set accessor of global is undefined. You cannot change this property directly. ",
    "RegExp.prototype.ignoreCase": "RegExp.prototype.ignoreCase has the value true if the i flag was used; otherwise, false. The i flag indicates that case should be ignored while attempting a match in a string. Case-insensitive matching is done by mapping both the expected character set and the matched string to the same casing.\nIf the regex is Unicode-aware, the case mapping happens through simple case folding specified in CaseFolding.txt. The mapping always maps to a single code point, so it does not map, for example, \u00c3\u009f (U+00DF LATIN SMALL LETTER SHARP S) to ss (which is full case folding, not simple case folding). It may however map code points outside the Basic Latin block to code points within it \u00e2\u0080\u0094 for example, \u00c5\u00bf (U+017F LATIN SMALL LETTER LONG S) case-folds to s (U+0073 LATIN SMALL LETTER S) and \u00e2\u0084\u00aa (U+212A KELVIN SIGN) case-folds to k (U+006B LATIN SMALL LETTER K). Therefore, \u00c5\u00bf and \u00e2\u0084\u00aa can be matched by /[a-z]/ui.\nIf the regex is Unicode-unaware, case mapping uses the Unicode Default Case Conversion \u00e2\u0080\u0094 the same algorithm used in String.prototype.toUpperCase(). For example, \u00e2\u0084\u00a6 (U+2126 OHM SIGN) and \u00ce\u00a9 (U+03A9 GREEK CAPITAL LETTER OMEGA) are both mapped by Default Case Conversion to themselves but by simple case folding to \u00cf\u0089 (U+03C9 GREEK SMALL LETTER OMEGA), so \"\u00cf\u0089\" is matched by /[\\u2126]/ui and /[\\u03a9]/ui but not by /[\\u2126]/i or /[\\u03a9]/i. This algorithm prevents code points outside the Basic Latin block to be mapped to code points within it, so \u00c5\u00bf and \u00e2\u0084\u00aa mentioned previously are not matched by /[a-z]/i.\nThe set accessor of ignoreCase is undefined. You cannot change this property directly. ",
    "RegExp.lastMatch ($&)": "Because lastMatch is a static property of RegExp, you always use it as RegExp.lastMatch or RegExp[\"$&\"], rather than as a property of a RegExp object you created.\nThe value of lastMatch updates whenever a RegExp (but not a RegExp subclass) instance makes a successful match. If no matches have been made, lastMatch is an empty string. The set accessor of lastMatch is undefined, so you cannot change this property directly.\nYou cannot use the shorthand alias with the dot property accessor (RegExp.$&), because & is not a valid identifier part, so this causes a SyntaxError. Use the bracket notation instead.\n$& can also be used in the replacement string of String.prototype.replace(), but that's unrelated to the RegExp[\"$&\"] legacy property. ",
    "RegExp.prototype.exec()": "JavaScript RegExp objects are stateful when they have the global or sticky flags set (e.g. /foo/g or /foo/y). They store a lastIndex from the previous match. Using this internally, exec() can be used to iterate over multiple matches in a string of text (with capture groups), as opposed to getting just the matching strings with String.prototype.match().\nWhen using exec(), the global flag has no effect when the sticky flag is set \u00e2\u0080\u0094 the match is always sticky.\nexec() is the primitive method of regexps. Many other regexp methods call exec() internally \u00e2\u0080\u0094 including those called by string methods, like @@replace. While exec() itself is powerful (and is the most efficient), it often does not convey the intent most clearly.\n\nIf you only care whether the regex matches a string, but not what is actually being matched, use RegExp.prototype.test() instead.\nIf you are finding all occurrences of a global regex and you don't care about information like capturing groups, use String.prototype.match() instead. In addition, String.prototype.matchAll() helps to simplify matching multiple parts of a string (with capture groups) by allowing you to iterate over the matches.\nIf you are executing a match to find its index position in the string, use the String.prototype.search() method instead.\n ",
    "RegExp.lastParen ($+)": "Because lastParen is a static property of RegExp, you always use it as RegExp.lastParen or RegExp[\"$+\"], rather than as a property of a RegExp object you created.\nThe value of lastParen updates whenever a RegExp (but not a RegExp subclass) instance makes a successful match. If no matches have been made, or if the most recent regex execution contains no capturing groups, lastParen is an empty string. The set accessor of lastParen is undefined, so you cannot change this property directly.\nYou cannot use the shorthand alias with the dot property accessor (RegExp.$+), because + is not a valid identifier part, so this causes a SyntaxError. Use the bracket notation instead. ",
    "RegExp: lastIndex": "This property is set only if the regular expression instance used the g flag to indicate a global search, or the y flag to indicate a sticky search. The following rules apply when exec() is called on a given input:\n\nIf lastIndex is greater than the length of the input, exec() will not find a match, and lastIndex will be set to 0.\nIf lastIndex is equal to or less than the length of the input, exec() will attempt to match the input starting from lastIndex.\n    \nIf exec() finds a match, then lastIndex will be set to the position of the end of the matched string in the input.\nIf exec() does not find a match, then lastIndex will be set to 0.\n\n\n\nOther regex-related methods, such as RegExp.prototype.test(), String.prototype.match(), String.prototype.replace(), etc., call exec() under the hood, so they have different effects on lastIndex. See their respective pages for details. ",
    "RegExp.prototype.dotAll": "RegExp.prototype.dotAll has the value true if the s flag was used; otherwise, false. The s flag indicates that the dot special character (.) should additionally match the following line terminator (\"newline\") characters in a string, which it would not match otherwise:\n\nU+000A LINE FEED (LF) (\\n)\nU+000D CARRIAGE RETURN (CR) (\\r)\nU+2028 LINE SEPARATOR\nU+2029 PARAGRAPH SEPARATOR\n\nThis effectively means the dot will match any character on the Unicode Basic Multilingual Plane (BMP). To allow it to match astral characters, the u (unicode) flag should be used. Using both flags in conjunction allows the dot to match any Unicode character, without exceptions.\nThe set accessor of dotAll is undefined. You cannot change this property directly. ",
    "Array.prototype.pop()": "The pop() method removes the last element from an array and returns that value to the caller. If you call pop() on an empty array, it returns undefined.\nArray.prototype.shift() has similar behavior to pop(), but applied to the first element in an array.\nThe pop() method is a mutating method. It changes the length and the content of this. In case you want the value of this to be the same, but return a new array with the last element removed, you can use arr.slice(0, -1) instead.\nThe pop() method is generic. It only expects the this value to have a length property and integer-keyed properties. Although strings are also array-like, this method is not suitable to be applied on them, as strings are immutable. ",
    "Array.prototype.reduce()": "The reduce() method is an iterative method. It runs a \"reducer\" callback function over all elements in the array, in ascending-index order, and accumulates them into a single value. Every time, the return value of callbackFn is passed into callbackFn again on next invocation as accumulator. The final value of accumulator (which is the value returned from callbackFn on the final iteration of the array) becomes the return value of reduce(). Read the iterative methods section for more information about how these methods work in general.\ncallbackFn is invoked only for array indexes which have assigned values. It is not invoked for empty slots in sparse arrays.\nUnlike other iterative methods, reduce() does not accept a thisArg argument. callbackFn is always called with undefined as this, which gets substituted with globalThis if callbackFn is non-strict.\nreduce() is a central concept in functional programming, where it's not possible to mutate any value, so in order to accumulate all values in an array, one must return a new accumulator value on every iteration. This convention propagates to JavaScript's reduce(): you should use spreading or other copying methods where possible to create new arrays and objects as the accumulator, rather than mutating the existing one. If you decided to mutate the accumulator instead of copying it, remember to still return the modified object in the callback, or the next iteration will receive undefined. However, note that copying the accumulator may in turn lead to increased memory usage and degraded performance \u00e2\u0080\u0094 see When to not use reduce() for more details. In such cases, to avoid bad performance and unreadable code, it's better to use a simple for loop instead.\nThe reduce() method is generic. It only expects the this value to have a length property and integer-keyed properties. ",
    "Array.prototype.findLastIndex()": "The findLastIndex() method is an iterative method. It calls a provided callbackFn function once for each element in an array in descending-index order, until callbackFn returns a truthy value. findLastIndex() then returns the index of that element and stops iterating through the array. If callbackFn never returns a truthy value, findLastIndex() returns -1. Read the iterative methods section for more information about how these methods work in general.\ncallbackFn is invoked for every index of the array, not just those with assigned values. Empty slots in sparse arrays behave the same as undefined.\nThe findLastIndex() method is generic. It only expects the this value to have a length property and integer-keyed properties. ",
    "Array.prototype.sort()": "\n  If compareFn is not supplied, all non-undefined array\n  elements are sorted by converting them to strings and comparing strings in UTF-16 code\n  units order. For example, \"banana\" comes before \"cherry\". In a numeric sort, 9 comes\n  before 80, but because numbers are converted to strings, \"80\" comes before \"9\" in the\n  Unicode order. All undefined elements are sorted to the end of the array.\n\nThe sort() method preserves empty slots. If the source array is sparse, the empty slots are moved to the end of the array, and always come after all the undefined.\n\n\nNote: In UTF-16, Unicode characters above \\uFFFF are\n    encoded as two surrogate code units, of the range\n    \\uD800 - \\uDFFF. The value of each code unit is taken\n    separately into account for the comparison. Thus the character formed by the surrogate\n    pair \\uD855\\uDE51 will be sorted before the character\n    \\uFF3A.\n  \n\n\n  If compareFn is supplied, all non-undefined array\n  elements are sorted according to the return value of the compare function (all\n  undefined elements are sorted to the end of the array, with no call to\n  compareFn).\n\n\n\n\ncompareFn(a, b) return value\nsort order\n\n\n\n\n> 0\nsort a after b, e.g. [b, a]\n\n\n< 0\nsort a before b, e.g. [a, b]\n\n\n=== 0\nkeep original order of a and b\n\n\n\nSo, the compare function has the following form:\njsfunction compareFn(a, b) {\n  if (a is less than b by some ordering criterion) {\n    return -1;\n  } else if (a is greater than b by the ordering criterion) {\n    return 1;\n  }\n  // a must be equal to b\n  return 0;\n}\n\nMore formally, the comparator is expected to have the following properties, in order to ensure proper sort behavior:\n\nPure: The comparator does not mutate the objects being compared or any external state. (This is important because there's no guarantee when and how the comparator will be called, so any particular call should not produce visible effects to the outside.)\nStable: The comparator returns the same result with the same pair of input.\nReflexive: compareFn(a, a) === 0.\nAnti-symmetric: compareFn(a, b) and compareFn(b, a) must both be 0 or have opposite signs.\nTransitive: If compareFn(a, b) and compareFn(b, c) are both positive, zero, or negative, then compareFn(a, c) has the same positivity as the previous two.\n\nA comparator conforming to the constraints above will always be able to return all of 1, 0, and -1, or consistently return 0. For example, if a comparator only returns 1 and 0, or only returns 0 and -1, it will not be able to sort reliably because anti-symmetry is broken. A comparator that always returns 0 will cause the array to not be changed at all, but is reliable nonetheless.\nThe default lexicographic comparator satisfies all constraints above.\n\n  To compare numbers instead of strings, the compare function can subtract b\n  from a. The following function will sort the array in ascending order (if\n  it doesn't contain NaN):\n\njsfunction compareNumbers(a, b) {\n  return a - b;\n}\n\nThe sort() method is generic. It only expects the this value to have a length property and integer-keyed properties. Although strings are also array-like, this method is not suitable to be applied on them, as strings are immutable. ",
    "Array.isArray()": "Array.isArray() checks if the passed value is an Array. It does not check the value's prototype chain, nor does it rely on the Array constructor it is attached to. It returns true for any value that was created using the array literal syntax or the Array constructor. This makes it safe to use with cross-realm objects, where the identity of the Array constructor is different and would therefore cause instanceof Array to fail.\nSee the article \"Determining with absolute accuracy whether or not a JavaScript object is an array\" for more details.\nArray.isArray() also rejects objects with Array.prototype in its prototype chain but aren't actual arrays, which instanceof Array would accept. ",
    "Array.prototype.concat()": "The concat method creates a new array. The array will first be populated by the elements in the object on which it is called. Then, for each argument, its value will be concatenated into the array \u00e2\u0080\u0094 for normal objects or primitives, the argument itself will become an element of the final array; for arrays or array-like objects with the property Symbol.isConcatSpreadable set to a truthy value, each element of the argument will be independently added to the final array. The concat method does not recurse into nested array arguments.\nThe concat() method is a copying method. It does not alter this or any of the arrays provided as arguments but instead returns a shallow copy that contains the same elements as the ones from the original arrays.\nThe concat() method preserves empty slots if any of the source arrays is sparse.\nThe concat() method is generic. The this value is treated in the same way as the other arguments (except it will be converted to an object first), which means plain objects will be directly prepended to the resulting array, while array-like objects with truthy @@isConcatSpreadable will be spread into the resulting array. ",
    "Array.prototype.lastIndexOf()": "The lastIndexOf() method compares searchElement to elements of the array using strict equality (the same algorithm used by the === operator). NaN values are never compared as equal, so lastIndexOf() always returns -1 when searchElement is NaN.\nThe lastIndexOf() method skips empty slots in sparse arrays.\nThe lastIndexOf() method is generic. It only expects the this value to have a length property and integer-keyed properties. ",
    "Array.prototype.shift()": "\n  The shift() method removes the element at the zeroth index and shifts the\n  values at consecutive indexes down, then returns the removed value. If the\n  length property is 0, undefined is returned.\n\nThe pop() method has similar behavior to shift(), but applied to the last element in an array.\nThe shift() method is a mutating method. It changes the length and the content of this. In case you want the value of this to be the same, but return a new array with the first element removed, you can use arr.slice(1) instead.\nThe shift() method is generic. It only expects the this value to have a length property and integer-keyed properties. Although strings are also array-like, this method is not suitable to be applied on them, as strings are immutable. ",
    "Array.prototype.copyWithin()": "The copyWithin() method works like C and C++'s memmove, and is a high-performance method to shift the data of an Array. This especially applies to the TypedArray method of the same name. The sequence is copied and pasted as one operation; the pasted sequence will have the copied values even when the copy and paste region overlap.\nBecause undefined becomes 0 when converted to an integer, omitting the start parameter has the same effect as passing 0, which copies the entire array to the target position, equivalent to a right shift where the right boundary is clipped off and the left boundary is duplicated. This behavior may confuse readers of your code, so you should explicitly pass 0 as start instead.\njsconsole.log([1, 2, 3, 4, 5].copyWithin(2));\n// [1, 2, 1, 2, 3]; move all elements to the right by 2 positions\n\nThe copyWithin() method is a mutating method. It does not alter the length of this, but it will change the content of this and create new properties or delete existing properties, if necessary.\nThe copyWithin() method preserves empty slots. If the region to be copied from is sparse, the empty slots' corresponding new indices are deleted and also become empty slots.\nThe copyWithin() method is generic. It only expects the this value to have a length property and integer-keyed properties. Although strings are also array-like, this method is not suitable to be applied on them, as strings are immutable. ",
    "Array.prototype.forEach()": "The forEach() method is an iterative method. It calls a provided callbackFn function once for each element in an array in ascending-index order. Unlike map(), forEach() always returns undefined and is not chainable. The typical use case is to execute side effects at the end of a chain. Read the iterative methods section for more information about how these methods work in general.\ncallbackFn is invoked only for array indexes which have assigned values. It is not invoked for empty slots in sparse arrays.\nThe forEach() method is generic. It only expects the this value to have a length property and integer-keyed properties.\nThere is no way to stop or break a forEach() loop other than by throwing an exception. If you need such behavior, the forEach() method is the wrong tool.\nEarly termination may be accomplished with looping statements like for, for...of, and for...in. Array methods like every(), some(), find(), and findIndex() also stops iteration immediately when further iteration is not necessary.\nforEach() expects a synchronous function \u00e2\u0080\u0094 it does not wait for promises. Make sure you are aware of the implications while using promises (or async functions) as forEach callbacks.\njsconst ratings = [5, 4, 5];\nlet sum = 0;\n\nconst sumFunction = async (a, b) => a + b;\n\nratings.forEach(async (rating) => {\n  sum = await sumFunction(sum, rating);\n});\n\nconsole.log(sum);\n// Naively expected output: 14\n// Actual output: 0\n\nTo run a series of asynchronous operations sequentially or concurrently, see promise composition. ",
    "Array.prototype.flatMap()": "The flatMap() method is an iterative method. See Array.prototype.map() for a detailed description of the callback function. The flatMap() method is identical to map(callbackFn, thisArg) followed by flat(1) \u00e2\u0080\u0094 for each element, it produces an array of new elements, and concatenates the resulting arrays together to form a new array. Read the iterative methods section for more information about how these methods work in general.\nThe flatMap() method is generic. It only expects the this value to have a length property and integer-keyed properties. However, the value returned from callbackFn must be an array if it is to be flattened. ",
    "Array.prototype.splice()": "The splice() method is a mutating method. It may change the content of this. If the specified number of elements to insert differs from the number of elements being removed, the array's length will be changed as well. At the same time, it uses @@species to create a new array instance to be returned.\nIf the deleted portion is sparse, the array returned by splice() is sparse as well, with those corresponding indices being empty slots.\nThe splice() method is generic. It only expects the this value to have a length property and integer-keyed properties. Although strings are also array-like, this method is not suitable to be applied on them, as strings are immutable. ",
    "Array.prototype.at()": "The at() method is equivalent to the bracket notation when index is non-negative. For example, array[0] and array.at(0) both return the first item. However, when counting elements from the end of the array, you cannot use array[-1] like you may in Python or R, because all values inside the square brackets are treated literally as string properties, so you will end up reading array[\"-1\"], which is just a normal string property instead of an array index.\nThe usual practice is to access length and calculate the index from that \u00e2\u0080\u0094 for example, array[array.length - 1]. The at() method allows relative indexing, so this can be shortened to array.at(-1).\nBy combining at() with with(), you can both read and write (respectively) an array using negative indices.\nThe at() method is generic. It only expects the this value to have a length property and integer-keyed properties. ",
    "Array.prototype.join()": "The string conversions of all array elements are joined into one string. If an element is undefined or null, it is converted to an empty string instead of the string \"null\" or \"undefined\".\nThe join method is accessed internally by Array.prototype.toString() with no arguments. Overriding join of an array instance will override its toString behavior as well.\nArray.prototype.join recursively converts each element, including other arrays, to strings. Because the string returned by Array.prototype.toString (which is the same as calling join()) does not have delimiters, nested arrays look like they are flattened. You can only control the separator of the first level, while deeper levels always use the default comma.\njsconst matrix = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9],\n];\n\nconsole.log(matrix.join()); // 1,2,3,4,5,6,7,8,9\nconsole.log(matrix.join(\";\")); // 1,2,3;4,5,6;7,8,9\n\nWhen an array is cyclic (it contains an element that is itself), browsers avoid infinite recursion by ignoring the cyclic reference.\njsconst arr = [];\narr.push(1, [3, arr, 4], 2);\nconsole.log(arr.join(\";\")); // 1;3,,4;2\n\nWhen used on sparse arrays, the join() method iterates empty slots as if they have the value undefined.\nThe join() method is generic. It only expects the this value to have a length property and integer-keyed properties. ",
    "Array.prototype.reduceRight()": "The reduceRight() method is an iterative method. It runs a \"reducer\" callback function over all elements in the array, in descending-index order, and accumulates them into a single value. Read the iterative methods section for more information about how these methods work in general.\ncallbackFn is invoked only for array indexes which have assigned values. It is not invoked for empty slots in sparse arrays.\nUnlike other iterative methods, reduceRight() does not accept a thisArg argument. callbackFn is always called with undefined as this, which gets substituted with globalThis if callbackFn is non-strict.\nThe reduceRight() method is generic. It only expects the this value to have a length property and integer-keyed properties.\nAll caveats about reduce discussed in when not to use reduce() apply to reduceRight as well. Because JavaScript has no lazy evaluation semantics, there is no performance difference between reduce and reduceRight. ",
    "Array.prototype.push()": "The push() method appends values to an array.\nArray.prototype.unshift() has similar behavior to push(), but applied to the start of an array.\nThe push() method is a mutating method. It changes the length and the content of this. In case you want the value of this to be the same, but return a new array with elements appended to the end, you can use arr.concat([element0, element1, /* ... ,*/ elementN]) instead. Notice that the elements are wrapped in an extra array \u00e2\u0080\u0094 otherwise, if the element is an array itself, it would be spread instead of pushed as a single element due to the behavior of concat().\nThe push() method is generic. It only expects the this value to have a length property and integer-keyed properties. Although strings are also array-like, this method is not suitable to be applied on them, as strings are immutable. ",
    "Array.of()": "The difference between Array.of() and the Array() constructor is in the handling of single arguments: Array.of(7) creates an array with a single element, 7, whereas Array(7) creates an empty array with a length property of 7. (That implies an array of 7 empty slots, not slots with actual undefined values.)\njsArray.of(7); // [7]\nArray(7); // array of 7 empty slots\n\nArray.of(1, 2, 3); // [1, 2, 3]\nArray(1, 2, 3); // [1, 2, 3]\n\nThe Array.of() method is a generic factory method. For example, if a subclass of Array inherits the of() method, the inherited of() method will return new instances of the subclass instead of Array instances. In fact, the this value can be any constructor function that accepts a single argument representing the length of the new array, and the constructor will be called with the number of arguments passed to of(). The final length will be set again when all elements are assigned. If the this value is not a constructor function, the plain Array constructor is used instead. ",
    "Array.prototype.toLocaleString()": "The Array.prototype.toLocaleString method traverses its content, calling the toLocaleString method of every element with the locales and options parameters provided, and concatenates them with an implementation-defined separator (such as a comma \",\"). Note that the method itself does not consume the two parameters \u00e2\u0080\u0094 it only passes them to the toLocaleString() of each element. The choice of the separator string depends on the host's current locale, not the locales parameter.\nIf an element is undefined, null, it is converted to an empty string instead of the string \"null\" or \"undefined\".\nWhen used on sparse arrays, the toLocaleString() method iterates empty slots as if they have the value undefined.\nThe toLocaleString() method is generic. It only expects the this value to have a length property and integer-keyed properties. ",
    "Array.prototype.find()": "The find() method is an iterative method. It calls a provided callbackFn function once for each element in an array in ascending-index order, until callbackFn returns a truthy value. find() then returns that element and stops iterating through the array. If callbackFn never returns a truthy value, find() returns undefined. Read the iterative methods section for more information about how these methods work in general.\ncallbackFn is invoked for every index of the array, not just those with assigned values. Empty slots in sparse arrays behave the same as undefined.\nThe find() method is generic. It only expects the this value to have a length property and integer-keyed properties. ",
    "Array.prototype.toSpliced()": "The toSpliced() method, like splice(), does multiple things at once: it removes the given number of elements from the array, starting at a given index, and then inserts the given elements at the same index. However, it returns a new array instead of modifying the original array. The deleted elements therefore are not returned from this method.\nThe toSpliced() method never produces a sparse array. If the source array is sparse, the empty slots will be replaced with undefined in the new array.\nThe toSpliced() method is generic. It only expects the this value to have a length property and integer-keyed properties. ",
    "Array.prototype.slice()": "The slice() method is a copying method. It does not alter this but instead returns a shallow copy that contains some of the same elements as the ones from the original array.\nThe slice() method preserves empty slots. If the sliced portion is sparse, the returned array is sparse as well.\nThe slice() method is generic. It only expects the this value to have a length property and integer-keyed properties. ",
    "ArrayBuffer": "The ArrayBuffer object is used to represent a generic raw binary data buffer.It is an array of bytes, often referred to in other languages as a byte array. You cannot directly manipulate the contents of an ArrayBuffer; instead, you create one of the typed array objects or a DataView object which represents the buffer in a specific format, and use that to read and write the contents of the buffer.The ArrayBuffer() constructor creates a new ArrayBuffer of the given length in bytes. You can also get an array buffer from existing data, for example, from a Base64 string or from a local file.ArrayBuffer is a transferable object.",
    "Array.prototype.findIndex()": "The findIndex() is an iterative method. It calls a provided callbackFn function once for each element in an array in ascending-index order, until callbackFn returns a truthy value. findIndex() then returns the index of that element and stops iterating through the array. If callbackFn never returns a truthy value, findIndex() returns -1. Read the iterative methods section for more information about how these methods work in general.\ncallbackFn is invoked for every index of the array, not just those with assigned values. Empty slots in sparse arrays behave the same as undefined.\nThe findIndex() method is generic. It only expects the this value to have a length property and integer-keyed properties. ",
    "Array.prototype.map()": "The map() method is an iterative method. It calls a provided callbackFn function once for each element in an array and constructs a new array from the results. Read the iterative methods section for more information about how these methods work in general.\ncallbackFn is invoked only for array indexes which have assigned values. It is not invoked for empty slots in sparse arrays.\nThe map() method is generic. It only expects the this value to have a length property and integer-keyed properties.\nSince map builds a new array, calling it without using the returned array is an anti-pattern; use forEach or for...of instead. ",
    "Array.prototype.toString()": "The Array object overrides the toString method of Object. The toString method of arrays calls join() internally, which joins the array and returns one string containing each array element separated by commas. If the join method is unavailable or is not a function, Object.prototype.toString is used instead, returning [object Array].\njsconst arr = [];\narr.join = 1; // re-assign `join` with a non-function\nconsole.log(arr.toString()); // [object Array]\n\nconsole.log(Array.prototype.toString.call({ join: () => 1 })); // 1\n\nJavaScript calls the toString method automatically when an array is to be represented as a text value or when an array is referred to in a string concatenation.\nArray.prototype.toString recursively converts each element, including other arrays, to strings. Because the string returned by Array.prototype.toString does not have delimiters, nested arrays look like they are flattened.\njsconst matrix = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9],\n];\n\nconsole.log(matrix.toString()); // 1,2,3,4,5,6,7,8,9\n\nWhen an array is cyclic (it contains an element that is itself), browsers avoid infinite recursion by ignoring the cyclic reference.\njsconst arr = [];\narr.push(1, [3, arr, 4], 2);\nconsole.log(arr.toString()); // 1,3,,4,2\n ",
    "Array.prototype.every()": "The every() method is an iterative method. It calls a provided callbackFn function once for each element in an array, until the callbackFn returns a falsy value. If such an element is found, every() immediately returns false and stops iterating through the array. Otherwise, if callbackFn returns a truthy value for all elements, every() returns true. Read the iterative methods section for more information about how these methods work in general.\nevery acts like the \"for all\" quantifier in mathematics. In particular, for an empty array, it returns true. (It is vacuously true that all elements of the empty set satisfy any given condition.)\ncallbackFn is invoked only for array indexes which have assigned values. It is not invoked for empty slots in sparse arrays.\nThe every() method is generic. It only expects the this value to have a length property and integer-keyed properties. ",
    "Array.prototype.values()": "Array.prototype.values() is the default implementation of Array.prototype[@@iterator]().\njsArray.prototype.values === Array.prototype[Symbol.iterator]; // true\n\nWhen used on sparse arrays, the values() method iterates empty slots as if they have the value undefined.\nThe values() method is generic. It only expects the this value to have a length property and integer-keyed properties. ",
    "Array.prototype.flat()": "The flat() method is a copying method. It does not alter this but instead returns a shallow copy that contains the same elements as the ones from the original array.\nThe flat() method ignores empty slots if the array being flattened is sparse. For example, if depth is 1, both empty slots in the root array and in the first level of nested arrays are ignored, but empty slots in further nested arrays are preserved with the arrays themselves.\nThe flat() method is generic. It only expects the this value to have a length property and integer-keyed properties. However, its elements must be arrays if they are to be flattened. ",
    "Array.prototype.reverse()": "\n  The reverse() method transposes the elements of the calling array object in\n  place, mutating the array, and returning a reference to the array.\n\nThe reverse() method preserves empty slots. If the source array is sparse, the empty slots' corresponding new indices are deleted and also become empty slots.\nThe reverse() method is generic. It only expects the this value to have a length property and integer-keyed properties. Although strings are also array-like, this method is not suitable to be applied on them, as strings are immutable. ",
    "Array() constructor": "The Array() constructor creates Array objects. ",
    "Array[@@species]": "The @@species accessor property returns the default constructor for Array objects. Subclass constructors may override it to change the constructor assignment. The default implementation is basically:\njs// Hypothetical underlying implementation for illustration\nclass Array {\n  static get [Symbol.species]() {\n    return this;\n  }\n}\n\nBecause of this polymorphic implementation, @@species of derived subclasses would also return the constructor itself by default.\njsclass SubArray extends Array {}\nSubArray[Symbol.species] === SubArray; // true\n\nWhen calling array methods that do not mutate the existing array but return a new array instance (for example, filter() and map()), the array's constructor[@@species] will be accessed. The returned constructor will be used to construct the return value of the array method. This makes it technically possible to make array methods return objects unrelated to arrays.\njsclass NotAnArray {\n  constructor(length) {\n    this.length = length;\n  }\n}\n\nconst arr = [0, 1, 2];\narr.constructor = { [Symbol.species]: NotAnArray };\narr.map((i) => i); // NotAnArray { '0': 0, '1': 1, '2': 2, length: 3 }\narr.filter((i) => i); // NotAnArray { '0': 1, '1': 2, length: 0 }\narr.concat([1, 2]); // NotAnArray { '0': 0, '1': 1, '2': 2, '3': 1, '4': 2, length: 5 }\n ",
    "Array.prototype.some()": "The some() method is an iterative method. It calls a provided callbackFn function once for each element in an array, until the callbackFn returns a truthy value. If such an element is found, some() immediately returns true and stops iterating through the array. Otherwise, if callbackFn returns a falsy value for all elements, some() returns false. Read the iterative methods section for more information about how these methods work in general.\nsome() acts like the \"there exists\" quantifier in mathematics. In particular, for an empty array, it returns false for any condition.\ncallbackFn is invoked only for array indexes which have assigned values. It is not invoked for empty slots in sparse arrays.\nsome() does not mutate the array on which it is called, but the function provided as callbackFn can. Note, however, that the length of the array is saved before the first invocation of callbackFn. Therefore:\n\ncallbackFn will not visit any elements added beyond the array's initial length when the call to some() began.\nChanges to already-visited indexes do not cause callbackFn to be invoked on them again.\nIf an existing, yet-unvisited element of the array is changed by callbackFn, its value passed to the callbackFn will be the value at the time that element gets visited. Deleted elements are not visited.\n\n\nWarning: Concurrent modifications of the kind described above frequently lead to hard-to-understand code and are generally to be avoided (except in special cases).\n\nThe some() method is generic. It only expects the this value to have a length property and integer-keyed properties. ",
    "Array.prototype.indexOf()": "The indexOf() method compares searchElement to elements of the array using strict equality (the same algorithm used by the === operator). NaN values are never compared as equal, so indexOf() always returns -1 when searchElement is NaN.\nThe indexOf() method skips empty slots in sparse arrays.\nThe indexOf() method is generic. It only expects the this value to have a length property and integer-keyed properties. ",
    "Array.prototype.toSorted()": "See sort() for more information on the compareFn parameter.\nWhen used on sparse arrays, the toSorted() method iterates empty slots as if they have the value undefined.\nThe toSorted() method is generic. It only expects the this value to have a length property and integer-keyed properties. ",
    "Array.prototype.unshift()": "\n  The unshift() method inserts the given values to the beginning of an\n  array-like object.\n\nArray.prototype.push() has similar behavior to unshift(), but applied to the end of an array.\n\n  Please note that, if multiple elements are passed as parameters, they're inserted in\n  chunk at the beginning of the object, in the exact same order they were passed as\n  parameters. Hence, calling unshift() with n\n  arguments once, or calling it n times with\n  1 argument (with a loop, for example), don't yield the same results.\n\nSee example:\njslet arr = [4, 5, 6];\n\narr.unshift(1, 2, 3);\nconsole.log(arr);\n// [1, 2, 3, 4, 5, 6]\n\narr = [4, 5, 6]; // resetting the array\n\narr.unshift(1);\narr.unshift(2);\narr.unshift(3);\n\nconsole.log(arr);\n// [3, 2, 1, 4, 5, 6]\n\nThe unshift() method is generic. It only expects the this value to have a length property and integer-keyed properties. Although strings are also array-like, this method is not suitable to be applied on them, as strings are immutable. ",
    "Array.prototype.fill()": "The fill() method is a mutating method. It does not alter the length of this, but it will change the content of this.\nThe fill() method fills empty slots in sparse arrays with value as well.\nThe fill() method is generic. It only expects the this value to have a length property. Although strings are also array-like, this method is not suitable to be applied on them, as strings are immutable.\n\n\nNote: Using Array.prototype.fill() on an empty array (length = 0) would not modify it as the array has nothing to be modified.\n    To use Array.prototype.fill() when declaring an array, make sure the array has non-zero length.\n    See example.\n  \n ",
    "Array.fromAsync()": "Array.fromAsync() lets you create arrays from:\n\nasync iterable objects (objects such as ReadableStream and AsyncGenerator); or, if the object is not async iterable,\niterable objects (objects such as Map and Set); or, if the object is not iterable,\narray-like objects (objects with a length property and indexed elements).\n\nArray.fromAsync() iterates the async iterable in a fashion very similar to for await...of. Array.fromAsync() is almost equivalent to Array.from() in terms of behavior, except the following:\n\nArray.fromAsync() handles async iterable objects.\nArray.fromAsync() returns a Promise that fulfills to the array instance.\nIf Array.fromAsync() is called with a non-async iterable object, each element to be added to the array is first awaited.\nIf a mapFn is provided, its input and output are internally awaited.\n\nArray.fromAsync() and Promise.all() can both turn an iterable of promises into a promise of an array. However, there are two key differences:\n\nArray.fromAsync() awaits each value yielded from the object sequentially. Promise.all() awaits all values concurrently.\nArray.fromAsync() iterates the iterable lazily, and doesn't retrieve the next value until the current one is settled. Promise.all() retrieves all values in advance and awaits them all.\n ",
    "Array.prototype.entries()": "When used on sparse arrays, the entries() method iterates empty slots as if they have the value undefined.\nThe entries() method is generic. It only expects the this value to have a length property and integer-keyed properties. ",
    "Array.prototype.findLast()": "The findLast() method is an iterative method. It calls a provided callbackFn function once for each element in an array in descending-index order, until callbackFn returns a truthy value. findLast() then returns that element and stops iterating through the array. If callbackFn never returns a truthy value, findLast() returns undefined. Read the iterative methods section for more information about how these methods work in general.\ncallbackFn is invoked for every index of the array, not just those with assigned values. Empty slots in sparse arrays behave the same as undefined.\nThe findLast() method is generic. It only expects the this value to have a length property and integer-keyed properties. ",
    "Array.prototype.keys()": "When used on sparse arrays, the keys() method iterates empty slots as if they have the value undefined.\nThe keys() method is generic. It only expects the this value to have a length property and integer-keyed properties. ",
    "Array.from()": "Array.from() lets you create Arrays from:\n\niterable objects (objects such as Map and Set); or, if the object is not iterable,\narray-like objects (objects with a length property and indexed elements).\n\nTo convert an ordinary object that's not iterable or array-like to an array (by enumerating its property keys, values, or both), use Object.keys(), Object.values(), or Object.entries(). To convert an async iterable to an array, use Array.fromAsync().\nArray.from() never creates a sparse array. If the arrayLike object is missing some index properties, they become undefined in the new array.\nArray.from() has an optional parameter mapFn, which allows you to execute a function on each element of the array being created, similar to map(). More clearly, Array.from(obj, mapFn, thisArg) has the same result as Array.from(obj).map(mapFn, thisArg), except that it does not create an intermediate array, and mapFn only receives two arguments (element, index) without the whole array, because the array is still under construction.\n\nNote: This behavior is more important for typed arrays, since the intermediate array would necessarily have values truncated to fit into the appropriate type. Array.from() is implemented to have the same signature as TypedArray.from().\n\nThe Array.from() method is a generic factory method. For example, if a subclass of Array inherits the from() method, the inherited from() method will return new instances of the subclass instead of Array instances. In fact, the this value can be any constructor function that accepts a single argument representing the length of the new array. When an iterable is passed as arrayLike, the constructor is called with no arguments; when an array-like object is passed, the constructor is called with the normalized length of the array-like object. The final length will be set again when iteration finishes. If the this value is not a constructor function, the plain Array constructor is used instead. ",
    "Array.prototype.toReversed()": "The toReversed() method transposes the elements of the calling array object in reverse order and returns a new array.\nWhen used on sparse arrays, the toReversed() method iterates empty slots as if they have the value undefined.\nThe toReversed() method is generic. It only expects the this value to have a length property and integer-keyed properties. ",
    "Array: length": "The value of the length property is a nonnegative integer with a value less than 232.\njsconst listA = [1, 2, 3];\nconst listB = new Array(6);\n\nconsole.log(listA.length);\n// 3\n\nconsole.log(listB.length);\n// 6\n\nlistB.length = 2 ** 32; // 4294967296\n// RangeError: Invalid array length\n\nconst listC = new Array(-100); // Negative numbers are not allowed\n// RangeError: Invalid array length\n\nThe array object observes the length property, and automatically syncs the length value with the array's content. This means:\n\nSetting length to a value smaller than the current length truncates the array \u00e2\u0080\u0094 elements beyond the new length are deleted.\nSetting any array index (a nonnegative integer smaller than 232) beyond the current length extends the array \u00e2\u0080\u0094 the length property is increased to reflect the new highest index.\nSetting length to an invalid value (e.g. a negative number or a non-integer) throws a RangeError exception.\n\nWhen length is set to a bigger value than the current length, the array is extended by adding empty slots, not actual undefined values. Empty slots have some special interactions with array methods; see array methods and empty slots.\njsconst arr = [1, 2];\nconsole.log(arr);\n// [ 1, 2 ]\n\narr.length = 5; // set array length to 5 while currently 2.\nconsole.log(arr);\n// [ 1, 2, <3 empty items> ]\n\narr.forEach((element) => console.log(element));\n// 1\n// 2\n\nSee also Relationship between length and numerical properties. ",
    "Array.prototype[@@iterator]()": "The [@@iterator]() method of Array instances implements the iterable protocol and allows arrays to be consumed by most syntaxes expecting iterables, such as the spread syntax and for...of loops. It returns an array iterator object that yields the value of each index in the array. \n The initial value of this property is the same function object as the initial value of the Array.prototype.values property. ",
    "Array.prototype[@@unscopables]": "The default Array properties that are ignored for with statement-binding purposes are:\n\nat()\ncopyWithin()\nentries()\nfill()\nfind()\nfindIndex()\nfindLast()\nfindLastIndex()\nflat()\nflatMap()\nincludes()\nkeys()\ntoReversed()\ntoSorted()\ntoSpliced()\nvalues()\n\nArray.prototype[@@unscopables] is an empty object only containing all the above property names with the value true. Its prototype is null, so Object.prototype properties like toString won't accidentally be made unscopable, and a toString() within the with statement will continue to be called on the array.\nSee Symbol.unscopables for how to set unscopable properties for your own objects. ",
    "Array.prototype.includes()": "The includes() method compares searchElement to elements of the array using the SameValueZero algorithm. Values of zero are all considered to be equal, regardless of sign. (That is, -0 is equal to 0), but false is not considered to be the same as 0. NaN can be correctly searched for.\nWhen used on sparse arrays, the includes() method iterates empty slots as if they have the value undefined.\nThe includes() method is generic. It only expects the this value to have a length property and integer-keyed properties. ",
    "Array.prototype.with()": "The with() method changes the value of a given index in the array, returning a new array with the element at the given index replaced with the given value. The original array is not modified. This allows you to chain array methods while doing manipulations.\nBy combining with() with at(), you can both write and read (respectively) an array using negative indices.\nThe with() method never produces a sparse array. If the source array is sparse, the empty slots will be replaced with undefined in the new array.\nThe with() method is generic. It only expects the this value to have a length property and integer-keyed properties. ",
    "Array.prototype.filter()": "The filter() method is an iterative method. It calls a provided callbackFn function once for each element in an array, and constructs a new array of all the values for which callbackFn returns a truthy value. Array elements which do not pass the callbackFn test are not included in the new array. Read the iterative methods section for more information about how these methods work in general.\ncallbackFn is invoked only for array indexes which have assigned values. It is not invoked for empty slots in sparse arrays.\nThe filter() method is generic. It only expects the this value to have a length property and integer-keyed properties. ",
    "Map.prototype.delete()": "\n  The delete() method of Map instances removes the specified element from this map by\n  key.\n ",
    "Map.prototype.clear()": "The clear() method of Map instances removes all elements from this map. ",
    "Map.prototype.size": "\n  The value of size is an integer representing how many entries the Map object\n  has. A set accessor function for size is undefined; you can not change this\n  property.\n ",
    "Map.prototype.forEach()": "\n  The forEach method executes the provided callback once for each key of the\n  map which actually exist. It is not invoked for keys which have been deleted.\n  However, it is executed for values which are present but have the value\n  undefined.\n\ncallback is invoked with three arguments:\n\nthe entry's value\nthe entry's key\nthe Map object being traversed\n\n\n  If a thisArg parameter is provided to forEach, it will be passed to\n  callback when invoked, for use as its this value. Otherwise, the value\n  undefined will be passed for use as its this value. The this value\n  ultimately observable by callback is determined according to\n  the usual rules for determining the this seen by a function.\n\n\n  Each value is visited once, except in the case when it was deleted and re-added\n  before forEach has finished. callback is not invoked for values deleted\n  before being visited. New values added before forEach has finished will be\n  visited.\n ",
    "Map.groupBy()": "Map.groupBy() calls a provided callbackFn function once for each element in an iterable. The callback function should return a value indicating the group of the associated element. The values returned by callbackFn are used as keys for the Map returned by Map.groupBy(). Each key has an associated array containing all the elements for which the callback returned the same value.\nThe elements in the returned Map and the original iterable are the same (not deep copies). Changing the internal structure of the elements will be reflected in both the original iterable and the returned Map.\nThis method is useful when you need to group information that is related to a particular object that might potentially change over time. This is because even if the object is modified, it will continue to work as a key to the returned Map. If you instead create a string representation for the object and use that as a grouping key in Object.groupBy(), you must maintain the mapping between the original object and its representation as the object changes.\n\nNote: To access the groups in the returned Map, you must use the same object that was originally used as a key in the Map (although you may modify its properties). You can't use another object that just happens to have the same name and properties.\n\nMap.groupBy does not read the value of this. It can be called on any object and a new Map instance will be returned. ",
    "Map.prototype.get()": "\n  The get() method of Map instances returns a specified element from this map. If the\n  value that is associated to the provided key is an object, then you will get a\n  reference to that object and any change made to that object will effectively\n  modify it inside the Map object.\n ",
    "Map.prototype.keys()": "The keys() method of Map instances returns a new map iterator object that contains the keys for each element in this map in insertion order. ",
    "Map.prototype.has()": "\n  The has() method of Map instances returns a boolean indicating whether an element with the\n  specified key exists in this map or not.\n ",
    "Map.prototype.values()": "The values() method of Map instances returns a new map iterator object that contains the values for each element in this map in insertion order. ",
    "Map.prototype.entries()": "The entries() method of Map instances returns a new map iterator object that contains the [key, value] pairs for each element in this map in insertion order. ",
    "Map.prototype.set()": "The set() method of Map instances adds or updates an entry in this map with a specified key and a value. ",
    "Map[@@species]": "The @@species accessor property returns the default constructor for Map objects. Subclass constructors may override it to change the constructor assignment.\n\nNote: This property is currently unused by all Map methods.\n ",
    "Map.prototype[@@iterator]()": "The [@@iterator]() method of Map instances implements the iterable protocol and allows Map objects to be consumed by most syntaxes expecting iterables, such as the spread syntax and for...of loops. It returns a map iterator object that yields the key-value pairs of the map in insertion order. \n The initial value of this property is the same function object as the initial value of the Map.prototype.entries property. ",
    "Map() constructor": "The Map() constructor creates Map objects. ",
    "Set.prototype.add()": "The add() method of Set instances inserts a new element with a specified value in to this set, if there isn't an element with the same value already in this set ",
    "Set.prototype.clear()": "The clear() method of Set instances removes all elements from this set. ",
    "Set.prototype.isDisjointFrom()": "Two sets are disjoint if they have no elements in common. In mathematical notation:\n\n\n\n\nA\n\u00a0is disjoint from\u00a0\nB\n\u00e2\u0087\u0094\nA\n\u00e2\u0088\u00a9\nB\n=\n\u00e2\u0088\u0085\n\nA\\text{ is disjoint from }B \\Leftrightarrow A\\cap B = \\empty\n\n\n\nAnd using Venn diagram:\n\n\n\nisDisjointFrom() accepts set-like objects as the other parameter. It requires this to be an actual Set instance, because it directly retrieves the underlying data stored in this without invoking any user code. Then, its behavior depends on the sizes of this and other:\n\nIf there are more elements in this than other.size, then it iterates over other by calling its keys() method, and if any element in other is present in this, it returns false (and closes the keys() iterator by calling its return() method). Otherwise, it returns true.\nOtherwise, it iterates over the elements in this, and returns false if any element e in this causes other.has(e) to return a truthy value. Otherwise, it returns true.\n\nBecause of this implementation, the efficiency of isDisjointFrom() mostly depends on the size of the smaller set between this and other (assuming sets can be accessed in sublinear time). ",
    "Set.prototype.delete()": "The delete() method of Set instances removes a specified value from this set, if it is in the set. ",
    "Set.prototype.isSubsetOf()": "In mathematical notation, subset is defined as:\n\n\n\n\nA\n\u00e2\u008a\u0086\nB\n\u00e2\u0087\u0094\n\u00e2\u0088\u0080\nx\n\u00e2\u0088\u008a\nA\n,\n\nx\n\u00e2\u0088\u008a\nB\n\nA\\subseteq B \\Leftrightarrow \\forall x\\in A,,x\\in B\n\n\n\nAnd using Venn diagram:\n\n\n\n\nNote: The subset relationship is not proper subset, which means isSubsetOf() returns true if this and other contain the same elements.\n\nisSubsetOf() accepts set-like objects as the other parameter. It requires this to be an actual Set instance, because it directly retrieves the underlying data stored in this without invoking any user code. Then, its behavior depends on the sizes of this and other:\n\nIf there are more elements in this than other.size, then it directly returns false.\nOtherwise, it iterates over the elements in this, and returns false if any element e in this causes other.has(e) to return a falsy value. Otherwise, it returns true.\n ",
    "Set[@@species]": "The @@species accessor property returns the default constructor for Set objects. Subclass constructors may override it to change the constructor assignment.\n\nNote: This property is currently unused by all Set methods.\n ",
    "Set.prototype[@@iterator]()": "The [@@iterator]() method of Set instances implements the iterable protocol and allows Set objects to be consumed by most syntaxes expecting iterables, such as the spread syntax and for...of loops. It returns a set iterator object that yields the values of the set in insertion order. \n The initial value of this property is the same function object as the initial value of the Set.prototype.values property. ",
    "Set.prototype.intersection()": "In mathematical notation, intersection is defined as:\n\n\n\n\nA\n\u00e2\u0088\u00a9\nB\n=\n{\nx\n\u00e2\u0088\u008a\nA\n\u00e2\u0088\u00a3\nx\n\u00e2\u0088\u008a\nB\n}\n\nA\\cap B = {x\\in A\\mid x\\in B}\n\n\n\nAnd using Venn diagram:\n\n\n\nintersection() accepts set-like objects as the other parameter. It requires this to be an actual Set instance, because it directly retrieves the underlying data stored in this without invoking any user code. Then, its behavior depends on the sizes of this and other:\n\nIf there are more elements in this than other.size, then it iterates over other by calling its keys() method, and constructs a new set with all elements produced that are also present in this.\nOtherwise, it iterates over the elements in this, and constructs a new set with all elements e in this that cause other.has(e) to return a truthy value.\n\nBecause of this implementation, the efficiency of intersection() mostly depends on the size of the smaller set between this and other (assuming sets can be accessed in sublinear time). The order of elements in the returned set is the same as that of the smaller of this and other. ",
    "Set.prototype.has()": "\n  The has() method of Set instances returns a boolean indicating whether an\n  element with the specified value exists in this set or not.\n ",
    "Set.prototype.keys()": "The keys() method of Set instances is an alias for the values() method. ",
    "Set.prototype.values()": "The values() method of Set instances returns a new set iterator object that contains the values for each element in this set in insertion order. ",
    "Set() constructor": "The Set() constructor creates Set objects. ",
    "Set.prototype.size": "The value of size is an integer representing how many entries the Set object has. A set accessor function for size is undefined; you cannot change this property. ",
    "Set.prototype.entries()": "The entries() method of Set instances returns a new set iterator object that contains an array of [value, value] for each element in this set, in insertion order. For Set objects there is no key like in Map objects. However, to keep the API similar to the Map object, each entry has the same value for its key and value here, so that an array [value, value] is returned. ",
    "Set.prototype.difference()": "In mathematical notation, difference is defined as:\n\n\n\n\nA\n\u00e2\u0088\u0096\nB\n=\n{\nx\n\u00e2\u0088\u008a\nA\n\u00e2\u0088\u00a3\nx\n\u00e2\u0088\u0089\nB\n}\n\nA\\setminus B = {x\\in A\\mid x\\notin B}\n\n\n\nAnd using Venn diagram:\n\n\n\ndifference() accepts set-like objects as the other parameter. It requires this to be an actual Set instance, because it directly retrieves the underlying data stored in this without invoking any user code. Then, its behavior depends on the sizes of this and other:\n\nIf there are more elements in this than other.size, then it iterates over other by calling its keys() method, and constructs a new set with all elements in this that are not seen in other.\nOtherwise, it iterates over the elements in this, and constructs a new set with all elements e in this that cause other.has(e) to return a falsy value.\n\nThe order of elements in the returned set is the same as in this. ",
    "Set.prototype.forEach()": "\n  The forEach() method executes the provided\n  callback once for each value which actually exists in the\n  Set object. It is not invoked for values which have been deleted. However,\n  it is executed for values which are present but have the value undefined.\n\ncallback is invoked with three arguments:\n\nthe element value\nthe element key\nthe Set object being traversed\n\n\n  There are no keys in Set objects, however, so the first two arguments are\n  both values contained in the Set. This is to make it\n  consistent with other forEach() methods for Map and Array.\n\n\n  If a thisArg parameter is provided to forEach(),\n  it will be passed to callback when invoked, for use as its\n  this value. Otherwise, the value undefined will be passed for\n  use as its this value. The this value ultimately observable by\n  callback is determined according to\n  the usual rules for determining the this seen by a function.\n\n\n  Each value is visited once, except in the case when it was deleted and re-added before\n  forEach() has finished. callback is not invoked for\n  values deleted before being visited. New values added before forEach() has\n  finished will be visited.\n\n\nforEach() executes the callback function once for\n  each element in the Set object; it does not return a value.\n ",
    "Set.prototype.symmetricDifference()": "In mathematical notation, symmetric difference is defined as:\n\n\n\n\nA\n\u00e2\u008a\u0096\nB\n=\n(\nA\n\u00e2\u0088\u0096\nB\n)\n\u00e2\u0088\u00aa\n(\nB\n\u00e2\u0088\u0096\nA\n)\n\nA\\ominus B = (A\\setminus B)\\cup(B\\setminus A)\n\n\n\nAnd using Venn diagram:\n\n\n\nsymmetricDifference() accepts set-like objects as the other parameter. It requires this to be an actual Set instance, because it directly retrieves the underlying data stored in this without invoking any user code. Then, it iterates over other by calling its keys() method, and constructs a new set with all elements in this that are not seen in other, and all elements in other that are not seen in this.\nThe order of elements in the returned set is first those in this followed by those in other. ",
    "Set.prototype.union()": "In mathematical notation, union is defined as:\n\n\n\n\nA\n\u00e2\u0088\u00aa\nB\n=\n{\nx\n\u00e2\u0088\u00a3\nx\n\u00e2\u0088\u008a\nA\n\u00a0or\u00a0\nx\n\u00e2\u0088\u008a\nB\n}\n\nA\\cup B = {x\\midx\\in A\\text{ or }x\\in B}\n\n\n\nAnd using Venn diagram:\n\n\n\nunion() accepts set-like objects as the other parameter. It requires this to be an actual Set instance, because it directly retrieves the underlying data stored in this without invoking any user code. Then, it iterates over other by calling its keys() method, and constructs a new set with all elements in this, followed by all elements in other that are not present in this.\nThe order of elements in the returned set is first those in this followed by those in other. ",
    "Set.prototype.isSupersetOf()": "In mathematical notation, superset is defined as:\n\n\n\n\nA\n\u00e2\u008a\u0087\nB\n\u00e2\u0087\u0094\n\u00e2\u0088\u0080\nx\n\u00e2\u0088\u008a\nB\n,\n\nx\n\u00e2\u0088\u008a\nA\n\nA\\supseteq B \\Leftrightarrow \\forall x\\in B,,x\\in A\n\n\n\nAnd using Venn diagram:\n\n\n\n\nNote: The superset relationship is not proper superset, which means isSupersetOf() returns true if this and other contain the same elements.\n\nisSupersetOf() accepts set-like objects as the other parameter. It requires this to be an actual Set instance, because it directly retrieves the underlying data stored in this without invoking any user code. Then, its behavior depends on the sizes of this and other:\n\nIf there are fewer elements in this than other.size, then it directly returns false.\nOtherwise, it iterates over other by calling its keys() method, and if any element in other is not present in this, it returns false (and closes the keys() iterator by calling its return() method). Otherwise, it returns true.\n ",
    "WeakMap.prototype.get()": "The get() method of WeakMap instances returns a specified element from this WeakMap. ",
    "WeakMap() constructor": "The WeakMap() constructor creates WeakMap objects. ",
    "WeakMap.prototype.has()": "\n  The has() method of WeakMap instances returns a boolean indicating whether an\n  element with the specified key exists in this WeakMap or not.\n ",
    "WeakMap.prototype.set()": "\n  The set() method of WeakMap instances adds a new element with a specified key\n  and value to this WeakMap.\n ",
    "WeakMap.prototype.delete()": "The delete() method of WeakMap instances removes the specified element from this WeakMap. ",
    "WeakSet.prototype.add()": "The add() method of WeakSet instances appends a new object to the end of this WeakSet. ",
    "WeakSet.prototype.delete()": "The delete() method of WeakSet instances removes the specified element from this WeakSet. ",
    "WeakSet() constructor": "The WeakSet() constructor creates WeakSet objects. ",
    "WeakSet.prototype.has()": "\n  The has() method of WeakSet instances returns a boolean indicating whether an\n  object exists in this WeakSet or not.\n ",
    "ArrayBuffer.prototype.byteLength": "The byteLength property is an accessor property whose set accessor function is undefined, meaning that you can only read this property. The value is established when the array is constructed and cannot be changed. This property returns 0 if this ArrayBuffer has been detached. ",
    "ArrayBuffer[@@species]": "The @@species accessor property returns the default constructor for ArrayBuffer objects. Subclass constructors may override it to change the constructor assignment. The default implementation is basically:\njs// Hypothetical underlying implementation for illustration\nclass ArrayBuffer {\n  static get [Symbol.species]() {\n    return this;\n  }\n}\n\nBecause of this polymorphic implementation, @@species of derived subclasses would also return the constructor itself by default.\njsclass SubArrayBuffer extends ArrayBuffer {}\nSubArrayBuffer[Symbol.species] === SubArrayBuffer; // true\n\nWhen calling array buffer methods that do not mutate the existing object but return a new array buffer instance (for example, slice()), the object's constructor[@@species] will be accessed. The returned constructor will be used to construct the return value of the array buffer method. ",
    "ArrayBuffer.prototype.transferToFixedLength()": "Unlike transfer(), transferToFixedLength() always creates a non-resizable ArrayBuffer. This means newByteLength can be larger than the maxByteLength, even if this ArrayBuffer is resizable. See transferring ArrayBuffers for more information. ",
    "ArrayBuffer.prototype.slice()": "The slice() method of ArrayBuffer instances returns a new ArrayBuffer whose contents are a copy of this ArrayBuffer's bytes from start, inclusive, up to end, exclusive. If either start or end is negative, it refers to an index from the end of the array, as opposed to from the beginning. ",
    "ArrayBuffer.isView()": "\n  The ArrayBuffer.isView() static method determines whether the\n  passed value is one of the ArrayBuffer views,\n  such as typed array objects\n  or a DataView.\n ",
    "ArrayBuffer.prototype.detached": "The detached property is an accessor property whose set accessor function is undefined, meaning that you can only read this property. The value is false when the ArrayBuffer is first created. The value becomes true if the ArrayBuffer is transferred, which detaches the instance from its underlying memory. Once a buffer becomes detached, it is no longer usable. ",
    "ArrayBuffer.prototype.resizable": "The resizable property is an accessor property whose set accessor function is undefined, meaning that you can only read this property. The value is established when the array is constructed. If the maxByteLength option was set in the constructor, resizable will return true; if not, it will return false. ",
    "ArrayBuffer() constructor": "The ArrayBuffer() constructor creates ArrayBuffer objects. ",
    "ArrayBuffer.prototype.resize()": "The resize() method resizes an ArrayBuffer to the size specified by the newLength parameter, provided that the ArrayBuffer is resizable and the new size is less than or equal to the maxByteLength of the ArrayBuffer. New bytes are initialized to 0.\nNote that you can use resize() to shrink as well as grow an ArrayBuffer \u00e2\u0080\u0094 it is permissible for newLength to be smaller than the ArrayBuffer's current byteLength. ",
    "ArrayBuffer.prototype.maxByteLength": "The maxByteLength property is an accessor property whose set accessor function is undefined, meaning that you can only read this property. The value is established when the array is constructed, set via the maxByteLength option of the ArrayBuffer() constructor, and cannot be changed.\nThis property returns 0 if this ArrayBuffer has been detached. If this ArrayBuffer was constructed without specifying a maxByteLength value, this property returns a value equal to the value of the ArrayBuffer's byteLength. ",
    "ArrayBuffer.prototype.transfer()": "The transfer() method performs the same operation as the structured clone algorithm. It copies the bytes of this ArrayBuffer into a new ArrayBuffer object, then detaches this ArrayBuffer object. See transferring ArrayBuffers for more information.\ntransfer() preserves the resizability of this ArrayBuffer. If you want the new ArrayBuffer to be non-resizable, use transferToFixedLength() instead. There's no way to transfer a buffer that makes a fixed-length buffer become resizable.\ntransfer() is very efficient because implementations may implement this method as a zero-copy move or a realloc \u00e2\u0080\u0094 there does not need to be an actual copy of the data. ",
    "SharedArrayBuffer.prototype.growable": "The growable property is an accessor property whose set accessor function is undefined, meaning that you can only read this property. The value is established when the array is constructed. If a maxByteLength option was set in the constructor, growable will return true; if not, it will return false. ",
    "SharedArrayBuffer[@@species]": "The @@species accessor property returns the default constructor for SharedArrayBuffer objects. Subclass constructors may override it to change the constructor assignment. The default implementation is basically:\njs// Hypothetical underlying implementation for illustration\nclass SharedArrayBuffer {\n  static get [Symbol.species]() {\n    return this;\n  }\n}\n\nBecause of this polymorphic implementation, @@species of derived subclasses would also return the constructor itself by default.\njsclass SubArrayBuffer extends SharedArrayBuffer {}\nSubArrayBuffer[Symbol.species] === SharedArrayBuffer; // true\n\nWhen calling array buffer methods that do not mutate the existing array but return a new array buffer instance (for example, slice()), the array's constructor[@@species] will be accessed. The returned constructor will be used to construct the return value of the array buffer method. ",
    "SharedArrayBuffer.prototype.slice()": "The slice() method of SharedArrayBuffer instances returns a new SharedArrayBuffer whose contents are a copy of this SharedArrayBuffer's bytes from start, inclusive, up to end, exclusive. If either start or end is negative, it refers to an index from the end of the array, as opposed to from the beginning. ",
    "SharedArrayBuffer() constructor": "\nNote: The SharedArrayBuffer constructor may not always be globally available unless certain security requirements are met.\n \n The SharedArrayBuffer() constructor creates SharedArrayBuffer objects. ",
    "SharedArrayBuffer.prototype.byteLength": "The byteLength property is an accessor property whose set accessor function is undefined, meaning that you can only read this property. The value is established when the shared array is constructed and cannot be changed. ",
    "SharedArrayBuffer.prototype.maxByteLength": "The maxByteLength property is an accessor property whose set accessor function is undefined, meaning that you can only read this property. The value is established when the shared array is constructed, set via the maxByteLength option of the SharedArrayBuffer() constructor, and cannot be changed.\nIf this SharedArrayBuffer was constructed without specifying a maxByteLength value, this property returns a value equal to the value of the SharedArrayBuffer's byteLength. ",
    "SharedArrayBuffer.prototype.grow()": "The grow() method grows a SharedArrayBuffer to the size specified by the newLength parameter, provided that the SharedArrayBuffer is growable and the new size is less than or equal to the maxByteLength of the SharedArrayBuffer. New bytes are initialized to 0. ",
    "DataView.prototype.getInt16()": "The getInt16() method of DataView instances reads 2 bytes starting at the specified byte offset of this DataView and interprets them as a 16-bit signed integer. There is no alignment constraint; multi-byte values may be fetched from any offset within bounds. ",
    "DataView.prototype.setBigUint64()": "The setBigUint64() method of DataView instances takes a BigInt and stores it as a 64-bit unsigned integer in the 8 bytes starting at the specified byte offset of this DataView. There is no alignment constraint; multi-byte values may be stored at any offset within bounds. ",
    "DataView.prototype.setInt16()": "The setInt16() method of DataView instances takes a number and stores it as a 16-bit signed integer in the 2 bytes starting at the specified byte offset of this DataView. There is no alignment constraint; multi-byte values may be stored at any offset within bounds. ",
    "DataView.prototype.setUint16()": "The setUint16() method of DataView instances takes a number and stores it as a 16-bit unsigned integer in the 2 bytes starting at the specified byte offset of this DataView. There is no alignment constraint; multi-byte values may be stored at any offset within bounds. ",
    "DataView.prototype.setInt8()": "The setInt8() method of DataView instances takes a number and stores it as an 8-bit signed integer in the byte at the specified byte offset of this DataView. ",
    "DataView.prototype.buffer": "The buffer property is an accessor property whose set accessor function is undefined, meaning that you can only read this property. The value is established when the DataView is constructed and cannot be changed. ",
    "DataView.prototype.byteLength": "The byteLength property is an accessor property whose set accessor function is undefined, meaning that you can only read this property. The value is established when an DataView is constructed and cannot be changed. If the DataView is not specifying an offset or a byteLength, the byteLength of the referenced ArrayBuffer or SharedArrayBuffer will be returned. ",
    "DataView.prototype.getInt32()": "The getInt32() method of DataView instances reads 4 bytes starting at the specified byte offset of this DataView and interprets them as a 32-bit signed integer. There is no alignment constraint; multi-byte values may be fetched from any offset within bounds. ",
    "DataView.prototype.getBigInt64()": "The getBigInt64() method of DataView instances reads 8 bytes starting at the specified byte offset of this DataView and interprets them as a 64-bit signed integer. There is no alignment constraint; multi-byte values may be fetched from any offset within bounds. ",
    "DataView.prototype.getUint8()": "The getUint8() method of DataView instances reads 1 byte at the specified byte offset of this DataView and interprets it as an 8-bit unsigned integer. ",
    "DataView.prototype.byteOffset": "The byteOffset property is an accessor property whose set accessor function is undefined, meaning that you can only read this property. The value is established when an DataView is constructed and cannot be changed. ",
    "DataView.prototype.setInt32()": "The setInt32() method of DataView instances takes a number and stores it as a 32-bit signed integer in the 4 bytes starting at the specified byte offset of this DataView. There is no alignment constraint; multi-byte values may be stored at any offset within bounds. ",
    "DataView.prototype.getUint32()": "The getUint32() method of DataView instances reads 4 bytes starting at the specified byte offset of this DataView and interprets them as a 32-bit unsigned integer. There is no alignment constraint; multi-byte values may be fetched from any offset within bounds. ",
    "DataView.prototype.getBigUint64()": "The getBigUint64() method of DataView instances reads 8 bytes starting at the specified byte offset of this DataView and interprets them as a 64-bit unsigned integer. There is no alignment constraint; multi-byte values may be fetched from any offset within bounds. ",
    "DataView() constructor": "The DataView() constructor creates DataView objects. ",
    "DataView.prototype.setFloat64()": "The setFloat64() method of DataView instances takes a number and stores it as a 64-bit floating point number in the 8 bytes starting at the specified byte offset of this DataView. There is no alignment constraint; multi-byte values may be stored at any offset within bounds. ",
    "DataView.prototype.setFloat32()": "The setFloat32() method of DataView instances takes a number and stores it as a 32-bit floating point number in the 4 bytes starting at the specified byte offset of this DataView. There is no alignment constraint; multi-byte values may be stored at any offset within bounds. ",
    "DataView.prototype.setUint8()": "The setUint8() method of DataView instances takes a number and stores it as an 8-bit unsigned integer in the byte at the specified byte offset of this DataView. ",
    "DataView.prototype.getFloat32()": "The getFloat32() method of DataView instances reads 4 bytes starting at the specified byte offset of this DataView and interprets them as a 32-bit floating point number. There is no alignment constraint; multi-byte values may be fetched from any offset within bounds. ",
    "DataView.prototype.getInt8()": "The getInt8() method of DataView instances reads 1 byte at the specified byte offset of this DataView and interprets it as an 8-bit signed integer. ",
    "DataView.prototype.setBigInt64()": "The setBigInt64() method of DataView instances takes a BigInt and stores it as a 64-bit signed integer in the 8 bytes starting at the specified byte offset of this DataView. There is no alignment constraint; multi-byte values may be stored at any offset within bounds. ",
    "DataView.prototype.getFloat64()": "The getFloat64() method of DataView instances reads 8 bytes starting at the specified byte offset of this DataView and interprets them as a 64-bit floating point number. There is no alignment constraint; multi-byte values may be fetched from any offset within bounds. ",
    "DataView.prototype.setUint32()": "The setUint32() method of DataView instances takes a number and stores it as a 32-bit unsigned integer in the 4 bytes starting at the specified byte offset of this DataView. There is no alignment constraint; multi-byte values may be stored at any offset within bounds. ",
    "DataView.prototype.getUint16()": "The getUint16() method of DataView instances reads 2 bytes starting at the specified byte offset of this DataView and interprets them as a 16-bit unsigned integer. There is no alignment constraint; multi-byte values may be fetched from any offset within bounds. ",
    "Atomics.waitAsync()": "The Atomics.waitAsync() static method waits asynchronously on a shared memory location and returns a Promise. \n Unlike Atomics.wait(), waitAsync is non-blocking and usable on the main thread. \n \nNote: This operation only works with an Int32Array or BigInt64Array that views a SharedArrayBuffer.\n ",
    "Atomics.exchange()": "The Atomics.exchange() static method exchanges a given value at a given position in the array and returns the old value at that position. This atomic operation guarantees that no other write happens between the read of the old value and the write of the new value. ",
    "Atomics.notify()": "\n  The Atomics.notify() static\n  method notifies up some agents that are sleeping in the wait queue.\n \n \n\nNote: This operation only works with an Int32Array or BigInt64Array that views a SharedArrayBuffer.\n    It will return 0 on non-shared ArrayBuffer objects.\n  \n ",
    "Atomics.isLockFree()": "\n  The Atomics.isLockFree() static\n  method is used to determine whether the Atomics methods use locks\n  or atomic hardware operations when applied to typed arrays with the given element\n  byte size.\n  It returns false if the given size is not one of the BYTES_PER_ELEMENT\n  property of integer TypedArray types.\n ",
    "Atomics.or()": "\n  The bitwise OR operation yields 1, if either a or b are 1.\n  The truth table for the OR operation is:\n\n\n\n\na\nb\na | b\n\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n1\n\n\n\n\n  For example, a bitwise OR of 5 | 1 results in 0101 which is 5\n  in decimal.\n\n5  0101\n1  0001\n   ----\n5  0101\n ",
    "Atomics.add()": "\n  The Atomics.add() static\n  method adds a given value at a given position in the array and returns the old value at\n  that position. This atomic operation guarantees that no other write happens until the\n  modified value is written back.\n ",
    "Atomics.and()": "\n  The bitwise AND operation only yields 1, if both a and b are\n  1. The truth table for the AND operation is:\n\n\n\n\na\nb\na & b\n\n\n\n\n0\n0\n0\n\n\n0\n1\n0\n\n\n1\n0\n0\n\n\n1\n1\n1\n\n\n\n\n  For example, a bitwise AND of 5 & 1 results in 0001 which\n  is 1 in decimal.\n\n5  0101\n1  0001\n   ----\n1  0001\n ",
    "Atomics.load()": "\n  The Atomics.load() static\n  method returns a value at a given position in the array.\n ",
    "Atomics.sub()": "\n  The Atomics.sub() static method subtracts a given value\n  at a given position in the array and returns the old value at that position. This atomic\n  operation guarantees that no other write happens until the modified value is written\n  back.\n ",
    "Atomics.compareExchange()": "The Atomics.compareExchange() static method exchanges a given replacement value at a given position in the array, if a given expected value equals the old value. It returns the old value at that position whether it was equal to the expected value or not. This atomic operation guarantees that no other write happens until the modified value is written back. ",
    "Atomics.xor()": "\n  The bitwise XOR operation yields 1, if a and b are different.\n  The truth table for the XOR operation is:\n\n\n\n\na\nb\na ^ b\n\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n0\n\n\n\n\n  For example, a bitwise XOR of 5 ^ 1 results in 0100 which is\n  4 in decimal.\n\n5  0101\n1  0001\n   ----\n4  0100\n ",
    "Atomics.wait()": "\n  The Atomics.wait() static\n  method verifies that a shared memory location still contains a\n  given value and if so sleeps, awaiting a wake-up notification or times out. It returns a string which\n  is either \"ok\", \"not-equal\", or \"timed-out\".\n \n \n\nNote: This operation only works with an Int32Array or BigInt64Array that views a SharedArrayBuffer, and may not be allowed on the main thread.\n    For a non-blocking, asynchronous version of this method, see Atomics.waitAsync().\n  \n ",
    "Atomics.store()": "\n  The Atomics.store() static\n  method stores a given value at the given position in the array and returns that value.\n ",
    "JSON.parse()": "JSON.parse() parses a JSON string according to the JSON grammar, then evaluates the string as if it's a JavaScript expression. The only instance where a piece of JSON text represents a different value from the same JavaScript expression is when dealing with the \"__proto__\" key \u00e2\u0080\u0094 see Object literal syntax vs. JSON. ",
    "JSON.stringify()": "JSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner:\n\nBoolean, Number, String, and BigInt (obtainable via Object()) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object()) are treated as plain objects.\nAttempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ...), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.\nundefined, Function, and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in \"pure\" values like JSON.stringify(() => {}) or JSON.stringify(undefined).\nThe numbers Infinity and NaN, as well as the value null, are all considered null. (But unlike the values in the previous point, they would never be omitted.)\nArrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored.\nFor other objects:\n    \nAll Symbol-keyed properties will be completely ignored, even when using the replacer parameter.\nIf the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key, which has the same semantic as the key parameter of the replacer function:\n        \nif this object is a property value, the property name\nif it is in an array, the index in the array, as a string\nif JSON.stringify() was directly called on this object, an empty string\nDate objects implement the toJSON() method which returns a string (the same as date.toISOString()). Thus, they will be stringified as strings.\n      \n\n        Only enumerable own properties are visited. This means Map, Set, etc. will become \"{}\". You can use the replacer parameter to serialize them to something more useful.\n        Properties are visited using the same algorithm as Object.keys(), which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).\n      \n\n\n ",
    "WeakRef.prototype.deref()": "See the Notes on WeakRefs section of the WeakRef page for some important notes. ",
    "WeakRef() constructor": "The WeakRef() constructor creates WeakRef objects. ",
    "FinalizationRegistry.prototype.unregister()": "\n  When a target value has been reclaimed, it is no longer registered in the registry.\n  There is no need to call unregister in your cleanup callback. Only call\n  unregister if you haven't received a cleanup callback and no longer need\n  to receive one.\n ",
    "FinalizationRegistry.prototype.register()": "\n  See the Avoid where possible\n  and Notes on cleanup callbacks\n  sections of the FinalizationRegistry page for important caveats.\n ",
    "FinalizationRegistry() constructor": "The FinalizationRegistry() constructor creates FinalizationRegistry objects. ",
    "Iterator.prototype[@@iterator]()": "The [@@iterator]() method of Iterator instances implements the iterable protocol and allows built-in iterators to be consumed by most syntaxes expecting iterables, such as the spread syntax and for...of loops. It returns the value of this, which is the iterator object itself. ",
    "Iterator.from()": "This method exists to convert custom iterators, probably exported by libraries, to proper iterators. All iterator objects returned by Iterator.from() inherit from a common prototype object, which has the following methods:\n\nnext()\n\nCalls the underlying iterator's next() method and returns the result.\n\nreturn()\n\nCalls the underlying iterator's return() method and returns the result, or returns { value: undefined, done: true } if the underlying iterator doesn't have a return() method.\n\n ",
    "Iterator.prototype.some()": "some() iterates the iterator and invokes the callbackFn function once for each element. It returns true immediately if the callback function returns a truthy value. Otherwise, it iterates until the end of the iterator and returns false. If some() returns true, the underlying iterator is closed by calling its return() method.\nThe main advantage of iterator helpers over array methods is their ability to work with infinite iterators. With infinite iterators, some() returns true as soon as the first truthy value is found. If the callbackFn always returns a falsy value, the method never returns. ",
    "Iterator() constructor": "Iterator represents an abstract class \u00e2\u0080\u0094 a class that provides common utilities for its subclasses, but is not intended to be instantiated itself. It is the superclass of all other iterator classes, and is used to create subclasses that implement specific iteration algorithms \u00e2\u0080\u0094 namely, all subclasses of Iterator must implement a next() method as required by the iterator protocol. Because Iterator doesn't actually provide the next() method, it doesn't make sense to construct an Iterator directly.\nYou can also use Iterator.from() to create an Iterator instance from an existing iterable or iterator object. ",
    "Iterator.prototype.filter()": "The main advantage of iterator helpers over array methods is their ability to work with infinite iterators. With infinite iterators, filter() allows you to iterate over only those elements that satisfy a given condition. ",
    "Iterator.prototype.forEach()": "forEach() iterates the iterator and invokes the callbackFn function once for each element. Unlike most other iterator helper methods, it does not work well with infinite iterators, because it is not lazy. ",
    "Iterator.prototype.drop()": "Experimental: This is an experimental technologyCheck the Browser compatibility table carefully before using this in production. \n The drop() method of Iterator instances returns a new iterator helper that skips the given number of elements at the start of this iterator. ",
    "Iterator.prototype.reduce()": "See Array.prototype.reduce() for details about how reduce() works. Unlike most other iterator helper methods, it does not work well with infinite iterators, because it is not lazy. ",
    "Iterator.prototype.find()": "find() iterates the iterator and invokes the callbackFn function once for each element. It returns the element immediately if the callback function returns a truthy value. Otherwise, it iterates until the end of the iterator and returns undefined. If find() returns an element, the underlying iterator is closed by calling its return() method.\nThe main advantage of iterator helpers over array methods is their ability to work with infinite iterators. With infinite iterators, find() returns the first satisfying element as soon as it is found. If the callbackFn always returns a falsy value, the method never returns. ",
    "Iterator.prototype.every()": "every() iterates the iterator and invokes the callbackFn function once for each element. It returns false immediately if the callback function returns a falsy value. Otherwise, it iterates until the end of the iterator and returns true. If every() returns false, the underlying iterator is closed by calling its return() method.\nThe main advantage of iterator helpers over array methods is their ability to work with infinite iterators. With infinite iterators, every() returns false as soon as the first falsy value is found. If the callbackFn always returns a truthy value, the method never returns. ",
    "Iterator.prototype.toArray()": "Experimental: This is an experimental technologyCheck the Browser compatibility table carefully before using this in production. \n The toArray() method of Iterator instances creates a new Array instance populated with the elements yielded from the iterator. ",
    "Iterator.prototype.map()": "The main advantage of iterator helpers over array methods is their ability to work with infinite iterators. With infinite iterators, map() allows you to create a new iterator that, when iterated, produces transformed elements. ",
    "Iterator.prototype.flatMap()": "flatMap accepts two kinds of return values from callbackFn: an iterator or iterable. They are handled in the same way as Iterator.from(): if the return value is iterable, the @@iterator method is called and the return value is used; otherwise, the return value is treated as an iterator and its next() method is called.\njs[1, 2, 3]\n  .values()\n  .flatMap((x) => {\n    let itDone = false;\n    const it = {\n      next() {\n        if (itDone) {\n          return { value: undefined, done: true };\n        }\n        itDone = true;\n        return { value: x, done: false };\n      },\n    };\n    switch (x) {\n      case 1:\n        // An iterable that's not an iterator\n        return { [Symbol.iterator]: () => it };\n      case 2:\n        // An iterator that's not an iterable\n        return it;\n      case 3:\n        // An iterable iterator is treated as an iterable\n        return {\n          ...it,\n          [Symbol.iterator]() {\n            console.log(\"@@iterator called\");\n            return it;\n          },\n        };\n    }\n  })\n  .toArray();\n// Logs \"@@iterator called\"\n// Returns [1, 2, 3]\n ",
    "Iterator.prototype.take()": "Experimental: This is an experimental technologyCheck the Browser compatibility table carefully before using this in production. \n The take() method of Iterator instances returns a new iterator helper that yields the given number of elements in this iterator and then terminates. ",
    "AsyncIterator.prototype[@@asyncIterator]()": "The [@@asyncIterator]() method of AsyncIterator instances implements the async iterable protocol and allows built-in async iterators to be consumed by most syntaxes expecting async iterables, such as for await...of loops. It returns the value of this, which is the async iterator object itself. ",
    "Promise.prototype.finally()": "The finally() method can be useful if you want to do some processing or cleanup once the promise is settled, regardless of its outcome.\nThe finally() method is very similar to calling then(onFinally, onFinally). However, there are a couple of differences:\n\nWhen creating a function inline, you can pass it once, instead of being forced to either declare it twice, or create a variable for it.\nThe onFinally callback does not receive any argument. This use case is for precisely when you do not care about the rejection reason or the fulfillment value, and so there's no need to provide it.\nA finally() call is usually transparent and does not change the eventual state of the original promise. So for example:\n    \nUnlike Promise.resolve(2).then(() => 77, () => {}), which returns a promise eventually fulfilled with the value 77, Promise.resolve(2).finally(() => 77) returns a promise eventually fulfilled with the value 2.\nSimilarly, unlike Promise.reject(3).then(() => {}, () => 88), which returns a promise eventually fulfilled with the value 88, Promise.reject(3).finally(() => 88) returns a promise eventually rejected with the reason 3.\n\n\n\n\nNote: A throw (or returning a rejected promise) in the finally callback still rejects the returned promise. For example, both Promise.reject(3).finally(() => { throw 99; }) and Promise.reject(3).finally(() => Promise.reject(99)) reject the returned promise with the reason 99.\n\nLike catch(), finally() internally calls the then method on the object upon which it was called. If onFinally is not a function, then() is called with onFinally as both arguments \u00e2\u0080\u0094 which, for Promise.prototype.then(), means that no useful handler is attached. Otherwise, then() is called with two internally created functions, which behave like the following:\n\nWarning: This is only for demonstration purposes and is not a polyfill.\n\njspromise.then(\n  (value) => Promise.resolve(onFinally()).then(() => value),\n  (reason) =>\n    Promise.resolve(onFinally()).then(() => {\n      throw reason;\n    }),\n);\n\nBecause finally() calls then(), it supports subclassing. Moreover, notice the Promise.resolve() call above \u00e2\u0080\u0094 in reality, onFinally()'s return value is resolved using the same algorithm as Promise.resolve(), but the actual constructor used to construct the resolved promise will be the subclass. finally() gets this constructor through promise.constructor[@@species]. ",
    "Promise.race()": "The Promise.race() method is one of the promise concurrency methods. It's useful when you want the first async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\nIf the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to the first of these values found in the iterable. ",
    "Promise.reject()": "The static Promise.reject function returns a Promise that is rejected. For debugging purposes and selective error catching, it is useful to make reason an instanceof Error.\nPromise.reject() is generic and supports subclassing, which means it can be called on subclasses of Promise, and the result will be a promise of the subclass type. To do so, the subclass's constructor must implement the same signature as the Promise() constructor \u00e2\u0080\u0094 accepting a single executor function that can be called with the resolve and reject callbacks as parameters. Promise.reject() is essentially a shorthand for new Promise((resolve, reject) => reject(reason)).\nUnlike Promise.resolve(), Promise.reject() always wraps reason in a new Promise object, even when reason is already a Promise. ",
    "Promise.withResolvers()": "Promise.withResolvers() is exactly equivalent to the following code:\njslet resolve, reject;\nconst promise = new Promise((res, rej) => {\n  resolve = res;\n  reject = rej;\n});\n\nExcept that it is more concise and does not require the use of let.\nThe key difference when using Promise.withResolvers() is that the resolution and rejection functions now live in the same scope as the promise itself, instead of being created and used once within the executor. This may enable some more advanced use cases, such as when reusing them for recurring events, particularly with streams and queues. This also generally results in less nesting than wrapping a lot of logic within the executor.\nPromise.withResolvers() is generic and supports subclassing, which means it can be called on subclasses of Promise, and the result will contain a promise of the subclass type. To do so, the subclass's constructor must implement the same signature as the Promise() constructor \u00e2\u0080\u0094 accepting a single executor function that can be called with the resolve and reject callbacks as parameters. ",
    "Promise[@@species]": "The @@species accessor property returns the default constructor for Promise objects. Subclass constructors may override it to change the constructor assignment. The default implementation is basically:\njs// Hypothetical underlying implementation for illustration\nclass Promise {\n  static get [Symbol.species]() {\n    return this;\n  }\n}\n\nBecause of this polymorphic implementation, @@species of derived subclasses would also return the constructor itself by default.\njsclass SubPromise extends Promise {}\nSubPromise[Symbol.species] === SubPromise; // true\n\nPromise chaining methods \u00e2\u0080\u0094 then(), catch(), and finally() \u00e2\u0080\u0094 return new promise objects. They get the constructor to construct the new promise through this.constructor[@@species]. If this.constructor is undefined, or if this.constructor[@@species] is undefined or null, the default Promise() constructor is used. Otherwise, the constructor returned by this.constructor[@@species] is used to construct the new promise object. ",
    "Promise.prototype.catch()": "The catch method is used for error handling in promise composition. Since it returns a Promise, it can be chained in the same way as its sister method, then().\nIf a promise becomes rejected, and there are no rejection handlers to call (a handler can be attached through any of then(), catch(), or finally()), then the rejection event is surfaced by the host. In the browser, this results in an unhandledrejection event. If a handler is attached to a rejected promise whose rejection has already caused an unhandled rejection event, then another rejectionhandled event is fired.\ncatch() internally calls then() on the object upon which it was called, passing undefined and onRejected as arguments. The value of that call is directly returned. This is observable if you wrap the methods.\njs// overriding original Promise.prototype.then/catch just to add some logs\n((Promise) => {\n  const originalThen = Promise.prototype.then;\n  const originalCatch = Promise.prototype.catch;\n\n  Promise.prototype.then = function (...args) {\n    console.log(\"Called .then on %o with arguments: %o\", this, args);\n    return originalThen.apply(this, args);\n  };\n  Promise.prototype.catch = function (...args) {\n    console.error(\"Called .catch on %o with arguments: %o\", this, args);\n    return originalCatch.apply(this, args);\n  };\n})(Promise);\n\n// calling catch on an already resolved promise\nPromise.resolve().catch(function XXX() {});\n\n// Logs:\n// Called .catch on Promise{} with arguments: Arguments{1} [0: function XXX()]\n// Called .then on Promise{} with arguments: Arguments{2} [0: undefined, 1: function XXX()]\n\nThis means that passing undefined still causes the returned promise to be rejected, and you have to pass a function to prevent the final promise from being rejected.\nBecause catch() just calls then(), it supports subclassing.\n\nNote: The examples below are throwing instances of Error. As with synchronous throw statements, this is considered a good practice; otherwise, the part doing the catching would have to perform checks to see if the argument was a string or an error, and you might lose valuable information such as stack traces.\n ",
    "Promise.prototype.then()": "The then() method schedules callback functions for the eventual completion of a Promise \u00e2\u0080\u0094 either fulfillment or rejection. It is the primitive method of promises: the thenable protocol expects all promise-like objects to expose a then() method, and the catch() and finally() methods both work by invoking the object's then() method.\nFor more information about the onRejected handler, see the catch() reference.\nthen() returns a new promise object. If you call the then() method twice on the same promise object (instead of chaining), then this promise object will have two pairs of settlement handlers. All handlers attached to the same promise object are always called in the order they were added. Moreover, the two promises returned by each call of then() start separate chains and do not wait for each other's settlement.\nThenable objects that arise along the then() chain are always resolved \u00e2\u0080\u0094 the onFulfilled handler never receives a thenable object, and any thenable returned by either handler are always resolved before being passed to the next handler. This is because when constructing the new promise, the resolve and reject functions passed by the executor are saved, and when the current promise settles, the respective function will be called with the fulfillment value or rejection reason. The resolving logic comes from the resolve function passed by the Promise() constructor.\nthen() supports subclassing, which means it can be called on instances of subclasses of Promise, and the result will be a promise of the subclass type. You can customize the type of the return value through the @@species property. ",
    "Promise.any()": "The Promise.any() method is one of the promise concurrency methods. This method is useful for returning the first promise that fulfills. It short-circuits after a promise fulfills, so it does not wait for the other promises to complete once it finds one.\nUnlike Promise.all(), which returns an array of fulfillment values, we only get one fulfillment value (assuming at least one promise fulfills). This can be beneficial if we need only one promise to fulfill but we do not care which one does. Note another difference: this method rejects upon receiving an empty iterable, since, truthfully, the iterable contains no items that fulfill. You may compare Promise.any() and Promise.all() with Array.prototype.some() and Array.prototype.every().\nAlso, unlike Promise.race(), which returns the first settled value (either fulfillment or rejection), this method returns the first fulfilled value. This method ignores all rejected promises up until the first promise that fulfills. ",
    "Promise() constructor": "Traditionally (before promises), asynchronous tasks were designed as callbacks.\njsreadFile(\"./data.txt\", (error, result) => {\n  // This callback will be called when the task is done, with the\n  // final `error` or `result`. Any operation dependent on the\n  // result must be defined within this callback.\n});\n// Code here is immediately executed after the `readFile` request\n// is fired. It does not wait for the callback to be called, hence\n// making `readFile` \"asynchronous\".\n\nTo take advantage of the readability improvement and language features offered by promises, the Promise() constructor allows one to transform the callback-based API to a promise-based one.\n\nNote: If your task is already promise-based, you likely do not need the Promise() constructor.\n\nThe executor is custom code that ties an outcome in a callback to a promise. You, the programmer, write the executor. Its signature is expected to be:\njsfunction executor(resolveFunc, rejectFunc) {\n  // Typically, some asynchronous operation that accepts a callback,\n  // like the `readFile` function above\n}\n\nresolveFunc and rejectFunc are also functions, and you can give them whatever actual names you want. Their signatures are simple: they accept a single parameter of any type.\njsresolveFunc(value); // call on resolved\nrejectFunc(reason); // call on rejected\n\nThe value parameter passed to resolveFunc can be another promise object, in which case the newly constructed promise's state will be \"locked in\" to the promise passed (as part of the resolution promise). The rejectFunc has semantics close to the throw statement, so reason is typically an Error instance. If either value or reason is omitted, the promise is fulfilled/rejected with undefined.\nThe executor's completion state has limited effect on the promise's state:\n\nThe executor return value is ignored. return statements within the executor merely impact control flow and alter whether a part of the function is executed, but do not have any impact on the promise's fulfillment value. If executor exits and it's impossible for resolveFunc or rejectFunc to be called in the future (for example, there are no async tasks scheduled), then the promise remains pending forever.\nIf an error is thrown in the executor, the promise is rejected, unless resolveFunc or rejectFunc has already been called.\n\n\nNote: The existence of pending promises does not prevent the program from exiting. If the event loop is empty, the program exits despite any pending promises (because those are necessarily forever-pending).\n\nHere's a summary of the typical flow:\n\nAt the time when the constructor generates the new Promise object, it also generates a corresponding pair of functions for resolveFunc and rejectFunc; these are \"tethered\" to the Promise object.\nexecutor typically wraps some asynchronous operation which provides a callback-based API. The callback (the one passed to the original callback-based API) is defined within the executor code, so it has access to the resolveFunc and rejectFunc.\nThe executor is called synchronously (as soon as the Promise is constructed) with the resolveFunc and rejectFunc functions as arguments.\nThe code within the executor has the opportunity to perform some operation. The eventual completion of the asynchronous task is communicated with the promise instance via the side effect caused by resolveFunc or rejectFunc. The side effect is that the Promise object becomes \"resolved\".\n    \nIf resolveFunc is called first, the value passed will be resolved. The promise may stay pending (in case another thenable is passed), become fulfilled (in most cases where a non-thenable value is passed), or become rejected (in case of an invalid resolution value).\nIf rejectFunc is called first, the promise instantly becomes rejected.\nOnce one of the resolving functions (resolveFunc or rejectFunc) is called, the promise stays resolved. Only the first call to resolveFunc or rejectFunc affects the promise's eventual state, and subsequent calls to either function can neither change the fulfillment value/rejection reason nor toggle its eventual state from \"fulfilled\" to \"rejected\" or opposite.\nIf executor exits by throwing an error, then the promise is rejected. However, the error is ignored if one of the resolving functions has already been called (so that the promise is already resolved).\nResolving the promise does not necessarily cause the promise to become fulfilled or rejected (i.e. settled). The promise may still be pending because it's resolved with another thenable, but its eventual state will match that of the resolved thenable.\n\n\nOnce the promise settles, it (asynchronously) invokes any further handlers associated through then(), catch(), or finally(). The eventual fulfillment value or rejection reason is passed to the invocation of fulfillment and rejection handlers as an input parameter (see Chained Promises).\n\nFor example, the callback-based readFile API above can be transformed into a promise-based one.\njsconst readFilePromise = (path) =>\n  new Promise((resolve, reject) => {\n    readFile(path, (error, result) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(result);\n      }\n    });\n  });\n\nreadFilePromise(\"./data.txt\")\n  .then((result) => console.log(result))\n  .catch((error) => console.error(\"Failed to read data\"));\n\nThe resolve and reject callbacks are only available within the scope of the executor function, which means you can't access them after the promise is constructed. If you want to construct the promise before deciding how to resolve it, you can use the Promise.withResolvers() method instead, which exposes the resolve and reject functions. ",
    "Promise.allSettled()": "The Promise.allSettled() method is one of the promise concurrency methods. Promise.allSettled() is typically used when you have multiple asynchronous tasks that are not dependent on one another to complete successfully, or you'd always like to know the result of each promise.\nIn comparison, the Promise returned by Promise.all() may be more appropriate if the tasks are dependent on each other, or if you'd like to immediately reject upon any of them rejecting. ",
    "Promise.all()": "The Promise.all() method is one of the promise concurrency methods. It can be useful for aggregating the results of multiple promises. It is typically used when there are multiple related asynchronous tasks that the overall code relies on to work successfully \u00e2\u0080\u0094 all of whom we want to fulfill before the code execution continues.\nPromise.all() will reject immediately upon any of the input promises rejecting. In comparison, the promise returned by Promise.allSettled() will wait for all input promises to complete, regardless of whether or not one rejects. Use allSettled() if you need the final result of every promise in the input iterable. ",
    "Promise.resolve()": "Promise.resolve() resolves a promise, which is not the same as fulfilling or rejecting the promise. See Promise description for definitions of the terminology. In brief, Promise.resolve() returns a promise whose eventual state depends on another promise, thenable object, or other value.\nPromise.resolve() is generic and supports subclassing, which means it can be called on subclasses of Promise, and the result will be a promise of the subclass type. To do so, the subclass's constructor must implement the same signature as the Promise() constructor \u00e2\u0080\u0094 accepting a single executor function that can be called with the resolve and reject callbacks as parameters.\nPromise.resolve() special-cases native Promise instances. If value belongs to Promise or a subclass, and value.constructor === Promise, then value is directly returned by Promise.resolve(), without creating a new Promise instance. Otherwise, Promise.resolve() is essentially a shorthand for new Promise((resolve) => resolve(value)).\nThe bulk of the resolving logic is actually implemented by the resolve function passed by the Promise() constructor. In summary:\n\nIf a non-thenable value is passed, the returned promise is already fulfilled with that value.\nIf a thenable is passed, the returned promise will adopt the state of that thenable by calling the then method and passing a pair of resolving functions as arguments. (But because native promises directly pass through Promise.resolve() without creating a wrapper, the then method is not called on native promises.) If the resolve function receives another thenable object, it will be resolved again, so that the eventual fulfillment value of the promise will never be thenable.\n ",
    "GeneratorFunction() constructor": "The GeneratorFunction() constructor creates GeneratorFunction objects. \n Note that GeneratorFunction is not a global object. It can be obtained with the following code: \n jsconst GeneratorFunction = function* () {}.constructor;\n \n The GeneratorFunction() constructor is not intended to be used directly, and all caveats mentioned in the Function() description apply to GeneratorFunction(). ",
    "AsyncGeneratorFunction() constructor": "The AsyncGeneratorFunction() constructor creates AsyncGeneratorFunction objects. \n Note that AsyncGeneratorFunction is not a global object. It could be obtained by evaluating the following code. \n jsconst AsyncGeneratorFunction = async function* () {}.constructor;\n \n The AsyncGeneratorFunction() constructor is not intended to be used directly, and all caveats mentioned in the Function() description apply to AsyncGeneratorFunction(). ",
    "Generator.prototype.throw()": "The throw() method, when called, can be seen as if a throw exception; statement is inserted in the generator's body at the current suspended position, where exception is the exception passed to the throw() method. Therefore, in a typical flow, calling throw(exception) will cause the generator to throw. However, if the yield expression is wrapped in a try...catch block, the error may be caught and control flow can either resume after error handling, or exit gracefully. ",
    "Generator.prototype.return()": "The return() method, when called, can be seen as if a return value; statement is inserted in the generator's body at the current suspended position, where value is the value passed to the return() method. Therefore, in a typical flow, calling return(value) will return { done: true, value: value }. However, if the yield expression is wrapped in a try...finally block, the control flow doesn't exit the function body, but proceeds to the finally block instead. In this case, the value returned may be different, and done may even be false, if there are more yield expressions within the finally block. ",
    "Generator.prototype.next()": "\n  The next() method of Generator instances returns an\n  object with two properties done and value. You can also\n  provide a parameter to the next method to send a value to the\n  generator.\n ",
    "GeneratorFunction": "The GeneratorFunction object provides methods for generator functions. In JavaScript, every generator function is actually a GeneratorFunction object. \n Note that GeneratorFunction is not a global object. It can be obtained with the following code: \n jsconst GeneratorFunction = function* () {}.constructor;\n \n GeneratorFunction is a subclass of Function. ",
    "AsyncGeneratorFunction": "The AsyncGeneratorFunction object provides methods for async generator functions. In JavaScript, every async generator function is actually an AsyncGeneratorFunction object. \n Note that AsyncGeneratorFunction is not a global object. It can be obtained with the following code: \n jsconst AsyncGeneratorFunction = async function* () {}.constructor;\n \n AsyncGeneratorFunction is a subclass of Function. ",
    "AsyncGenerator.prototype.next()": "The next() method of AsyncGenerator instances returns the next value in the sequence. ",
    "AsyncGenerator.prototype.return()": "The return() method, when called, can be seen as if a return value; statement is inserted in the generator's body at the current suspended position, where value is the value passed to the return() method. Therefore, in a typical flow, calling return(value) will return { done: true, value: value }. However, if the yield expression is wrapped in a try...finally block, the control flow doesn't exit the function body, but proceeds to the finally block instead. In this case, the value returned may be different, and done may even be false, if there are more yield expressions within the finally block. ",
    "AsyncGenerator.prototype.throw()": "The throw() method of AsyncGenerator instances acts as if a throw statement is inserted in the generator's body at the current suspended position, which informs the generator of an error condition and allows it to handle the error, or perform cleanup and close itself. ",
    "AsyncFunction() constructor": "The AsyncFunction() constructor creates AsyncFunction objects. \n Note that AsyncFunction is not a global object. It can be obtained with the following code: \n jsconst AsyncFunction = async function () {}.constructor;\n \n The AsyncFunction() constructor is not intended to be used directly, and all caveats mentioned in the Function() description apply to AsyncFunction(). ",
    "Reflect.setPrototypeOf()": "Reflect.setPrototypeOf() provides the reflective semantic of setting the prototype of an object. At the very low level, setting the prototype returns a boolean (as is the case with the proxy handler). Object.setPrototypeOf() provides nearly the same semantic, but it throws a TypeError if the status is false (the operation was unsuccessful), while Reflect.setPrototypeOf() directly returns the status.\nReflect.setPrototypeOf() invokes the [[SetPrototypeOf]] object internal method of target. ",
    "Reflect.get()": "Reflect.get() provides the reflective semantic of a property access. That is, Reflect.get(target, propertyKey, receiver) is semantically equivalent to:\njstarget[propertyKey];\n\nNote that in a normal property access, target and receiver would observably be the same object.\nReflect.get() invokes the [[Get]] object internal method of target. ",
    "Reflect.construct()": "Reflect.apply() provides the reflective semantic of a constructor call. That is, Reflect.construct(target, argumentsList, newTarget) is semantically equivalent to:\njsnew target(...argumentsList);\n\nNote that when using the new operator, target and newTarget are always the same constructor \u00e2\u0080\u0094 but Reflect.construct() allows you to pass a different new.target value. Conceptually, newTarget is the function on which new was called, and newTarget.prototype will become the constructed object's prototype, while target is the constructor that is actually executed to initialize the object. For example, new.target may also be different from the currently executed constructor in class inheritance.\njsclass A {\n  constructor() {\n    console.log(new.target.name);\n  }\n}\nclass B extends A {}\n\nnew B(); // \"B\"\n\nReflect.construct() allows you to invoke a constructor with a variable number of arguments. (This is also possible with the spread syntax in a normal constructor call.)\njsconst obj = new Foo(...args);\nconst obj = Reflect.construct(Foo, args);\n\nReflect.construct() invokes the [[Construct]] object internal method of target. ",
    "Reflect.getOwnPropertyDescriptor()": "Reflect.getOwnPropertyDescriptor() provides the reflective semantic of retrieving the property descriptor of an object. The only difference with Object.getOwnPropertyDescriptor() is how non-object targets are handled. Reflect.getOwnPropertyDescriptor() throws a TypeError if the target is not an object, while Object.getOwnPropertyDescriptor() coerces it to an object.\nReflect.getOwnPropertyDescriptor() invokes the [[GetOwnProperty]] object internal method of target. ",
    "Reflect.has()": "Reflect.has() provides the reflective semantic of checking if a property is in an object. That is, Reflect.has(target, propertyKey) is semantically equivalent to:\njspropertyKey in target;\n\nReflect.has() invokes the [[HasProperty]] object internal method of target. ",
    "Reflect.getPrototypeOf()": "Reflect.getPrototypeOf() provides the reflective semantic of retrieving the prototype of an object. The only difference with Object.getPrototypeOf() is how non-object targets are handled. Reflect.getPrototypeOf() throws a TypeError if the target is not an object, while Object.getPrototypeOf() coerces it to an object.\nReflect.getPrototypeOf() invokes the [[GetPrototypeOf]] object internal method of target. ",
    "Reflect.isExtensible()": "Reflect.isExtensible() provides the reflective semantic of checking if an object is extensible. The only difference with Object.isExtensible() is how non-object targets are handled. Reflect.isExtensible() throws a TypeError if the target is not an object, while Object.isExtensible() always returns false for non-object targets.\nReflect.isExtensible() invokes the [[IsExtensible]] object internal method of target. ",
    "Reflect.apply()": "Reflect.apply() provides the reflective semantic of a function call. That is, Reflect.apply(target, thisArgument, argumentsList) is semantically equivalent to:\njsMath.floor.apply(null, [1.75]);\nReflect.apply(Math.floor, null, [1.75]);\n\nThe only differences are:\n\nReflect.apply() takes the function to call as the target parameter instead of the this context.\nReflect.apply() throws if argumentsList is omitted instead of defaulting to calling with no parameters.\n\nReflect.apply() invokes the [[Call]] object internal method of target. ",
    "Reflect.preventExtensions()": "Reflect.preventExtensions() provides the reflective semantic of preventing extensions of an object. The differences with Object.preventExtensions() are:\n\nReflect.preventExtensions() throws a TypeError if the target is not an object, while Object.preventExtensions() always returns non-object targets as-is.\nReflect.preventExtensions() returns a Boolean indicating whether or not the target was successfully set to prevent extensions, while Object.preventExtensions() returns the target object.\n\nReflect.preventExtensions() invokes the [[PreventExtensions]] object internal method of target. ",
    "Reflect.deleteProperty()": "Reflect.deleteProperty() provides the reflective semantic of the delete operator. That is, Reflect.deleteProperty(target, propertyKey) is semantically equivalent to:\njsdelete target.propertyKey;\n\nAt the very low level, deleting a property returns a boolean (as is the case with the proxy handler). Reflect.deleteProperty() directly returns the status, while delete would throw a TypeError in strict mode if the status is false. In non-strict mode, delete and Reflect.deleteProperty() have the same behavior.\nReflect.deleteProperty() invokes the [[Delete]] object internal method of target. ",
    "Reflect.ownKeys()": "Reflect.ownKeys() provides the reflective semantic of retrieving all property keys of an object. It is the only way to get all own properties \u00e2\u0080\u0093 enumerable and not enumerable, strings and symbols \u00e2\u0080\u0094 in one call, without extra filtering logic. For example, Object.getOwnPropertyNames() takes the return value of Reflect.ownKeys() and filters to only string values, while Object.getOwnPropertySymbols() filters to only symbol values. Because normal objects implement [[OwnPropertyKeys]] to return all string keys before symbol keys, Reflect.ownKeys(target) is usually equivalent to Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target)). However, if the object has a custom [[OwnPropertyKeys]] method (such as through a proxy's ownKeys handler), the order of the keys may be different.\nReflect.ownKeys() invokes the [[OwnPropertyKeys]] object internal method of target. ",
    "Reflect.defineProperty()": "Reflect.defineProperty() provides the reflective semantic of defining an own property on an object. At the very low level, defining a property returns a boolean (as is the case with the proxy handler). Object.defineProperty() provides nearly the same semantic, but it throws a TypeError if the status is false (the operation was unsuccessful), while Reflect.defineProperty() directly returns the status.\nMany built-in operations would also define own properties on objects. The most significant difference between defining properties and setting them is that setters aren't invoked. For example, class fields directly define properties on the instance without invoking setters.\njsclass B extends class A {\n  set a(v) {\n    console.log(\"Setter called\");\n  }\n} {\n  a = 1; // Nothing logged\n}\n\nReflect.defineProperty() invokes the [[DefineOwnProperty]] object internal method of target. ",
    "Reflect.set()": "Reflect.set() provides the reflective semantic of a property access. That is, Reflect.set(target, propertyKey, value, receiver) is semantically equivalent to:\njstarget[propertyKey] = value;\n\nNote that in a normal property access, target and receiver would observably be the same object.\nReflect.set() invokes the [[Set]] object internal method of target. ",
    "handler.deleteProperty()": "The handler.deleteProperty() method is a trap for the [[Delete]] object internal method, which is used by operations such as the delete operator.",
    "handler.getPrototypeOf()": "The handler.getPrototypeOf() method is a trap for the [[GetPrototypeOf]] object internal method, which is used by operations such as Object.getPrototypeOf().",
    "Proxy() constructor": "\n  Use the Proxy() constructor to create a new Proxy object.\n  This constructor takes two mandatory arguments:\n\n\ntarget is the object for which you want to create the proxy\nhandler is the object that defines the custom behavior of the proxy.\n\n\n  An empty handler will create a proxy that behaves, in almost all respects, exactly like\n  the target. By defining any of a set group of functions on the handler\n  object, you can customize specific aspects of the proxy's behavior. For example, by\n  defining get() you can provide a customized version of the target's\n  property accessor.\n ",
    "handler.getOwnPropertyDescriptor()": "The handler.getOwnPropertyDescriptor() method is a trap for the [[GetOwnProperty]] object internal method, which is used by operations such as Object.getOwnPropertyDescriptor().",
    "handler.set()": "The handler.set() method is a trap for the [[Set]] object internal method, which is used by operations such as using property accessors to set a property's value.",
    "handler.defineProperty()": "The handler.defineProperty() method is a trap for the [[DefineOwnProperty]] object internal method, which is used by operations such as Object.defineProperty(). ",
    "handler.setPrototypeOf()": "The handler.setPrototypeOf() method is a trap for the [[SetPrototypeOf]] object internal method, which is used by operations such as Object.setPrototypeOf().",
    "handler.preventExtensions()": "The handler.preventExtensions() method is a trap for the [[PreventExtensions]] object internal method, which is used by operations such as Object.preventExtensions().",
    "handler.ownKeys()": "The handler.ownKeys() method is a trap for the [[OwnPropertyKeys]] object internal method, which is used by operations such as Object.keys(), Reflect.ownKeys(), etc.",
    "handler.isExtensible()": "The handler.isExtensible() method is a trap for the [[IsExtensible]] object internal method, which is used by operations such as Object.isExtensible().",
    "handler.apply()": "The handler.apply() method is a trap for the [[Call]] object internal method, which is used by operations such as function calls.",
    "handler.get()": "The handler.get() method is a trap for the [[Get]] object internal method, which is used by operations such as property accessors.",
    "Proxy.revocable()": "The Proxy.revocable() factory function is the same as the Proxy() constructor, except that in addition to creating a proxy object, it also creates a revoke function that can be called to disable the proxy. The proxy object and the revoke function are wrapped in a plain object.\nThe revoke function does not take any parameters, nor does it rely on the this value. The created proxy object is attached to the revoke function as a private property that the revoke function accesses on itself when called (the existence of the private property is not observable from the outside, but it has implications on how garbage collection happens). The proxy object is not captured within the closure of the revoke function (which will make garbage collection of proxy impossible if revoke is still alive).\nAfter the revoke() function gets called, the proxy becomes unusable: any trap to a handler throws a TypeError. Once a proxy is revoked, it remains revoked, and calling revoke() again has no effect \u00e2\u0080\u0094 in fact, the call to revoke() detaches the proxy object from the revoke function, so the revoke function will not be able to access the proxy again at all. If the proxy is not referenced elsewhere, it will then be eligible for garbage collection. The revoke function also detaches target and handler from the proxy, so if target is not referenced elsewhere, it will also be eligible for garbage collection, even when its proxy is still alive, since there's no longer a way to meaningfully interact with the target object.\nLetting users interact with an object through a revocable proxy allows you to control the lifetime of the object exposed to the user \u00e2\u0080\u0094 you can make the object garbage-collectable even when the user is still holding a reference to its proxy. ",
    "handler.has()": "The handler.has() method is a trap for the [[HasProperty]] object internal method, which is used by operations such as the in operator.",
    "handler.construct()": "The handler.construct() method is a trap for the [[Construct]] object internal method, which is used by operations such as the new operator. In order for the new operation to be valid on the resulting Proxy object, the target used to initialize the proxy must itself be a valid constructor.",
    "Intl.Locale": "The Intl.Locale object was created to allow for easier manipulation of Unicode locales. Unicode represents locales with a string, called a locale identifier. The locale identifier consists of a language identifier and extension tags. Language identifiers are the core of the locale, consisting of language, script, and region subtags. Additional information about the locale is stored in the optional extension tags. Extension tags hold information about locale aspects such as calendar type, clock type, and numbering system type.\nTraditionally, the Intl API used strings to represent locales, just as Unicode does. This is a simple and lightweight solution that works well. Adding a Locale class, however, adds ease of parsing and manipulating the language, script, and region, as well as extension tags. The following properties of Intl.Locale correspond to Unicode locale identifier subtags:\n\n\n\nProperty\nCorresponding subtag\n\n\n\n\nlanguage\nlanguage (first part)\n\n\nscript\nscript (second part)\n\n\nregion\nregion (second/third part)\n\n\ncalendar\nca (extension)\n\n\ncaseFirst\nkf (extension)\n\n\ncollation\nco (extension)\n\n\nhourCycle\nhc (extension)\n\n\nnumberingSystem\nnu (extension)\n\n\nnumeric\nkn (extension)\n\n\n\nThe information above is exactly provided as-is when the Locale object is constructed, without consulting any external database. The Intl.Locale object additionally provides some methods that return information about the locale's real-world information, such as available calendars, collations, and numbering systems. ",
    "Intl.Collator": "The Intl.Collator object enables language-sensitive string comparison. ",
    "Intl.NumberFormat": "The Intl.NumberFormat object enables language-sensitive number formatting. ",
    "Intl.DisplayNames": "The Intl.DisplayNames object enables the consistent translation of language, region and script display names. ",
    "Intl.Segmenter": "The Intl.Segmenter object enables locale-sensitive text segmentation, enabling you to get meaningful items (graphemes, words or sentences) from a string. ",
    "Intl.supportedValuesOf()": "The Intl.supportedValuesOf() static method returns an array containing the supported calendar, collation, currency, numbering systems, or unit values supported by the implementation. \n Duplicates are omitted and the array is sorted in ascending lexicographical order (or more precisely, using Array.prototype.sort() with an undefined compare function). \n \n  The method can be used to feature-test whether values are supported in a particular implementation and download a polyfill only if necessary.\n  It can also be used to build UIs that allow users to select their preferred localized values, for example when the UI is created from WebGL or server-side.\n ",
    "Intl.RelativeTimeFormat": "The Intl.RelativeTimeFormat object enables language-sensitive relative time formatting. ",
    "Intl.ListFormat": "The Intl.ListFormat object enables language-sensitive list formatting. ",
    "Intl.DurationFormat": "Experimental: This is an experimental technologyCheck the Browser compatibility table carefully before using this in production. \n The Intl.DurationFormat object enables language-sensitive duration formatting. ",
    "Intl.DateTimeFormat": "The Intl.DateTimeFormat object enables language-sensitive date and time formatting. ",
    "Intl.PluralRules": "\n  Languages use different patterns for expressing both plural numbers of items (cardinal numbers) and for expressing the order of items (ordinal numbers).\n  English has two forms for expressing cardinal numbers: one for the singular \"item\" (1 hour, 1 dog, 1 fish) and the other for zero or any other number of \"items\" (0 hours, 2 lemmings, 100000.5 fish), while Chinese has only one form, and Arabic has six!\n  Similarly, English has four forms for expressing ordinal numbers: \"th\", \"st\", \"nd\", \"rd\", giving the sequence: 0th, 1st, 2nd, 3rd, 4th, 5th, ..., 21st, 22nd, 23rd, 24th, 25th, and so on, while both Chinese and Arabic only have one form for ordinal numbers.\n\n\n  Given a particular language and set of formatting options, the methods Intl.PluralRules.prototype.select() and Intl.PluralRules.prototype.selectRange() return a tag that represents the plural form of a single or a range of numbers, cardinal or ordinal.\n  Code can use the returned tags to represent numbers appropriately for the given language.\n  The full set of tags that might be returned are: zero, one, two, few, many, and other (the \"general\" plural form, also used if the language only has one form).\n\n\n  As English only has two forms for cardinal numbers, the select() method returns only two tags: \"one\" for the singular case, and \"other\" for all other cardinal numbers.\n  This allows construction of sentences that make sense in English for each case, such as: \"1 dog is happy; do you want to play with it?\" and \"10 dogs are happy; do you want to play with them?\".\n\n\n  Creating appropriate sentences for each form depends on the language, and even in English may not be as simple as just adding \"s\" to a noun to make the plural form.\n  Using the example above, we see that the form may affect:\n\n\nNouns: 1 dogs/2 dogs (but not \"fish\" or \"sheep\", which have the same singular and plural form).\nVerbs: 1 dog is happy, 2 dogs are happy\nPronouns (and other referents): Do you want to play with it / them.\n\nOther languages have more forms, and choosing appropriate sentences can be even more complex.\n\nselect() can return any of four tags for ordinal numbers in English, representing each of the allowed forms: one for \"st\" numbers (1, 21, 31, ...), two for \"nd\" numbers (2, 22, 32, ...), few for \"rd\" numbers (3, 33, 43, ...), and other for \"th\" numbers (0, 4-20, etc.).\n  Again, the returned tags allow appropriate formatting of strings describing an ordinal number.\n\n\n  For more information about the rules and how they are used, see Plural Rules.\n  For a list of the rules and how they apply for different languages, see the LDML Language Plural Rules.\n ",
    "Intl.getCanonicalLocales()": "\n  The Intl.getCanonicalLocales() static method returns an array\n  containing the canonical locale names. Duplicates will be omitted and elements will be\n  validated as structurally valid language tags.\n ",
    "Intl.Collator.prototype.compare()": "\n  The compare() method of Intl.Collator instances compares two\n  strings according to the sort order of this collator object.\n ",
    "Intl.Collator.prototype.resolvedOptions()": "The resulting object has the following properties:\n\nlocale\n\n\n      The BCP 47 language tag for the locale actually used. If any Unicode extension\n      values were requested in the input BCP 47 language tag that led to this locale,\n      the key-value pairs that were requested and are supported for this locale are\n      included in locale.\n    \n\nusage, sensitivity, ignorePunctuation\n\n\n      The values provided for these properties in the options argument or\n      filled in as defaults.\n    \n\ncollation\n\n\n      The value requested using the Unicode extension key \"co\", if it is\n      supported for locale, or \"default\".\n    \n\nnumeric, caseFirst\n\n\n      The values requested for these properties in the options argument or\n      using the Unicode extension keys \"kn\" and \"kf\" or filled\n      in as defaults. If the implementation does not support these properties, they are\n      omitted.\n    \n\n ",
    "Intl.Collator.supportedLocalesOf()": "The Intl.Collator.supportedLocalesOf() static method returns an array containing those of the provided locales that are supported in collation without having to fall back to the runtime's default locale. ",
    "Intl.Collator() constructor": "The Intl.Collator() constructor creates Intl.Collator objects. ",
    "Intl.DateTimeFormat.supportedLocalesOf()": "The Intl.DateTimeFormat.supportedLocalesOf() static method returns an array containing those of the provided locales that are supported in date and time formatting without having to fall back to the runtime's default locale. ",
    "Intl.DateTimeFormat.prototype.formatRange()": "\n  The formatRange() method of Intl.DateTimeFormat instances formats a\n  date range in the most concise way based on the locales and\n  options provided when instantiating this\n  Intl.DateTimeFormat object.\n ",
    "Intl.DateTimeFormat.prototype.resolvedOptions()": "The resulting object has the following properties:\n\nlocale\n\n\n      The BCP 47 language tag for the locale actually used. If any Unicode extension\n      values were requested in the input BCP 47 language tag that led to this locale,\n      the key-value pairs that were requested and are supported for this locale are\n      included in locale.\n    \n\ncalendar\n\nE.g. \"gregory\"\n\nnumberingSystem\n\n\n      The values requested using the Unicode extension keys \"ca\" and\n      \"nu\" or filled in as default values.\n    \n\ntimeZone\n\n\n      The value provided for this property in the options argument;\n      defaults to the runtime's default time zone. Should never be undefined.\n    \n\nhour12\n\n\n      The value provided for this property in the options argument or\n      filled in as a default.\n    \n\nweekday, era, year, month, day, hour, minute, second, timeZoneName\n\n\n      The values resulting from format matching between the corresponding properties in\n      the options argument and the available combinations and\n      representations for date-time formatting in the selected locale. Some of these\n      properties may not be present, indicating that the corresponding components will\n      not be represented in formatted output.\n    \n\n ",
    "Intl.DateTimeFormat.prototype.formatRangeToParts()": "\n  The formatRangeToParts() method of Intl.DateTimeFormat instances returns an array of locale-specific tokens representing each part of the formatted date\n  range produced by this Intl.DateTimeFormat object.\n ",
    "Intl.DateTimeFormat.prototype.format()": "The format() method of Intl.DateTimeFormat instances formats a date according to the locale and formatting options of this Intl.DateTimeFormat object. ",
    "Intl.DateTimeFormat() constructor": "The Intl.DateTimeFormat() constructor creates Intl.DateTimeFormat objects. ",
    "Intl.DateTimeFormat.prototype.formatToParts()": "\n  The formatToParts() method is useful for custom formatting of date\n  strings. It returns an Array of objects containing the locale-specific\n  tokens from which it possible to build custom strings while preserving the\n  locale-specific parts. The structure the formatToParts() method returns,\n  looks like this:\n\njs[\n  { type: \"day\", value: \"17\" },\n  { type: \"weekday\", value: \"Monday\" },\n];\n\nPossible types are the following:\n\nday\n\nThe string used for the day, for example \"17\".\n\ndayPeriod\n\n\n      The string used for the day period, for example, \"AM\",\n      \"PM\", \"in the morning\", or \"noon\"\n\n\nera\n\nThe string used for the era, for example \"BC\" or \"AD\".\n\nfractionalSecond\n\nThe string used for the fractional seconds, for example \"0\" or \"00\" or \"000\".\n\nhour\n\nThe string used for the hour, for example \"3\" or \"03\".\n\nliteral\n\n\n      The string used for separating date and time values, for example \"/\",\n      \",\", \"o'clock\", \"de\", etc.\n    \n\nminute\n\nThe string used for the minute, for example \"00\".\n\nmonth\n\nThe string used for the month, for example \"12\".\n\nrelatedYear\n\n\n      The string used for the related 4-digit Gregorian year, in the event that the\n      calendar's representation would be a yearName instead of a year, for example \"2019\".\n    \n\nsecond\n\nThe string used for the second, for example \"07\" or \"42\".\n\ntimeZone\n\nThe string used for the name of the time zone, for example \"UTC\". Default is the timezone of the current environment.\n\nweekday\n\nThe string used for the weekday, for example \"M\", \"Monday\", or \"Montag\".\n\nyear\n\nThe string used for the year, for example \"2012\" or \"96\".\n\nyearName\n\nThe string used for the yearName in relevant contexts, for example \"geng-zi\"\n\n ",
    "Intl.DisplayNames.prototype.of()": "The of() method of Intl.DisplayNames instances receives a code and returns a string based on the locale and options provided when instantiating this Intl.DisplayNames object. ",
    "Intl.DisplayNames.supportedLocalesOf()": "The Intl.DisplayNames.supportedLocalesOf() static method returns an array containing those of the provided locales that are supported in display names without having to fall back to the runtime's default locale. ",
    "Intl.DisplayNames() constructor": "The Intl.DisplayNames() constructor creates Intl.DisplayNames objects. ",
    "Intl.DisplayNames.prototype.resolvedOptions()": "The object returned by resolvedOptions() has the following properties:\n\nlocale\n\n\n      The BCP 47 language tag for the locale actually used. If any Unicode extension\n      values were requested in the input BCP 47 language tag that led to this locale,\n      the key-value pairs that were requested and are supported for this locale are\n      included in locale.\n    \n\nstyle\n\n\n      The value provided for this property in the options argument of the\n      constructor or the default value (\"long\"). Its value is either\n      \"long\", \"short\", or \"narrow\".\n    \n\ntype\n\n\n      The value provided for this property in the options argument of the\n      constructor or the default value (\"language\"). Its value is either\n      \"language\", \"region\", \"script\", or\n      \"currency\".\n    \n\nfallback\n\n\n      The value provided for this property in the options argument of the constructor or\n      the default value (\"code\"). Its value is either \"code\"\n      or \"none\".\n    \n\n ",
    "Intl.DurationFormat() constructor": "For each time segment, an Intl.NumberFormat object is constructed under the hood. It uses the following options (see Intl.NumberFormat() for details):\n\nnumberingSystem: the value of options.numberingSystem\n\nWhen milliseconds, microseconds, or nanoseconds uses the \"numeric\" style, the following options are also used:\n\nminimumFractionDigits: 0 when options.fractionalDigits is undefined, options.fractionalDigits otherwise\nmaximumFractionDigits: 9 when options.fractionalDigits is undefined, options.fractionalDigits otherwise\nroundingMode: \"trunc\"\n\nWhen the time segment uses the \"2-digit\" style, the following options are also used:\n\nminimumIntegerDigits: 2\n\nWhen the time segment uses the \"long\", \"short\", or \"narrow\" style, the following options are also used:\n\nstyle: \"unit\" when \"long\", \"short\", or \"narrow\" is specified, undefined otherwise\nunit: the currently formatted unit (\"years\", \"days\", \"nanoseconds\", etc.)\nunitDisplay: the value of the time segment style (\"long\", \"short\", or \"narrow\")\n ",
    "Intl.DurationFormat.prototype.format()": "Experimental: This is an experimental technologyCheck the Browser compatibility table carefully before using this in production. \n The format() method of Intl.DurationFormat instances formats a duration according to the locale and formatting options of this Intl.DurationFormat object. ",
    "Intl.DurationFormat.supportedLocalesOf()": "Experimental: This is an experimental technologyCheck the Browser compatibility table carefully before using this in production. \n The Intl.DurationFormat.supportedLocalesOf() static method returns an array containing those of the provided locales that are supported in duration formatting without having to fall back to the runtime's default locale. ",
    "Intl.DurationFormat.prototype.resolvedOptions()": "The resulting object has the following properties:\n\nlocale\n\nThe BCP 47 language tag for the locale used. If any Unicode extension values were requested in the input BCP 47 language tag that led to this locale, the key-value pairs that were requested and are supported for this locale are included in locale.\n\nstyle\n\nOne of the strings \"long\", \"short\", \"narrow\", or \"digital\" identifying the duration formatting style used.\n\nyears\n\nOne of the strings \"long\", \"short\", or \"narrow\" identifying the formatting style used for the years field.\n\nyearsDisplay\n\nOne of the strings \"auto\" or \"always\" identifying when to display the years field.\n\nmonths\n\nOne of the strings \"long\", \"short\", and \"narrow\" identifying the formatting style used for the months field.\n\nmonthsDisplay\n\nOne of the strings \"auto\" or \"always\" identifying when to display the months field.\n\nweeks\n\nOne of the strings \"long\", \"short\", and \"narrow\" identifying the formatting style used for the weeks field.\n\nweeksDisplay\n\nOne of the strings \"auto\" or \"always\" identifying when to display the weeks field.\n\ndays\n\nOne of the strings \"long\", \"short\", and \"narrow\" identifying the formatting style used for the days field.\n\ndaysDisplay\n\nOne of the strings \"auto\" or \"always\" identifying when to display the days field.\n\nhours\n\nOne of the strings \"long\", \"short\", \"narrow\", \"2-digit\", or \"numeric\" identifying the formatting style used for the hours field.\n\nhoursDisplay\n\nOne of the strings \"auto\" or \"always\" identifying when to display the hours field.\n\nminutes\n\nOne of the strings \"long\", \"short\", \"narrow\", \"2-digit\", or \"numeric\" identifying the formatting style used for the minutes field.\n\nminutesDisplay\n\nOne of the strings \"auto\" or \"always\" identifying when to display the minutes field.\n\nseconds\n\nOne of the strings \"long\", \"short\", \"narrow\", \"2-digit\", or \"numeric\" identifying the formatting style used for the seconds field.\n\nsecondsDisplay\n\nOne of the strings \"auto\" or \"always\" identifying when to display the seconds field.\n\nmilliseconds\n\nOne of the strings \"long\", \"short\", \"narrow\", or \"numeric\" identifying the formatting style used for the milliseconds field.\n\nmillisecondsDisplay\n\nOne of the strings \"auto\" or \"always\" identifying when to display the millisecondsDisplay field.\n\nmicroseconds\n\nOne of the strings \"long\", \"short\", \"narrow\", or \"numeric\" identifying the formatting style used for the microseconds field.\n\nmicrosecondsDisplay\n\nOne of the strings \"auto\" or \"always\" identifying when to display the microsecondsDisplay field.\n\nnanoseconds\n\nOne of the strings \"long\", \"short\", \"narrow\", or \"numeric\" identifying the formatting style used for the nanoseconds field.\n\nnanosecondsDisplay\n\nOne of the strings \"auto\" or \"always\" identifying when to display the nanosecondsDisplay field.\n\nfractionalDigits\n\nA number, identifying the number of fractional digits used with numeric styles.\n\nnumberingSystem\n\nThe value provided for this property in the options argument, if present, or the value requested using the Unicode extension key nu or filled in as a default.\n\n ",
    "Intl.DurationFormat.prototype.formatToParts()": "The formatToParts() method is useful for custom formatting of duration objects. It returns an Array of objects containing the locale-specific tokens from which it possible to build custom strings while preserving the locale-specific parts. The structure the formatToParts() method returns, looks like this:\njs[\n  { type: \"integer\", value: \"7\", unit: \"hour\" },\n  { type: \"literal\", value: \" \", unit: \"hour\" },\n  { type: \"unit\", value: \"hr\", unit: \"hour\" },\n  { type: \"literal\", value: \", \" },\n  { type: \"integer\", value: \"8\", unit: \"minute\" },\n  { type: \"literal\", value: \" \", unit: \"minute\" },\n  { type: \"unit\", value: \"min\", unit: \"minute\" },\n];\n ",
    "Intl.ListFormat.supportedLocalesOf()": "The Intl.ListFormat.supportedLocalesOf() static method returns an array containing those of the provided locales that are supported in list formatting without having to fall back to the runtime's default locale. ",
    "Intl.ListFormat.prototype.resolvedOptions()": "The object returned by resolvedOptions() has the following properties:\n\nlocale\n\n\n      The BCP 47 language tag for the locale actually used. If any Unicode extension\n      values were requested in the input BCP 47 language tag that led to this locale,\n      the key-value pairs that were requested and are supported for this locale are\n      included in locale.\n    \n\nstyle\n\n\n      The value provided for this property in the options argument of the\n      constructor or the default value (\"long\"). Its value is either\n      \"long\", \"short\", or \"narrow\".\n    \n\ntype\n\n\n      The value provided for this property in the options argument of the\n      constructor or the default value (\"conjunction\"). Its value is either\n      \"conjunction\", \"disjunction\", or \"unit\".\n    \n\n ",
    "Intl.ListFormat.prototype.formatToParts()": "\n  Whereas Intl.ListFormat.prototype.format() returns a string being the formatted version\n  of the list (according to the given locale and style options),\n  formatToParts() returns an array of the different components of the\n  formatted string.\n\n\n  Each element of the resulting array has two properties: type and\n  value. The type property may be either\n  \"element\", which refers to a value from the list, or\n  \"literal\" which refers to a linguistic construct. The value\n  property gives the content, as a string, of the token.\n\n\n  The locale and style options used for formatting are given when constructing the\n  Intl.ListFormat instance.\n ",
    "Intl.ListFormat() constructor": "The Intl.ListFormat() constructor creates Intl.ListFormat objects. ",
    "Intl.ListFormat.prototype.format()": "\n  The format() method returns a string that has been\n  formatted based on parameters provided in the Intl.ListFormat object. The\n  locales and options parameters customize the behavior of\n  format() and let applications specify the language conventions that\n  should be used to format the list.\n ",
    "Intl.Locale.prototype.hourCycle": "There are 2 main types of time keeping conventions (clocks) used around the world: the 12 hour clock and the 24 hour clock. The hourCycle property's value is set at construction time, either through the hc key of the locale identifier or through the hourCycle option of the Intl.Locale() constructor. The latter takes priority if they are both present; and if neither is present, the property has value undefined.\nFor a list of supported hour cycle types, see Intl.Locale.prototype.getHourCycles().\nThe set accessor of hourCycle is undefined. You cannot change this property directly. ",
    "Intl.Locale.prototype.maximize()": "\n  Sometimes, it is convenient to be able to identify the most likely locale language\n  identifier subtags based on an incomplete language ID. The Add Likely Subtags\n  algorithm gives us this functionality. For instance, given the language ID \"en\", the\n  algorithm would return \"en-Latn-US\", since English can only be written in the Latin\n  script, and is most likely to be used in the United States, as it is the largest\n  English-speaking country in the world. This functionality is provided to JavaScript\n  programmers via the maximize() method. maximize() only\n  affects the main subtags that comprise the language identifier: language, script, and region subtags.\n  Other subtags after the \"-u\" in the locale identifier are called extension subtags and\n  are not affected by the maximize() method. Examples of these subtags\n  include hourCycle,\n  calendar, and numeric.\n ",
    "Intl.Locale.prototype.getTimeZones()": "The getTimeZones() method of Intl.Locale instances returns a list of supported time zones for this locale. \n \nNote: In some versions of some browsers, this method was implemented as an accessor property called timeZones. However, because it returns a new array on each access, it is now implemented as a method to prevent the situation of locale.timeZones === locale.timeZones returning false. Check the browser compatibility table for details.\n ",
    "Intl.Locale.prototype.numeric": "Like caseFirst, numeric represents a modification to the collation rules utilized by the locale. numeric is a boolean value, which means that it can be either true or false. If numeric is set to false, there will be no special handling of numeric values in strings. If numeric is set to true, then the locale will take numeric characters into account when collating strings. This special numeric handling means that sequences of decimal digits will be compared as numbers. For example, the string \"A-21\" will be considered less than \"A-123\". ",
    "Intl.Locale.prototype.getNumberingSystems()": "The getNumberingSystems() method of Intl.Locale instances returns a list of one or more unique numbering system identifiers for this locale. \n \nNote: In some versions of some browsers, this method was implemented as an accessor property called numberingSystems. However, because it returns a new array on each access, it is now implemented as a method to prevent the situation of locale.numberingSystems === locale.numberingSystems returning false. Check the browser compatibility table for details.\n ",
    "Intl.Locale.prototype.getHourCycles()": "The getHourCycles() method of Intl.Locale instances returns a list of one or more unique hour cycle identifiers for this locale. \n \nNote: In some versions of some browsers, this method was implemented as an accessor property called hourCycles. However, because it returns a new array on each access, it is now implemented as a method to prevent the situation of locale.hourCycles === locale.hourCycles returning false. Check the browser compatibility table for details.\n ",
    "Intl.Locale.prototype.collation": "Collation is the process of ordering strings of characters. It is used whenever strings must be sorted and placed into a certain order, from search query results to ordering records in a database. While the idea of placing strings in order might seem trivial, the idea of order can vary from region to region and language to language. The collation property's value is set at construction time, either through the co key of the locale identifier or through the collation option of the Intl.Locale() constructor. The latter takes priority if they are both present; and if neither is present, the property has value undefined.\nFor a list of supported collation types, see Intl.Locale.prototype.getCollations().\nThe set accessor of collation is undefined. You cannot change this property directly. ",
    "Intl.Locale.prototype.script": "A script, sometimes called writing system, is one of the core attributes of a locale. It indicates the set of symbols, or glyphs, that are used to write a particular language. For instance, the script associated with English is Latin, whereas the script typically associated with Korean is Hangul. In many cases, denoting a script is not strictly necessary, since the language (which is necessary) is only written in a single script. There are exceptions to this rule, however, and it is important to indicate the script whenever possible, in order to have a complete Unicode language identifier. ",
    "Intl.Locale.prototype.toString()": "\n  The Locale object is a JavaScript representation of a concept\n  Unicode locale identifier. Information about a particular locale (language, script,\n  calendar type, etc.) can be encoded in a locale identifier string. To make it easier\n  to work with these locale identifiers, the Locale object was\n  introduced to JavaScript. Calling the toString method on a Locale object\n  will return the identifier string for that particular Locale. The\n  toString method allows Locale instances to be\n  provided as an argument to existing Intl constructors, serialized in\n  JSON, or any other context where an exact string representation is useful.\n ",
    "Intl.Locale.prototype.baseName": "An Intl.Locale object represents a parsed local and options for that locale. The baseName property returns basic, core information about the Locale in the form of a substring of the complete data string. Specifically, the property returns the substring containing the language, and the script and region if available.\nbaseName returns the language [\"-\" script] [\"-\" region] *(\"-\" variant) subsequence of the unicode_language_id grammar. ",
    "Intl.Locale.prototype.region": "The region is an essential part of the locale identifier, as it places the locale in a specific area of the world. Knowing the locale's region is vital to identifying differences between locales. For example, English is spoken in the United Kingdom and the United States of America, but there are differences in spelling and other language conventions between those two countries. Knowing the locale's region helps JavaScript programmers make sure that the content from their sites and applications is correctly displayed when viewed from different areas of the world. ",
    "Intl.Locale.prototype.caseFirst": "A locale's collation rules are used to determine how strings are ordered in that locale. Certain locales use a character's case (UPPERCASE or lowercase) in the collation process. This additional rule can be expressed in a Intl.Locale object's caseFirst property.\nThere are 3 values that the caseFirst property can have, outlined in the table below. ",
    "Intl.Locale.prototype.getCalendars()": "The getCalendars() method of Intl.Locale instances returns a list of one or more unique calendar identifiers for this locale. \n \nNote: In some versions of some browsers, this method was implemented as an accessor property called calendars. However, because it returns a new array on each access, it is now implemented as a method to prevent the situation of locale.calendars === locale.calendars returning false. Check the browser compatibility table for details.\n ",
    "Intl.Locale.prototype.language": "Language is one of the core features of a locale. The Unicode specification treats the language identifier of a locale as the language and the region together (to make a distinction between dialects and variations, e.g. British English vs. American English). The language property of a Intl.Locale returns strictly the locale's language subtag. ",
    "Intl.Locale.prototype.calendar": "While most of the world uses the Gregorian calendar, there are several regional calendar eras used around the world. The calendar property's value is set at construction time, either through the ca key of the locale identifier or through the calendar option of the Intl.Locale() constructor. The latter takes priority if they are both present; and if neither is present, the property has value undefined.\nFor a list of supported calendar types, see Intl.Locale.prototype.getCalendars().\nThe set accessor of calendar is undefined. You cannot change this property directly. ",
    "Intl.Locale() constructor": "The Intl.Locale() constructor creates Intl.Locale objects. ",
    "Intl.Locale.prototype.getTextInfo()": "The getTextInfo() method of Intl.Locale instances returns the ordering of characters indicated by either ltr (left-to-right) or by rtl (right-to-left) for this locale. \n \nNote: In some versions of some browsers, this method was implemented as an accessor property called textInfo. However, because it returns a new object on each access, it is now implemented as a method to prevent the situation of locale.textInfo === locale.textInfo returning false. Check the browser compatibility table for details.\n ",
    "Intl.Locale.prototype.getCollations()": "The getCollations() method of Intl.Locale instances returns a list of one or more collation types for this locale. \n \nNote: In some versions of some browsers, this method was implemented as an accessor property called collations. However, because it returns a new array on each access, it is now implemented as a method to prevent the situation of locale.collations === locale.collations returning false. Check the browser compatibility table for details.\n ",
    "Intl.Locale.prototype.minimize()": "\n  This method carries out the reverse of maximize(),\n  removing any language, script, or region subtags from the locale language identifier\n  (essentially the contents of baseName). This is useful when there are\n  superfluous subtags in the language identifier; for instance, \"en-Latn\" can be\n  simplified to \"en\", since \"Latn\" is the only script used to write English.\n  minimize() only affects the main subtags that comprise\n  the language identifier:\n  language, script, and region subtags. Other subtags after the \"-u\"\n  in the locale identifier are called extension subtags and are not affected by the\n  minimize() method. Examples of these subtags include\n  hourCycle, calendar, and numeric.\n ",
    "Intl.Locale.prototype.numberingSystem": "A numeral system is a system for expressing numbers. The numberingSystem property's value is set at construction time, either through the nu key of the locale identifier or through the numberingSystem option of the Intl.Locale() constructor. The latter takes priority if they are both present; and if neither is present, the property has value undefined.\nFor a list of supported numbering system types, see Intl.Locale.prototype.getNumberingSystems(). ",
    "Intl.Locale.prototype.getWeekInfo()": "The getWeekInfo() method of Intl.Locale instances returns a weekInfo object with the properties firstDay, weekend and minimalDays for this locale. \n \nNote: In some versions of some browsers, this method was implemented as an accessor property called weekInfo. However, because it returns a new object on each access, it is now implemented as a method to prevent the situation of locale.weekInfo === locale.weekInfo returning false. Check the browser compatibility table for details.\n ",
    "Intl.NumberFormat() constructor": "The Intl.NumberFormat() constructor creates Intl.NumberFormat objects. ",
    "Intl.NumberFormat.prototype.formatRangeToParts()": "The formatRangeToParts() method of Intl.NumberFormat instances returns an Array of objects containing the locale-specific tokens from which it is possible to build custom strings while preserving the locale-specific parts. This makes it possible to provide locale-aware custom formatting ranges of number strings. ",
    "Intl.NumberFormat.prototype.resolvedOptions()": "The resolvedOptions() method of Intl.NumberFormat instances returns a new object with properties reflecting the locale and number formatting options computed during initialization of this Intl.NumberFormat object. ",
    "Intl.NumberFormat.supportedLocalesOf()": "The Intl.NumberFormat.supportedLocalesOf() static method returns an array containing those of the provided locales that are supported in number formatting without having to fall back to the runtime's default locale. ",
    "Intl.NumberFormat.prototype.formatToParts()": "\n  The formatToParts() method is useful for custom formatting of number\n  strings. It returns an Array of objects containing the locale-specific\n  tokens from which it possible to build custom strings while preserving the\n  locale-specific parts. The structure the formatToParts() method returns,\n  looks like this:\n\njs[\n  { type: \"integer\", value: \"3\" },\n  { type: \"group\", value: \".\" },\n  { type: \"integer\", value: \"500\" },\n];\n\nPossible types are the following:\n\ncompact\n\nThe exponent in \"long\" or \"short\" form, depending on how compactDisplay (which defaults to short) is specified when notation is set to compact.\n\ncurrency\n\nThe currency string, such as the symbols \"$\" and \"\u00e2\u0082\u00ac\" or the name \"Dollar\", \"Euro\", depending on how currencyDisplay is specified.\n\ndecimal\n\nThe decimal separator string (\".\").\n\nexponentInteger\n\nThe exponent integer value, when notation is set to scientific or engineering.\n\nexponentMinusSign\n\nThe exponent minus sign string (\"-\").\n\nexponentSeparator\n\nThe exponent separator, when notation is set to scientific or engineering.\n\nfraction\n\nThe fraction number.\n\ngroup\n\nThe group separator string (\",\").\n\ninfinity\n\nThe Infinity string (\"\u00e2\u0088\u009e\").\n\ninteger\n\nThe integer number.\n\nliteral\n\nAny literal strings or whitespace in the formatted number.\n\nminusSign\n\nThe minus sign string (\"-\").\n\nnan\n\nThe NaN string (\"NaN\").\n\nplusSign\n\nThe plus sign string (\"+\").\n\npercentSign\n\nThe percent sign string (\"%\").\n\nunit\n\nThe unit string, such as the \"l\" or \"litres\", depending on how unitDisplay is specified.\n\nunknown\n\nThe string for unknown type results.\n\n ",
    "Intl.NumberFormat.prototype.format()": "\nNumber values in JavaScript suffer from loss of precision if they are too big or too small, making the text representation inaccurate.\n  If you are performing calculations with integers larger than Number.MAX_SAFE_INTEGER you should use a BigInt instead, which will format correctly:\n\njsnew Intl.NumberFormat(\"en-US\").format(1234567891234567891); // 1,234,567,891,234,568,000\nnew Intl.NumberFormat(\"en-US\").format(1234567891234567891n); // 1,234,567,891,234,567,891\n\nYou can also pass through very large strings to be formatted as an arbitrary-precision decimal string (if you're performing calculations on the data you will still need to work with BigInt):\njsnew Intl.NumberFormat(\"en-US\").format(\"1234567891234567891\"); // 1,234,567,891,234,567,891\n ",
    "Intl.NumberFormat.prototype.formatRange()": "The formatRange getter function formats a range of numbers into a string according to the locale and formatting options of this Intl.NumberFormat object from which it is called. ",
    "Intl.PluralRules() constructor": "The Intl.PluralRules() constructor creates Intl.PluralRules objects. ",
    "Intl.PluralRules.prototype.selectRange()": "This function selects a pluralization category according to the locale and formatting options of an Intl.PluralRules object.\n\n  Conceptually the behavior is the same as getting plural rules for a single cardinal or ordinal number.\n  Languages have one or more forms for describing ranges, and this method returns the appropriate form given the supplied locale and formatting options.\n  In English there is only one plural form, such as \"1\u00e2\u0080\u009310 apples\", and the method will return other.\n  Other languages can have many forms.\n ",
    "Intl.PluralRules.prototype.select()": "\n  This function selects a pluralization category according to the locale and formatting options of an Intl.PluralRules object.\n  These options are set in the Intl.PluralRules() constructor.\n ",
    "Intl.PluralRules.supportedLocalesOf()": "The Intl.PluralRules.supportedLocalesOf() static method returns an array containing those of the provided locales that are supported in plural rules without having to fall back to the runtime's default locale. ",
    "Intl.PluralRules.prototype.resolvedOptions()": "The resolvedOptions() method of Intl.PluralRules instances returns a new object with properties reflecting the locale and plural formatting options computed during initialization of this Intl.PluralRules object. ",
    "Intl.RelativeTimeFormat.prototype.resolvedOptions()": "The resulting object has the following properties:\n\nlocale\n\nThe BCP 47 language tag for the locale actually used. If any Unicode extension values were requested in the input BCP 47 language tag that led to this locale, the key-value pairs that were requested and are supported for this locale are included in locale.\n\nstyle\n\nThe length of the internationalized message. Possible values are:\n\n\"long\" (default, e.g., in 1 month)\n\"short\" (e.g., in 1 mo.),\nor \"narrow\" (e.g., in 1 mo.). The narrow style could be similar to the short style for some locales.\n\n\nnumeric\n\nThe format of output message. Possible values are:\n\n\"always\" (default, e.g., 1 day ago),\nor \"auto\" (e.g., yesterday). The \"auto\" value allows to not always have to use numeric values in the output.\n\n\nnumberingSystem\n\nThe value requested using the Unicode extension key \"nu\" or filled in as a default.\n\n ",
    "Intl.RelativeTimeFormat.prototype.format()": "The format() method of Intl.RelativeTimeFormat instances formats a value and unit according to the locale and formatting options of this Intl.RelativeTimeFormat object. ",
    "Intl.RelativeTimeFormat() constructor": "The Intl.RelativeTimeFormat() constructor creates Intl.RelativeTimeFormat objects. ",
    "Intl.RelativeTimeFormat.prototype.formatToParts()": "The Intl.RelativeTimeFormat.prototype.formatToParts method is a version of the format method which it returns an array of objects which represent \"parts\" of the object, separating the formatted number into its constituent parts and separating it from other surrounding text. These objects have two properties: type a NumberFormat formatToParts type, and value, which is the String which is the component of the output. If a \"part\" came from NumberFormat, it will have a unit property which indicates the unit being formatted; literals which are part of the larger frame will not have this property. ",
    "Intl.RelativeTimeFormat.supportedLocalesOf()": "The Intl.RelativeTimeFormat.supportedLocalesOf() static method returns an array containing those of the provided locales that are supported in relative time formatting without having to fall back to the runtime's default locale. ",
    "Intl.Segmenter.supportedLocalesOf()": "The Intl.Segmenter.supportedLocalesOf() static method returns an array containing those of the provided locales that are supported in segmentation without having to fall back to the runtime's default locale. ",
    "Intl.Segmenter.prototype.segment()": "The segment() method of Intl.Segmenter instances segments a string according to the locale and granularity of this Intl.Segmenter object. ",
    "Intl.Segmenter.prototype.resolvedOptions()": "The resulting object has the following properties:\n\nlocale\n\n\n      The BCP 47 language tag for the locale actually used. If any Unicode extension\n      values were requested in the input BCP 47 language tag that led to this locale,\n      the key-value pairs that were requested and are supported for this locale are\n      included in locale.\n    \n\ngranularity\n\n\n      The value provided for this property in the options argument or filled\n      in as the default.\n    \n\n ",
    "Segments": "A Segments object is an iterable collection of the segments of a text string. It is returned by a call to the segment() method of an Intl.Segmenter object. ",
    "Intl.Segmenter() constructor": "The Intl.Segmenter() constructor creates Intl.Segmenter objects. "
}